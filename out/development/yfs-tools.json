{"slots":{"-5":{"name":"library","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}}},"handlers":[{"key":1,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":";(function()\nlocal a={}local b=0;function library.addEventHandlers(c)if not c or c.onEvent and c.triggerEvent then return false end;b=b+1;a[b]=c;local d,e,f='table','function','thread'if d~=type(c)then error('You can only add event handlers to table objects!')end;local g={}local function h(c)local i=type(c)return e==i or d==i and h(getmetatable(c).__call)or f==i end;c.onEvent=function(self,j,k,l)if not h(k)then error('Event handler must be a function, a callable object or a thread!')end;l=l or self;if d~=type(l)then error('The value of self must be a table!')end;if not g[j]then g[j]={_=0}end;local m=f==type(k)and function(...)coroutine.resume(k,...)end or k;local k=g[j]local n=k._+1;k[n]={m,l}k._=n;return n end;c.clearEvent=function(self,j,o)if g[j]and g[j][o]then g[j][o]=nil end end;c.clearAllEvents=function(self)g={}end;c.triggerEvent=function(self,j,...)local p=g[j]if p then for q=1,p._ do local k=p[q]if k then k[1](k[2],...)end end end end;return true end;function library.clearAllEventHandlers()for q=1,b do local c=a[q]if c and c.clearAllEvents then c:clearAllEvents()end end end\nend)()"},{"key":2,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":";(function()\nlocal a=DULibrary or{}function a.getLinks(b,c)local d={}if not b then b={}end;for e,f in pairs(unit.getOutPlugs())do local g=unit[f.name]if'table'==type(g)and'function'==type(g.getClass)then local h=true;for i,j in pairs(b)do if not('function'==type(g[i])and j==g[i]():sub(1,#j))then h=false;break end end;if h then if c then table.insert(d,g)else d[f.name]=g end end end end;return d end;function a.getLinksByClass(k,c)return a.getLinks({getClass=k},c)end;function a.getLinkByClass(k)return a.getLinksByClass(k,true)[1]end;function a.getCoreUnit()return a.getLinkByClass('CoreUnit')end;function a.getLinkByName(l)local m=a.getCoreUnit()if not m then error('getLinkByName requires a linked CoreUnit to work')end;local d=a.getLinks()for n,o in pairs(d)do if l==m.getElementNameById(o.getLocalId())then return o end end end\nend)()"},{"key":3,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":"package.preload['YFS-Tools:globals.lua']=(function()\n---@diagnostic disable: lowercase-global\n-- Initialize globals and constants\nConfig = { core = nil, databanks = {}, screens = {} }\nDetectedArch = 0\nDetectedYFS = false\nYFSDB = nil\nYFS_NAMED_POINTS = \"NamedPoints\"\nYFS_ROUTES = \"NamedRoutes\"\nARCH_SAVED_LOCATIONS = \"SavedLocations\"\nDEBUG = false\nWP_EG_ENABLED = false -- Waypointer by EasternGamer\nWP_WOLF_ENABLED = false -- Waypointer AR by Wolfe Labs\nScriptStartTime = 0\nINGAME = system ~= nil\n\nif not INGAME then\n\nelse\n    ScriptStartTime = system.getArkTime()\n    print = system.print\nend\n\nprojector = nil\nclicked = false -- for waypointer\n\nCNID = construct.getId()\nend)\npackage.preload['YFS-Tools:../util/SU.lua']=(function()\nlocal SU = {}\n\nlocal strmatch, strlen, tonum = string.match, string.len, tonumber\n\n---@comment Returns s being trimmed of any whitespace from both start and end.\n---@param s string\n---@return string\nfunction SU.Trim(s)\n    if strlen(s) == 0 then return \"\" end\n    return SU.Ltrim(SU.Rtrim(s))\nend\n\n---@comment Returns s being trimmed of any whitespace from the start.\n---@param s string\n---@return string\nfunction SU.Ltrim(s)\n    local res, _ = string.gsub(s, \"^%s+\", \"\")\n    return res\nend\n\n---@comment Returns s being trimmed of any whitespace from the end.\n---@param s string\n---@return string\nfunction SU.Rtrim(s)\n    local res, _ = string.gsub(s, \"%s+$\", \"\")\n    return res\nend\n\nfunction SU.Pad(s, padChar, length)\n    if not s or not length or not padChar or tonum(length) < 1 then return s end\n    return string.rep(padChar, length - s:len()) .. s\nend\n\n---@param s string\n---@param prefix string\n---@return boolean\nfunction SU.StartsWith(s, prefix)\n    if not s or not prefix then return false end\n    return string.sub(s, 1, #prefix) == prefix\nend\n\n---@param s string\n---@param suffix string\n---@return boolean\nfunction SU.EndsWith(s, suffix)\n    if not s or not suffix then return false end\n    return string.sub(s, -#suffix) == suffix\nend\n\n---@param s string\n---@param suffix string\n---@return string\nfunction SU.RtrimChar(s,char)\n    if not s or not char then return s end\n    while #s > 0 and SU.EndsWith(s, char) do\n        s = string.sub(s,1,#s - #char)\n    end\n    return s\nend\n\n---Splits the string into parts, honoring \" and ' as quote chars to make multi-word arguments\n-- SplitQuoted() credits to Yoarii (SVEA)\n---@param s string\n---@return string[]\nfunction SU.SplitQuoted(s)\n    local function isQuote(c) return c == '\"' or c == \"'\" end\n    local function isSpace(c) return c == \" \" end\n\n    local function add(target, v)\n        v = SU.Trim(v)\n        if v:len() > 0 then\n            table.insert(target, #target + 1, v)\n        end\n    end\n\n    local inQuote = false\n    local parts = {} ---@type string[]\n    if type(s) ~= \"string\" or s == \"\" then\n        return parts\n    end\n\n    local current = \"\"\n    for c in string.gmatch(s, \".\") do\n        if isSpace(c) and not inQuote then\n            -- End of non-quoted part\n            add(parts, current)\n            current = \"\"\n        elseif isQuote(c) then\n            if inQuote then -- End of quote\n                add(parts, current)\n                current = \"\"\n                inQuote = false\n            else -- End current, start quoted\n                add(parts, current)\n                current = \"\"\n                inQuote = true\n            end\n        else\n            current = current .. c\n        end\n    end\n\n    -- Add whatever is at the end of the string.\n    add(parts, current)\n\n    return parts\nend\n\n---@comment Returns trueValue if cond is true, otherwise falseValue. nil's will be checked and returned as empty strings.\n---@param cond boolean cond should evaluate to true or false\n---@param trueValue any\n---@param falseValue any\n---@return string\nfunction SU.If(cond, trueValue, falseValue)\n    if cond then\n        return tostring(trueValue or \"\")\n    end\n    return tostring(falseValue or \"\")\nend\n\n---@comment Returns true if char is a printable character\n---@param char string single character\n---@return boolean\nfunction SU.isPrintable(char)\n    return strmatch(char, \"[%g%s]\") ~= nil\nend\n\n---@comment Returns true if char is a printable character\n---@return any Returns the ready string. In case of invalid separator, the original string is returned.\nfunction SU.SplitAndCapitalize(inputString, delimiter)\n    if not inputString or not SU.isPrintable(delimiter) then\n        return inputString\n    end\n    local parts = {}\n    for part in inputString:gmatch(\"[^\" .. delimiter .. \"]+\") do\n        table.insert(parts, part)\n    end\n    for i = 1, #parts do\n        parts[i] = parts[i]:sub(1, 1):upper() .. parts[i]:sub(2)\n    end\n    return table.concat(parts)\nend\n\nreturn SU\nend)\npackage.preload['YFS-Tools:../util/out.lua']=(function()\n--- functions with chat output\nlocal o = {}\n\nfunction o.PrettyDistance(dist)\n    if dist < 10000 then\n        return Round(dist,2)..\" m\"\n    end\n    if dist < 200000 then\n        return Round(dist/1000,2)..\" km\"\n    end\n    return Round(dist/200000,2)..\" SU\"\nend\n\n---@param mass number mass in kg\n---@return string prettyfied mass for display\nfunction o.PrettyMass(mass)\n    if mass > 1000000 then\n        return Round(mass / 1000000,2)..\" KT\"\n    end\n    if mass > 1000 then\n        return Round(mass / 1000,2)..\" tons\"\n    end\n    return Round(mass,2)..\" kg\"\nend\n\n---@param s string|any\nfunction o.PrintLines(s)\n    if not s then return end\n    if type(s) ~= \"string\" then s = tostring(s) end\n    for str in s:gmatch(\"([^\\n]+)\") do\n         print(str)\n    end\nend\n\nfunction o.Error(err)\n    o.PrintLines(err)\n    return false\nend\n\nfunction o.DeepPrint(e, maxItems)\n    if IsTable(e) then\n        local cnt = 0\n        maxItems = maxItems or 0\n        for k,v in pairs(e) do\n            if IsTable(v) then\n                P(\"-> \"..k)\n                o.DeepPrint(v, maxItems)\n            elseif type(v) == \"boolean\" then\n                P(k..\": \"..BoolStr(v))\n            elseif type(v) == \"function\" then\n                P(k..\"()\")\n            elseif v == nil then\n                P(k..\" (\"..type(v)..\")\")\n            else\n                P(k..\": \"..tostring(v))\n            end\n            cnt = cnt + 1\n            if maxItems > 0 and cnt >= maxItems then\n               P(\"^:^:^:^: cutoff reached :^:^:^:^\")\n                return\n            end\n        end\n    elseif type(e) == \"boolean\" then\n       P(BoolStr(e))\n    else\n       P(e)\n    end\nend\n\nfunction o.DumpVar(data)\n    -- cache of tables already printed, to avoid infinite recursive loops\n    local tablecache = {}\n    local buffer = \"\"\n    local padder = \"    \"\n    local function _dumpvar(d, depth)\n        local t = type(d)\n        local str = tostring(d)\n        if (t == \"table\") then\n            if (tablecache[str]) then\n                -- table already dumped before, so we dont\n                -- dump it again, just mention it\n                buffer = buffer..\"<\"..str..\">\\n\"\n            else\n                tablecache[str] = (tablecache[str] or 0) + 1\n                buffer = buffer..\"(\"..str..\") {\\n\"\n                for k, v in pairs(d) do\n                    buffer = buffer..string.rep(padder, depth+1)..\"[\"..k..\"] => \"\n                    _dumpvar(v, depth+1)\n                end\n                buffer = buffer..string.rep(padder, depth)..\"}\\n\"\n            end\n        elseif (t == \"boolean\") then\n            buffer = buffer..\"(\"..BoolStr(t)..\")\\n\"\n        elseif (t == \"number\") then\n            buffer = buffer..\"(\"..t..\") \"..str..\"\\n\"\n        else\n            buffer = buffer..\"(\"..t..\") \\\"\"..str..\"\\\"\\n\"\n        end\n    end\n    _dumpvar(data, 0)\n    return buffer\nend\n\nreturn o\nend)\npackage.preload['YFS-Tools:../util/Dtbk.lua']=(function()\n-- Dtbk by Jeronimo\nDtbk = {}\nDtbk.__index = Dtbk;\nfunction Dtbk.new(bank)\n    local self = setmetatable({}, Dtbk)\n    self.DB = bank\n    self.concat = table.concat\n    return self\nend\nfunction Dtbk.hasKey(self,tag)\n    return self.DB.hasKey(tag)\nend\nfunction Dtbk.getString(self,tag)\n    return self.DB.getStringValue(tag)\nend\nfunction Dtbk.setString(self,tag,value)\n    self.DB.setStringValue(tag,value)\nend\nfunction Dtbk.setData(self,tag,value)\n    local str = json.encode(value)\n    self.DB.setStringValue(tag,str)\nend\nfunction Dtbk.getData(self,tag)\n    local tmp = self.DB.getStringValue(tag)\n    if tmp == nil then return nil end\n    local str = json.decode(tmp)\n    return str\nend\nfunction Dtbk.remove(self,key)\n    self.DB.clearValue(key)\nend\nfunction Dtbk.ResetAll(self)\n    self.DB.clear()\nend\n\nend)\npackage.preload['YFS-Tools:libutils.lua']=(function()\nlocal tonum, strmatch = tonumber, string.match\n\nfunction IsTable(obj)\n    return obj ~= nil and type(obj) == \"table\"\nend\n\nfunction GetSortedAssocKeys(source)\n    local L = {}\n    if not IsTable(source) then E(\"[E] Invalid object for GetSortedKeys()!\") return L end\n    for k,_ in pairs(source) do\n        table.insert(L, k)\n    end\n    table.sort(L)\n    return L\nend\n\nfunction Round(num, decimals)\n    local mult = 10^(decimals or 0)\n    return ((num*mult) + (2^52 + 2^51) - (2^52 + 2^51))/mult\nend\n\nfunction TableLen(source)\n    if not IsTable(source) then return 0 end\n    local cnt = 0\n    for _ in pairs(source) do\n      cnt = cnt + 1\n    end\n    return cnt\nend\n\nfunction GetIndex(source, value)\n    if not IsTable(source) then return -1 end\n    for k, v in pairs(source) do\n      if value == v then return k end\n    end\n    return -1\nend\n\n---@param srcTable any\n---@param paramName string\n---@param reqType string|nil\n---@param reqMsg boolean|nil\n---@return any\nfunction GetParamValue(srcTable, paramName, reqType, reqMsg)\n    local err = \"[E] Parameter value missing for \"..paramName\n    if srcTable == nil or not IsTable(srcTable) then\n        if reqMsg == true then P(err) end\n        return nil\n    end\n    for k, v in ipairs(srcTable) do\n        if v == paramName then\n            local idx = k + 1\n            if #srcTable < idx then\n                if reqMsg == true then P(err) end\n                return nil\n            end\n            local val = srcTable[idx]\n            if not reqType or reqType == \"string\" or reqType == \"s\" then\n                if val == '\"\"' or val == \"''\" then return nil end\n                return val\n            elseif ((reqType == \"int\" or reqType == \"i\") and not strmatch(val, \"%D\")) then\n                return tonum(val)\n            elseif reqType == \"number\" or reqType == \"n\" then\n                return tonum(val)\n            elseif reqType == \"bool\" or reqType == \"b\" then\n                if val then return true else return false end\n            end\n            return nil\n        end\n    end\n    if reqMsg == true then E(err) end\n    return nil\nend\n\nfunction PairsByKeys(t, f)\n    local a = {}\n    for n in pairs(t) do table.insert(a, n) end\n    table.sort(a, f)\n    local i = 0 -- iterator variable\n    local iter = function () -- iterator function\n        i = i + 1\n        if a[i] == nil then\n            return nil\n        else\n            return a[i], t[a[i]]\n        end\n    end\n    return iter\nend\n\nfunction BoolState(bool)\n    if bool then\n        return \"enabled\"\n    else\n        return \"disabled\"\n    end\nend\n\nfunction BoolStr(b)\n    if b == true then\n        return \"true\"\n    else\n        return \"false\"\n    end\nend\n\nfunction ScreenOutput(output, chatFooter)\n    local chat = \"Point at screen, CTRL+L, then copy text!\"\n    if #Config.screens >  0 then\n        -- local pre = \"local rslib = require('rslib')\\n\"..\n        -- \"local text = [[\"..output..\"]]\\n\"..\n        -- \"local config = { fontSize = 20 }\\n\"..\n        -- \"rslib.drawQuickText(text, config)\\n\"\n        local font = OutputFont or \"FiraMono\"\n        local pre = \"local text = [[\\n\"..output..\"\\n]]\\n\"..\n[[\nlocal rslib = require('rslib')\nlocal layer = createLayer()\nlocal rx, ry = getResolution()\nlocal fontSize = 15\nlocal font = loadFont(\"]]..font..[[\", fontSize)\nlocal line = 1\nfor str in text:gmatch(\"([^\\n]+)\") do\n    addText(layer, font, str, 20, line*(fontSize+4))\n    line = line + 1\nend ]]\n--setNextFillColor(layer, 1, 0, 0, 1)\n--addBox(layer, rx/4, ry/4, rx/2, ry/2)\n--addText(layer, font, text, rx/1, ry/1)\n        --Config.screens[1].setHTML(pre)\n        Config.screens[1].setRenderScript(pre)\n        if chatFooter and chatFooter:len() then\n            chat = chatFooter..\"\\n\"..chat\n        end\n    else\n        chat = \"Hint: link a screen to PB to easily copy text from it!\"\n    end\n    P(chat)\n    return true\nend\nend)\npackage.preload['YFS-Tools:commands.lua']=(function()\n--TODO: refactor commands to use WM instead of databank data\nlocal cmd = {}\n\n-- requires libutils, globals PM, SU, YFSDB etc.\n-- WaypointInfo only used for WarpCostCmd()\n\nlocal strmatch, sformat, strlen = string.match, string.format, string.len\nlocal tonum, uclamp, mabs, max, floor, ceil = tonumber, utils.clamp, math.abs, math.max, math.floor, math.ceil\n\n-- Local functions\n\n---@comment Adds for each existing waypoint listed in \"wpnames\" an extra \"Flight\" waypoint\n--- at the given altitude with the given name suffix.\n--- Already existing waypoints with the suffix'ed name will have their altitude changed!\n--- Returns a list of \"connected\" waypoints, e.g.\n--- 1 landed -> 1 flight -> 2 flight -> 2 landed -> 2 flight -> 3 flight -> 3 landed  etc.\n--- as 2nd result; 1st result is the updated full waypoints list.\n---@param wpdata table\n---@param wpnames table\n---@param altitude number\n---@param suffix string\nlocal function yfsAddAltitudeWaypoints(wpdata, wpnames, altitude, suffix)\n    local cnt = 0\n    local names = {}\n    local wpCnt = #wpnames\n    for _,k in ipairs(wpnames) do\n        local wp = wpdata.v[k]\n        if wp ~= nil then\n            cnt = cnt + 1\n            local wpN = k .. suffix\n            if cnt > 1 then table.insert(names, wpN) end\n            table.insert(names, k)\n            if cnt < wpCnt then table.insert(names, wpN) end\n            local newPos = PM.ReplaceAltitudeInPos(wp.pos, altitude)\n            if wpdata.v[wpN] ~= nil then\n                wpdata.v[wpN].pos = newPos\n            else\n                wpdata.v[wpN] = { pos = newPos }\n                P(wpN ..\"  \" .. newPos)\n            end\n        end\n    end\n    if cnt == 0 then\n        P(\"[E] No waypoints processed!\")\n        return nil,nil\n    end\n    P(\"[I] \"..cnt..\" waypoints at \"..altitude..\"m added (or changed)!\")\n    return wpdata, names\nend\n\nlocal function storeYFSData(keyName, data)\n    if not DetectedYFS or not keyName then return false end\n    YFSDB:setData(keyName, data)\n    return true\nend\n\nlocal function getYFSData(keyName)\n    if not DetectedYFS or not keyName then return false end\n    local data = YFSDB:getData(keyName)\n    if data == nil or not IsTable(data.v) then\n        return false\n    end\n    return data\nend\n\nlocal function storeYFSNamedWaypoints(data)\n    storeYFSData(YFS_NAMED_POINTS, data)\nend\n\nlocal function storeYFSRoutes(data)\n    storeYFSData(YFS_ROUTES, data)\nend\n\n-- Class functions\n\nfunction cmd.GetYFSNamedWaypoints(muteMsg)\n    if not DetectedYFS then\n        return E(\"[E] Linked YFS databank required!\")\n    end\n    local namedWP = getYFSData(YFS_NAMED_POINTS)\n    if not namedWP and not muteMsg then\n        P(\"[I] No named waypoints\")\n    end\n    return namedWP\nend\n\nfunction cmd.GetYFSRoutes()\n    if not DetectedYFS then\n        return E(\"[E] Linked YFS databank required!\")\n    end\n    local data = getYFSData(YFS_ROUTES)\n    if not data then\n        return E('[I] No YFS routes found.')\n    end\n    return data\nend\n\nfunction cmd.PlanetInfoCmd(text)\n    PM.PlanetInfo(text)\nend\n\nfunction cmd.PrintAltitudeCmd(text)\n    P(Out.PrettyDistance(PM.Altitude()))\nend\n\nfunction cmd.PrintPosCmd(text)\n    P(PM.GetCurrentPosString())\nend\n\nfunction cmd.PrintWorldPosCmd(text)\n    P(PM.Vec3ToPosString(PM.WorldPosVec3()))\nend\n\nfunction cmd.WarpCostCmd(text)\n    CalcWarpCost(text)\nend\n\n---@comment with WM: create commands to recreate waypoints in either YFS or ArchHud format\nfunction cmd.WpSaveNamedCmd(text, isYfs)\n    if not WM or not WM:hasPoints() then\n        return E(\"[E] No waypoints to export.\")\n    end\n    local output = \"\"\n    for _,wp in ipairs(WM:getSorted()) do\n        local pos = wp:AsString()\n        if isYfs then\n            pos = \"pos-save-as '\" .. wp:getName() .. \"' -pos \" .. pos\n        else\n            pos = \"/addlocation \" .. wp:getName() .. \" \" .. pos\n        end\n        output = output .. pos .. \"\\n\"\n        P(pos)\n    end\n    ScreenOutput(output)\nend\n\nfunction cmd.ArchSaveNamedCmd(text)\n    cmd.WpSaveNamedCmd(text, false)\nend\n\n---@comment with WM: output name and position for all waypoints\nfunction cmd.WpExportCmd(text)\n    if not WM or not WM:hasPoints() then\n        return E(\"[E] No waypoints to export.\")\n    end\n    local output = \"\"\n    local wplist = WM:getSorted()\n    for _,wp in ipairs(wplist) do\n        local s = wp:getName() .. \"\\n\" .. wp:AsString() .. \"\\n\"\n        output = output .. s\n    end\n    P(output)\n    ScreenOutput(output)\nend\n\nfunction cmd.WpAltitudeCeilingCmd(text)\n    local wpnames = cmd.GetYFSNamedWaypoints()\n    if not wpnames then return end\n\n    -- 0 parse params to find a) name and b) new altitude value\n    local parts = SU.SplitQuoted(text)\n    if #parts ~= 2 then\n        P(\"[E] Parameter(s) missing: 'name 1' 'name 2'\")\n        return E(\"Example: /wp-altitude-ceiling 'Base 1' 'Base 2'\")\n    end\n    local wpName1 = parts[1]\n    local wpName2 = parts[2]\n\n    -- 2 find named waypoint as per params\n    local wp1found, wp2found = true, true\n    if wpnames.v[wpName1] == nil or wpnames.v[wpName1] == \"\" then\n        P(\"[E] Waypoint '\".. wpName1 ..\"' not found.\")\n        wp1found = false\n    end\n    if wpnames.v[wpName2] == nil or wpnames.v[wpName2] == \"\" then\n        P(\"[E] Waypoint '\".. wpName2 ..\"' not found.\")\n        wp2found = false\n    end\n    if not wp1found or not wp2found then return end\n    if wpnames.v[wpName1] == wpnames.v[wpName2] then\n        return E(\"[E] Parameters invalid (same names).\")\n    end\n\n    -- 3 get waypoint's altitudes and update the lower one\n    local alt1 = PM.GetAltitudeFromPos(wpnames.v[wpName1].pos)\n    local alt2 = PM.GetAltitudeFromPos(wpnames.v[wpName2].pos)\n    if alt1 == alt2 then\n        P(\"[I] Waypoints had same altitude, no changes applied.\")\n        return\n    end\n    local target, targetAlt = \"\", 0\n    if alt1 > alt2 then\n        target = wpName2\n        targetAlt = alt1\n    else\n        target = wpName1\n        targetAlt = alt2\n    end\n    local newPos = PM.ReplaceAltitudeInPos(wpnames.v[target].pos, targetAlt)\n    wpnames.v[target].pos = newPos\n    P(\"[I] Waypoint '\"..target..\"' changed to:\")\n    P(newPos)\n\n    -- 4 json.encode data and write back to DB\n    storeYFSNamedWaypoints(wpnames)\n    return true\nend\n\nfunction cmd.GetStoredLocations(points) -- for ArchHud only\n    if not points or not IsTable(points) then return end\n    for _,p in ipairs(points) do\n        if p.name and p.position and p.position.x and p.position.y and p.position.z then\n            P(\"[I] Location '\".. p.name ..\"' found.\")\n            local pos = '::pos{0,0,'.. p.position.x .. ',' .. p.position.y .. ',' .. p.position.z ..'}'\n            PM.CreateWaypoint(pos, p.name)\n        end\n    end\nend\n\nfunction cmd.YfsAddAltitudeWpCmd(text)\n    local wpdata = cmd.GetYFSNamedWaypoints()\n    if not wpdata or not IsTable(wpdata.v) or TableLen(wpdata.v) == 0 then\n        return E(\"[E] No waypoints.\")\n    end\n\n    local example = \"\\nExample: /yfs-add-altitude-wp -altitude 450 -suffix 'F'\"\n    local args = SU.SplitQuoted(text)\n    local pStart = GetParamValue(args, \"-wpStartsWith\", \"s\")\n    if #args < 1 then\n        return E(\"[E] Parameter missing: -altitude\"..example)\n    end\n    local pAlt = GetParamValue(args, \"-altitude\", \"n\", true)\n    local pSuf = GetParamValue(args, \"-suffix\", \"s\")\n    if not pSuf or pSuf == \"\" then pSuf = \"F\" end\n    if pAlt < -100 or pAlt > 20000 then\n        return E(\"[E] -altitude value out of range (-100 .. 20000)\"..example)\n    end\n\n    -- need a sorted list of names, can't use wpdata as that is being modified\n    local wplist = {}\n    for k in PairsByKeys(wpdata.v) do\n        if not pStart or k:find(pStart) > 0 then\n            table.insert(wplist, k)\n        end\n    end\n    local newData, names = yfsAddAltitudeWaypoints(wpdata, wplist, pAlt, pSuf)\n    if newData ~= nil and names ~= nil then\n        storeYFSNamedWaypoints(newData)\n    end\n    return true\nend\n\nfunction cmd.YfsBuildRouteFromWpCmd(text)\n    local wpdata = cmd.GetYFSNamedWaypoints()\n    if not wpdata or not IsTable(wpdata.v) or TableLen(wpdata.v) == 0 then\n        return E(\"[E] No waypoints.\")\n    end\n\n    local rdata = cmd.GetYFSRoutes()\n    if not rdata or not IsTable(rdata.v) or TableLen(rdata.v) == 0 then\n        -- Initializing routes\n        rdata = { v = {}, t = \"table\" }\n    else\n    end\n\n    local example = \"\\nExample: /yfs-build-route-from-wp -name 'Route' -altitude 450 -wpStartsWith 'Chr' -suffix 'F'\\n-suffix is optional, default F (Flight)\"\n    local args = SU.SplitQuoted(text)\n    if #args < 1 then\n        return E(\"[E] Parameters missing!\"..example)\n    end\n\n    local pName  = GetParamValue(args, \"-name\", \"s\", true)\n    if not pName then return end\n    local pStart = GetParamValue(args, \"-wpStartsWith\", \"s\")\n    local pAlt   = GetParamValue(args, \"-altitude\", \"n\", true)\n    if not pAlt then return end\n    local pSuf   = GetParamValue(args, \"-prefix\", \"s\")\n    local pMarginL = GetParamValue(args, \"-marginL\", \"n\")\n    local pMarginF = GetParamValue(args, \"-marginF\", \"n\")\n    local pMaxSpeed = GetParamValue(args, \"-maxSpeed\", \"n\")\n    local pFinalSpeedF = GetParamValue(args, \"-finalSpeedF\", \"n\")\n    -- some sanity checks, review later\n    pMarginL = uclamp(pMarginL or 0.1, 0.1, 100) -- landed position margin\n    pMarginF = uclamp(pMarginF or 0.1, 0.1, 100) -- flight position margin\n    pMaxSpeed = uclamp(pMaxSpeed or 0, 0, 1200) -- max speed at flight\n    pFinalSpeedF = uclamp(pFinalSpeedF or 0, 0, 1200) -- speed reaching the wp\n    if rdata.v[pName] ~= nil then\n        return E(\"[E] Route \"..pName..\"already exists, aborting!\")\n    end\n    if not type(pSuf) == \"string\" or pSuf == \"\" then pSuf = \"F\" end\n    if strlen(pSuf) > 3 then\n        return E(\"[E] -suffix accepts max. 3 characters\"..example)\n    end\n    if pAlt < -100 or pAlt > 20000 then\n        return E(\"[E] -altitude value out of range (-100 .. 20000)\"..example)\n    end\n\n    -- need a sorted list of names, can't use wpdata as that is being modified *live*\n    -- names could be filtered by pStart\n    local wplist = {}\n    for k in PairsByKeys(wpdata.v) do\n        if not pStart or k:find(pStart) > 0 then\n            table.insert(wplist, k)\n        end\n    end\n\n    -- lets add new \"flight\" waypoints and get updated tables back\n    local wpdata, wplistNew = yfsAddAltitudeWaypoints(wpdata, wplist, pAlt, pSuf)\n    if wpdata == nil or wplistNew == nil then\n        return E(\"[I] No waypoints processed: no changes made.\")\n    end\n\n    -- add new route\n    rdata.v[pName] = { points = {} }\n\n    -- assume that wplistNew now contains all required wp names in order\n    -- so these can be added to the route\n    local cnt = 0\n    for _,k in ipairs(wplistNew) do\n        local wp = wpdata.v[k]\n        if wp ~= nil then\n            -- add wp to route\n            cnt = cnt + 1\n            local rOpt = { margin = 0.1, maxSpeed = 0 }\n            local rp = { opt = rOpt, pos = wp.pos, waypointRef = k }\n            -- for \"flight\" waypoints:\n            if GetIndex(wplist, k) < 1 then\n                -- set final approaching speed for landing waypoints if specified\n                if pFinalSpeedF and pFinalSpeedF > 0 and GetIndex(wplist, k) < 1 then\n                    rp.opt.finalSpeed = pFinalSpeedF\n                end\n                -- set max speed for flight waypoints if specified\n                if pMaxSpeed and pMaxSpeed > 0 then\n                    rp.opt.maxSpeed = pMaxSpeed\n                end\n                -- set margin for flight waypoints if specified\n                if pMarginF and pMarginF > 0.1 then\n                    rp.opt.margin = pMarginF\n                end\n                rp.opt.selectable = false\n                rp.opt.skippable = false\n            else -- for Landed waypoints:\n                -- set margin for landed waypoints if specified\n                if pMarginL and pMarginL > 0.1 then\n                    rp.opt.margin = pMarginL\n                end\n                rp.opt.selectable = true\n                rp.opt.skippable = true\n            end\n            table.insert(rdata.v[pName].points, rp)\n        end\n    end\n    P(\"[I] \"..cnt..\" positions added to route '\"..pName..\"'\")\n    storeYFSNamedWaypoints(wpdata)\n    storeYFSRoutes(rdata)\nend\n\nfunction cmd.YfsSaveRouteCmd(text)\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n\n    local parts = SU.SplitQuoted(text)\n    if #parts < 1 then\n        return E(\"[E] Parameter(s) missing: routename\\nExample: /yfs-save-route 'Cryo' -onlySelectable -withOptions -prefix 'Cryo'\")\n    end\n    local wpPrefix = GetParamValue(parts, \"-prefix\", \"s\")\n    if not wpPrefix then wpPrefix = \"WP\" end\n    local onlySelectable = GetIndex(parts, \"-onlySelectable\") > 0\n    local withOptions = GetIndex(parts, \"-withOptions\") > 0\n    local routename = parts[1]\n    local route = routes.v[routename]\n    if not route or not IsTable(route.points) or #route.points == 0 then\n        return E(\"[E] Route '\"..routename..\"' not found or empty\")\n    end\n    local output1, output2 = \"create-route '\"..routename..\"'\\r\\n\", \"\"\n\n    local wpdata = cmd.GetYFSNamedWaypoints()\n\n    -- iterate points, build one commands output for wp creation and one for\n    -- adding each with options (optionally) to the route\n    local wpIdx = 1\n    local wpNames = {} -- to avoid duplicates\n    for _,v in ipairs(route.points) do\n        local wppos = \"\"\n        local wpName = wpPrefix..\" \"..sformat(\"%03d\", wpIdx)\n        if v.waypointRef and wpdata then\n            wpName = v.waypointRef\n            wppos = wpdata.v[wpName].pos\n        else\n            wppos = v.pos or \"<unknown>\"\n        end\n\n        if GetIndex(wpNames, wpName) < 0 then\n            wpNames[#wpNames + 1] = wpName\n            local tmp = \"pos-save-as '\"..wpName..\"' -pos \"..wppos\n            output1 = output1 .. tmp .. \"\\n\"\n        end\n        if (not onlySelectable) or (v.opt[\"selectable\"] ~= false) then\n            local tmp = \"route-add-named-pos '\"..wpName..\"'\"\n            if withOptions then\n                -- named-waypoint level options\n                -- Note: \"lockdir\" option is presently not transferrable!\n                if v.opt[\"maxSpeed\"] and v.opt[\"maxSpeed\"] ~= 0 then\n                    tmp = tmp..\" -maxspeed \"..v.opt[\"maxSpeed\"]\n                end\n                if v.opt[\"margin\"] and v.opt[\"margin\"] ~= 0.1 then\n                    tmp = tmp..\" -margin \"..v.opt[\"margin\"]\n                end\n                -- route-level options require a 2nd command\n                local routeLvlOptions = false\n                local routeOptStr = \"\"\n                if v.opt[\"skippable\"] == true then\n                    routeLvlOptions = true\n                    routeOptStr = routeOptStr .. \" -toggleSkippable\"\n                end\n                if v.opt[\"selectable\"] == false then\n                    routeLvlOptions = true\n                    routeOptStr = routeOptStr .. \" -toggleSelectable\"\n                end\n                if v.opt[\"finalSpeed\"] and v.opt[\"finalSpeed\"] ~= 0 then\n                    routeLvlOptions = true\n                    routeOptStr = routeOptStr..\" -finalSpeed \"..v.opt[\"finalSpeed\"]\n                end\n                if routeLvlOptions then\n                    tmp = tmp .. \"\\nroute-set-pos-option -ix \"..wpIdx..routeOptStr\n                end\n            end\n            output2 = output2 .. tmp .. \"\\n\"\n            wpIdx = wpIdx + 1\n        end\n    end\n    output2 = output2..\"route-save\\r\\n\"\n    P(output1..output2)\n    ScreenOutput(output1..output2)\nend\n\n---@comment Replaces a given YFS waypoint (by -name) with current pos (default) or -pos ::pos{...}\nfunction cmd.YfsReplaceWpCmd(text)\n    local wpnames = cmd.GetYFSNamedWaypoints()\n    if not wpnames then return end\n\n    local ex = \"\\r\\nExample: /yfs-replace-wp 'base 1'\"\n    local params = SU.SplitQuoted(text)\n    if #params < 1 then\n        return E(\"[E] Parameter(s) missing: -name 'point'\"..ex)\n    end\n\n    local wpName = GetParamValue(params, \"-name\", \"s\", true)\n    if not wpName then return end\n    if not wpnames.v[wpName] or wpnames.v[wpName] == \"\" then\n        return E(\"[E] Waypoint '\".. wpName ..\"' not found.\"..ex)\n    end\n\n    local newPos = PM.GetCurrentPosString()\n    local pPos = GetParamValue(params, \"-pos\", \"s\")\n    if pPos then\n        ---@diagnostic disable-next-line: cast-local-type\n        local tmp = PM.SplitPos(pPos)\n        if not tmp then\n            return E(\"[E] Invalid ::pos{} specified!\")\n        end\n        newPos = pPos\n    end\n\n    wpnames.v[wpName].pos = newPos\n    P(\"[I] Waypoint '\"..wpName..\"' changed to:\")\n    P(newPos)\n\n    storeYFSNamedWaypoints(wpnames)\n    return true\nend\n\nfunction cmd.YfsRouteAltitudeCmd(text)\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n\n    local namedWP = cmd.GetYFSNamedWaypoints()\n    if not namedWP then return end\n\n    -- 1 check parameters\n    local example = \"\\nExample:\\n/yfs-route-altitude -route 'name' -ix 2 -endIx 3 -alt 330\\nThe -endIx is optional.\"\n    local parts  = SU.SplitQuoted(text)\n    local pName  = GetParamValue(parts, \"-route\", \"s\", true)\n    if not pName then return end\n    if not routes.v[pName] then\n        return E(\"[E] Route '\"..pName..\"' not found.\"..example)\n    end\n    if not routes.v[pName].points or #routes.v[pName].points == 0 then\n        return E(\"[E] Route '\"..pName..\"' empty.\")\n    end\n\n    local pStart = GetParamValue(parts, \"-ix\", \"i\", true)\n    local pEnd   = GetParamValue(parts, \"-endIx\", \"i\")\n    local pAlt   = GetParamValue(parts, \"-alt\", \"n\", true)\n    local isError = not pName or not pStart or not pAlt or (pStart < 1) or (pEnd and pEnd < pStart) or (pAlt < -100) or (pAlt > 10000)\n    if isError then\n        return E(\"[E] Wrong number of parameters / invalid values!\"..example)\n    end\n    if not pEnd or pEnd < pStart then pEnd = pStart end\n\n    -- 2 process route waypoints and collect named waypoint names\n    -- /yfs-route-altitude -route 'Cryo' -ix 2 -endIx 3 -alt 330.1243\n    P(\"[I] Processing route '\"..pName..\"'\")\n    local changed = 0\n    local wpnames = {}\n    for i,v in ipairs(routes.v[pName].points) do\n        if i >= pStart and i <= pEnd then\n            local wpName = v.waypointRef\n            local wp = namedWP.v[wpName]\n            if wp ~= nil then\n                if GetIndex(wpnames, wpName) < 1 then\n                    table.insert(wpnames, wpName)\n                end\n                local newPos = PM.ReplaceAltitudeInPos(wp.pos, pAlt)\n                routes.v[pName].points[i].pos = newPos\n                P(\"[I] Route Waypoint '\"..wpName..\"' changed to:\\n\"..newPos)\n            end\n        end\n    end\n    if #wpnames == 0 then\n        return E(\"[I] No waypoints in route changed.\\n[*] Make sure that start (and end-index) are valid.\")\n    end\n    -- 3 store routes back to db\n    storeYFSRoutes(routes)\n    P(\"[I] Routes saved.\")\n\n    -- 4 process named waypoints list\n    changed = 0\n    for _,entry in ipairs(wpnames) do\n        if namedWP.v[entry] then\n            changed = changed + 1\n            local newPos = PM.ReplaceAltitudeInPos(namedWP.v[entry].pos, altitude)\n            namedWP.v[entry].pos = newPos\n            P(\"[I] Named Waypoint '\"..entry..\"' changed to:\")\n            P(newPos)\n        else\n            P(\"[E] '\"..entry..\"' not found!\")\n        end\n    end\n    -- 5 write back to DB\n    if changed > 0 then\n        storeYFSNamedWaypoints(namedWP)\n        P(\"[I] Named waypoints saved.\")\n    end\nend\n\nfunction cmd.YfsWpAltitudeCmd(text)\n    -- 1 read named waypoints from DB\n    local wpnames = cmd.GetYFSNamedWaypoints()\n    if not wpnames then return E(\"[E] No named waypoints.\") end\n\n    -- 2 parse params to find a) name and b) new altitude value\n    local parts = SU.SplitQuoted(text)\n    if #parts ~= 2 then\n        return E(\"[E] Wrong number of parameters!\\nExample: /yfs-wp-altitude 'Base 1' 324.12\")\n    end\n    local pName = parts[1] or \"\"\n\n    -- 3 find named waypoint\n    if not pName or not parts[2] or not wpnames.v[pName] or wpnames.v[pName] == \"\" then\n         return E(\"[E] Waypoint '\".. pName ..\"' not found\")\n    end\n\n    -- 4 alter waypoint's altitude\n    local pAlt = tonum(parts[2] or 0)\n    local newPos = PM.ReplaceAltitudeInPos(wpnames.v[pName].pos, pAlt)\n    wpnames.v[pName].pos = newPos\n    P(\"[I] Waypoint '\"..pName..\"' changed to:\")\n    P(newPos)\n    P(\"[I] Note: routes' waypoints are updated on route activation, i.e. exporting route data before activation may still show old value!\")\n\n    -- 4 write back to DB\n    storeYFSNamedWaypoints(wpnames)\n    return true\nend\n\nfunction cmd.YfsRouteNearestCmd(text)\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n    -- 1 process params\n    local params = SU.SplitQuoted(text)\n    if #params == 0 or #params > 2 then\n        P(\"[E] Wrong parameter count\\n[I] Example: /yfs-route-nearest 'Route 1'\")\n        P(\"\\nOptional parameter:\\n\")\n        P(\"-onlySelectable -> only show closest, selectable waypoints in route\")\n        return false\n    end\n    -- 2 find the route\n    local routeName = params[1]\n    local route = routes.v[routeName]\n    if not route or not IsTable(route.points) then\n        return E(\"[E] Route '\" .. routeName ..\"' not found or empty\")\n    end\n    P(\"[I] Route '\"..routeName..\"' found.\")\n    -- 3 check optional parameters\n    local onlySelectable = GetIndex(params, \"-onlySelectable\") > 0\n\n    -- 4 process route waypoints\n    local wplist = cmd.GetYFSNamedWaypoints(true)\n    local idx = 0\n    local closestDist = 999999999\n    local sDist, sNearest = \"\", \"\"\n    local res =  {}\n    for k,v in ipairs(route.points) do\n        idx = idx + 1\n        if (not onlySelectable) or (v.opt and v.opt.selectable ~= false) then\n            local wpname = SU.Trim(sformat(\"%02d\", idx) .. \": '\"..(v.waypointRef or \"\")..\"'\")\n            local pos = v.pos\n            if v.waypointRef and wplist then\n                pos = wplist.v[v.waypointRef].pos\n            end\n            local dist = PM.GetDistance(pos)\n            if dist > 0.1 then\n                route.points[k].distance = dist\n                sDist = wpname .. \" = \" .. sformat(\"%.4f\", dist)\n                if dist < closestDist then\n                    sNearest = sDist\n                    closestDist = dist\n                end\n                local tmpDist = tostring(math.modf(dist * 10000))\n                local key = ('0'):rep(12-#tmpDist)..tmpDist\n                res[key] = idx\n            end\n        end\n    end\n    if not idx then return E(\"[I] No selectable waypoints found.\") end\n    local output = \"Route-Idx / Name / Distance (m)\\n\"\n    for _,key in pairs(GetSortedAssocKeys(res)) do\n        local routeIdx = res[key]\n        local wpName = route.points[routeIdx].waypointRef\n        local wpDist = route.points[routeIdx].distance\n        output = output .. sformat(\"%02d\", routeIdx)..\" / '\"..wpName..\"' / \"\n        output = output .. Out.PrettyDistance(wpDist)..\"\\n\"\n    end\n    output = output .. \"\\n[I] Nearest waypoint: \"..sNearest\n\n    Out.PrintLines(output)\n    ScreenOutput(output)\nend\n\nfunction cmd.YfsRouteToNamedCmd(text)\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n    -- 1 process params\n    local params = SU.SplitQuoted(text)\n    if #params == 0 or #params > 6 then\n        P(\"[E] Wrong parameter count\\n[I] Example: /yfs-route-to-named 'Route 1'\\nOptional parameters:\\n\")\n        P(\"-onlySelectable -> only write waypoints marked as selectable in route\")\n        P(\"-prefix Myprefix -> if unspecified, 'WP' is default\")\n        P(\"-toScreen -> output JSON of list to optional screen if linked\")\n        P(\"-toDB -> only if this is given, the changed list will be written to DB to avoid miscalls\")\n        P(\"Important: command aborts if ANY waypoint's name starts with given prefix to avoid errors!\")\n        return false\n    end\n    -- 2 find the route\n    local routeName = params[1]\n    local route = routes.v[routeName]\n    if not route or not IsTable(route.points) then\n        return E(\"[E] Route '\" .. routeName ..\"' not found or empty\")\n    end\n    P(\"[I] Route '\"..routeName..\"' found.\")\n    -- 3 check optional parameters\n    local toDB = GetIndex(params, \"-toDB\") > 0\n    local toScreen = GetIndex(params, \"-toScreen\") > 0\n    local onlySelectable = GetIndex(params, \"-onlySelectable\") > 0\n    local wpPrefix = GetParamValue(params, \"-prefix\", \"s\")\n    if not wpPrefix then wpPrefix = \"WP\" end\n    -- local margin = nil\n    -- local pMargin = GetParamValue(params, \"-margin\", \"number\")\n    -- if pMargin and pMargin ~= 0.1 then margin = pMargin end\n\n    -- 4 process route waypoints\n    local wplist = cmd.GetYFSNamedWaypoints(true)\n    if not wplist or not wplist.v then\n        wplist = { v = { } }\n    else\n        -- if any WP with same prefix already exists, abort!\n        for k,_ in pairs(wplist.v) do\n            if string.find(k, wpPrefix) == 1 then\n                return E(\"[!] Waypoints with same prefix already exist!\\n[!] Command aborted.\")\n            end\n        end\n    end\n    local idx = 0\n    for _,v in ipairs(route.points) do\n        if (not onlySelectable) or (v.opt and v.opt.selectable ~= false) then\n            idx = idx + 1\n            local wpname = wpPrefix .. \" \" .. sformat(\"%02d\", idx)\n            local wp = { pos = v.pos, opt = v.opt}\n            --if margin then wp.opt.margin = margin end\n            wplist.v[wpname] = wp\n            P(wpname ..\"  \" .. v.pos)\n        end\n    end\n    if not idx then return E(\"[I] No changes to waypoints done\") end\n\n    -- 5 write waypoints back to DB, if at least 1 point was added\n    if toDB then\n        storeYFSNamedWaypoints(wplist)\n        P(\"[I] Waypoint changes saved to databank!\")\n    else\n        P(\"[I] -toDB not present, no changes saved to databank!\")\n    end\n    if toScreen then\n        ScreenOutput(json.encode(wplist.v))\n    end\nend\n\nfunction cmd.YFSLoadNamedWaypoints()\n    local wpnames = cmd.GetYFSNamedWaypoints()\n    if not wpnames then return end\n    for k,v in pairs(wpnames.v) do\n        PM.CreateWaypoint(v.pos, k)\n    end\nend\n\nfunction cmd.YFSLoadRoutepoints(onlySelectableWP, onlyWpForRoute)\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return false end\n    P('[I] Processing routes...')\n    for k,v in pairs(routes.v) do\n        if (onlyWpForRoute == \"\" or onlyWpForRoute == k) and IsTable(v) then\n            for k2,v2 in ipairs(v.points) do\n                if (not onlySelectableWP) or (v2.opt[\"selectable\"] ~= false) then\n                    local wpName = k .. \" \" .. k2\n                    if v2.waypointRef then\n                        wpName = v2.waypointRef\n                    end\n                    PM.CreateWaypoint(v2[\"pos\"], wpName)\n                end\n            end\n            P(\"[I] Route '\"..k..\"' read.\")\n        end\n    end\n    return true\nend\n\nfunction cmd.YfsSaveNamedCmd(text)\n    cmd.WpSaveNamedCmd(text, true)\nend\n\nfunction cmd.PosDataCmd()\n    --P(\"GetCameraCmd() called\")\n    P(\"getCameraHorizontalFov: \"..system.getCameraHorizontalFov())\n    P(\"getCameraVerticalFov: \"..system.getCameraVerticalFov())\n\n    P(\"getCameraPos: \"..PM.Vec3String(system.getCameraPos()))\n    P(\"getCameraForward: \"..PM.Vec3String(system.getCameraForward()))\n    P(\"getCameraRight: \"..PM.Vec3String(system.getCameraRight()))\n    P(\"getCameraUp: \"..PM.Vec3String(system.getCameraUp()))\n\n    P(\"getCameraWorldPos: \"..PM.Vec3String(system.getCameraWorldPos()))\n    P(\"getCameraWorldForward: \"..PM.Vec3String(system.getCameraWorldForward()))\n    P(\"getCameraWorldRight: \"..PM.Vec3String(system.getCameraWorldRight()))\n    P(\"getCameraWorldUp: \"..PM.Vec3String(system.getCameraWorldUp()))\n\n    P(\"construct.getWorldPosition: \"..PM.Vec3String(construct.getWorldPosition(CNID)))\n    P(\"construct.getOrientationForward: \"..PM.Vec3String(construct.getOrientationForward()))\n    P(\"construct.getOrientationRight: \"..PM.Vec3String(construct.getOrientationRight()))\n    P(\"construct.getOrientationUp: \"..PM.Vec3String(construct.getOrientationUp()))\nend\n\nfunction cmd.DumpPointsCmd()\n    if true then\n        P(\"~=~=~=~=~=~=~= DUMP START ~=~=~=~=~=~=\")\n        local tmp = Out.DumpVar(WM:getWaypointsInst())\n        P(tmp)\n        return ScreenOutput((tmp or \"[I] No waypoints.\"),\"\\n~=~=~=~=~=~=~= DUMP END ~=~=~=~=~=~=~=\")\n    end\n\nend\n\nfunction cmd.DumpRoutesCmd()\n    if not DetectedYFS then return E(\"[I] No YFS databank.\") end\n    P(\"~=~=~=~=~=~=~= ROUTES DUMP START ~=~=~=~=~=~=\")\n    local tmp = YFSDB:getString(YFS_ROUTES)\n    P(tmp)\n    ScreenOutput((tmp or \"[I] No routes.\"),\"\\n~=~=~=~=~=~=~= ROUTES DUMP END ~=~=~=~=~=~=~=\")\nend\n\nfunction cmd.RoutesCmd()\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n    P(\"[I] Available routes:\")\n    for k,_ in pairs(routes.v) do\n        P(k)\n    end\nend\n\n-- *** Dev/Testing functions ***\n\nfunction cmd.YfsTestDataCmd(param)\n    if not (param == \"TESTING\") then return end\n    P(\"[*] Creating YFS test data...\")\n\n    YFSDB:remove(YFS_NAMED_POINTS)\n    local data = { }\n    data[\"Chr 01\"] = { pos = \"::pos{0,7,-20.7784,-153.7402,360.5184}\", opt = {} }\n    data[\"Chr 02\"] = { pos = \"::pos{0,7,-21.3610,-152.3447,345.8787}\", opt = {} }\n    data[\"Chr 03\"] = { pos = \"::pos{0,7,-23.0540,-152.8934,360.6677}\", opt = {} }\n    data[\"Chr 04\"] = { pos = \"::pos{0,7,-22.4445,-154.3119,320.1029}\", opt = {} }\n    data[\"Chr 05\"] = { pos = \"::pos{0,7,-20.5370,-154.7507,308.0151}\", opt = {} }\n    data[\"Chr 06\"] = { pos = \"::pos{0,7,-21.6295,-155.1465,292.7660}\", opt = {} }\n    data[\"Chr Hub\"] = { pos = \"::pos{0,7,-21.9903,-153.1008,391.4632}\", opt = {} }\n    local tmp = { v = data, t = type(data) }\n    storeYFSNamedWaypoints(tmp)\n\n    YFSDB:remove(YFS_ROUTES)\n    local r = { }\n    -- r[\"Test\"] = { points = { } }\n    -- r[\"Test\"].points[1] = { pos = \"::pos{0,7,-20.8094,-153.7308,366.1022}\", waypointRef = \"Chr 01\" }\n    storeYFSRoutes({ v = r, t = type(r) })\n\n    P(\"[*] YFS test data saved!\")\n    cmd.DumpPointsCmd()\n    cmd.DumpRoutesCmd()\nend\n\nfunction cmd.ConversionTestCmd(param)\n    PM.ConversionTest()\nend\n\nfunction cmd.XCmd()\n    -- local s = \"-name C -altitude 440 -marginL 0.5 -marginF 1 -finalSpeedF 10 -suffix 'F'\"\n    -- P(\"X params: \"..params)\n    -- cmd.YfsBuildRouteFromWpCmd(s)\nend\n\nreturn cmd\nend)\npackage.preload['YFS-Tools:help.lua']=(function()\nlocal help = {}\n\nfunction help.PrintHelpCmd()\n    local hlp = \"~~~~~~~~~~~~~~~~~~~~\\nYFS-Tools Commands:\\n~~~~~~~~~~~~~~~~~~~~\\n\"..\n    \"/arch-save-named\\n-> Builds list of chat commands for ArchHud to add locations for all named waypoints.\\n\"..\n    \"/planetInfo (id or name)\\n-> Info about current planet or for passed planet id or name, e.g. 2 for Alioth).\\n\"..\n    \"/printAltitude /printPos /printWorldPos\\n-> Prints info data.\\n\"..\n    \"/warpCost -from name/::pos{}/planets -to name/::pos{}/planets -mass tons -moons\\n-> Flexible warp cell calculator.\\n\"..\n    \"/wp-altitude-ceiling\\n-> Changes a waypoint to have the higher altitude of both.\\n\"..\n    \"/wp-export\\n-> Outputs list of plain waypoints to chat and an optional screen. Source can include ArchHud locations, too, if databank linked.\\n\"..\n    \"/yfs-add-altitude-wp\\n-> Adds waypoints for each existing WP at a specified altitude and name suffix.\\n\"..\n    \"/yfs-build-route-from-wp\\n-> Powerful route-building command based on existing named waypoints.\\n\"..\n    \"/yfs-route-altitude\\n-> Changes altitude for a range of waypoints of a specific YFS route.\\n\"..\n    \"/yfs-route-nearest\\n-> Show list of route waypoints by distance from current location.\\n\"..\n    \"/yfs-route-to-named\\n-> Converts a route's *unnamed* waypoints to named waypoints for YFS.\\n\"..\n    \"/yfs-save-named\\n-> Builds list of YFS commands to recreate all named waypoints.\\n\"..\n    \"/yfs-save-route\\n-> Builds list of YFS commands to recreate full route incl. named waypoints and their options.\\n\"..\n    \"/yfs-wp-altitude\\n-> Changes altitude of a named waypoint to specified altitude.\\n\"..\n    \"----------------------------------\\n\"..\n    \"Important: Enclose names (as parameters) in single quotes if they contain blanks!\\n\"..\n    \"*** DO NOT USE COMMANDS THAT CHANGE POINTS ***\\n*** OR ROUTES WHILE YFS IS RUNNING! ***\\n\"\n    ScreenOutput(hlp)\n    P(hlp)\nend\n\nreturn help\nend)\npackage.preload['YFS-Tools:warpcost.lua']=(function()\n-- requires SU, PM\nlocal strmatch, sformat, strlen = string.match, string.format, string.len\nlocal tonum, uclamp, mabs, max, floor, ceil = tonumber, utils.clamp, math.abs, math.max, math.floor, math.ceil\n\n\n---@comment Calculates # of warp cells for distance and mass\n---@param text string List of space-separated params\nfunction CalcWarpCost(text)\n    local example = \"\\nExample 1:\\n/warpCost -from Madis -to Alioth -mass 534\"..\n        \"\\nExample 2:\\n/warpCost -from Alioth -to planets -moons\"..\n        \"\\nOptional '-from x' with x being either 'here', a planet name, ::pos{} or 'planets' (multi-result).\"..\n        \"\\nOptional '-to x' like -from, but for end location.\"..\n        \"\\nOptional '-mass x' with x the total mass in tons. If not given, the current constructs' total mass is used.\"..\n        \"\\nOptional '-cargo x' with x the cargo mass in tons. If specified, a cell count for a return trip is calculated, too.\"..\n        \"\\nOptional '-moons' only together with 'planets' to also include moons in the list.\"..\n        \"\\n- One of -from or -to can be left out, then the current construct's location (or planet) is used.\"..\n        \"\\n- If construct is landed on a planet or moon, the Atlas specified warp altitude is the starting point.\"..\n        \"\\n- Enclose names in single-quotes if they contain spaces!\"\n    local getCMass = construct.getMass\n    local pOn, onPlanet = {}, false\n    local s, s2 = \"~~~ WARP CELL CALCULATOR ~~~\", \"\"\n\n    local function checkParam(args, pName, isFrom)\n        local v, allPlanets, offs = {}, false, 0\n        local par = GetParamValue(args, pName, \"s\")\n        if not par or (par == \"\") or (par == \"here\") then\n            v = PM.WorldPosVec3() -- current position\n            if onPlanet and pOn then\n                offs = 2 * pOn.radius\n                par = pOn.name[1]\n                v = vec3(pOn.center)\n            else\n                offs = 12 -- min. 12 km warp distance\n                par = PM.Vec3ToPosString(v)\n            end\n        elseif par == \"planets\" then\n            allPlanets = true\n        elseif par > \"\" then\n            if SU.StartsWith(par, \"::pos{\") then\n                offs = 12 -- min. 12 km warp distance\n                v = PM.MapPosToWorldVec3(par)\n            else\n                local p = PM.PlanetByName(par)\n                if p then\n                    offs = 2 * p.radius\n                    v = vec3(p.center)\n                end\n            end\n        end\n        return { parm = par, v = v, isP = allPlanets, offset = offs }\n    end\n\n    local args = SU.SplitQuoted(text)\n    if #args < 1 then return E(\"[E] Parameter(s) missing!\"..example) end\n    local pMoons = GetIndex(args, \"-moons\") > 0\n\n    -- for current location, check if we are \"on\" a planet (within atmo-radius),\n    -- and set an offset of 2*radius from center as \"warp barrier\"\n    local offset = 0\n    pOn = PM.GetClosestPlanet(PM.WorldPosVec3())\n    if pOn then\n        offset = 2 * pOn.radius -- warp exclusion distance from center\n        onPlanet = PM.Altitude() < offset\n        if onPlanet then\n            s2 = \"Current\"\n        else\n            s2 = \"Nearest\"\n        end\n        s = s..\"\\n\"..s2..\" planet: \"..pOn.name[1]\n    else\n        s = s..\"\\n[I] No planet nearby!\"\n    end\n\n    ---@diagnostic disable-next-line: missing-parameter\n    local maxMass = 50000\n    ---@diagnostic disable-next-line: missing-parameter\n    local tons = getCMass(CNID) / 1000 -- CNID in globals.lua!\n\n    -- check -cargo param and value\n    local pCargo, bCargo = 0, false\n    if GetIndex(args, \"-cargo\") > 0 then\n        local tmpCargo = GetParamValue(args, \"-cargo\", \"n\")\n        tmpCargo = tmpCargo or 0\n        if tmpCargo > 0 then\n            pCargo = uclamp(tmpCargo, 0, maxMass)\n            bCargo = pCargo > 0\n        else\n            return E(s..\"\\n[E] Invalid -cargo value, must be in range of 1-50000 tons!\")\n        end\n    end\n\n    local pMass = GetParamValue(args, \"-mass\", \"n\")\n    s2 = \"Mass: \"\n    if pMass then\n        tons = tonum(pMass)\n    else\n        s2 = \"Construct \"..s2\n    end\n    s = s..\"\\n\"..s2..Out.PrettyMass(tons*1000)\n    if bCargo then\n        s = s..\"  ~*~  Cargo: \"..Out.PrettyMass(pCargo*1000)\n    end\n    if tons < 100 then -- warp drive alone is 75 tons!\n        return E(s..\"\\n[E] Impossibly low mass for a warp ship! ;)\")\n    elseif tons > maxMass then\n        return E(s..\"\\n[E] I don't accept you're warping that heavy! ;)\")\n    end\n\n    local locFrom = checkParam(args, \"-from\", true)\n    if not locFrom.isP and not locFrom.v then\n        return E(s..\"\\n[E] Invalid starting location!\")\n    end\n    local locTo = checkParam(args, \"-to\", false)\n    if not locTo.isP and not locTo.v then\n        return E(s..\"\\n[E] Invalid end location!\")\n    end\n\n    if locFrom.isP and locTo.isP then\n        return E(s..\"\\n[E] Only one 'planets' option supported!\")\n    end\n    if (locFrom.parm == locTo.parm) or (locFrom.v == locTo.v) then\n        return E(s..\"\\n[E] Start and end locations must be different!\")\n    end\n\n    local function process(from, to, distance, massT, cargo)\n        local out = \"\"\n        if from > \"\" then out = out .. from end\n        if from > \"\" and to > \"\" then out = out .. \" to \" end\n        if to > \"\" then out = out .. to end\n        out = out.. \" (\"..Out.PrettyDistance(distance)..\")\"\n\n        -- min 1 SU, max 500 SU (1 SU = 200000 m)\n        if distance < 200000 then\n            return out..\" -> too short!\"\n        elseif distance > 100000000 then\n            return out..\" -> too far!\"\n        end\n        local cnt = PM.ComputeCells(distance, massT)\n        out = out..\" = \"..cnt..\" cell\" .. SU.If(cnt > 1, \"s\")\n        if bCargo then\n            local cnt2 = PM.ComputeCells(distance, massT - cargo)\n            out = out..\" / \"..cnt2..\" cell\" .. SU.If(cnt > 1, \"s\")..\" = \"..(cnt+cnt2)..\" total\"\n        end\n        return out\n    end\n\n    -- Single source and destination\n    if not locFrom.isP and not locTo.isP then\n        local distance = mabs(vec3(locFrom.v - locTo.v):len()) - locFrom.offset - locTo.offset\n        local res = process(locFrom.parm, locTo.parm, distance, tons, pCargo)\n        if type(res) == \"string\" then\n            s = s .. \"\\n\" .. res\n            P(s)\n            ScreenOutput(s)\n        else\n            E(\"[E] Sorry, something went wrong :(\")\n        end\n        return\n    end\n\n    -- Planets processing\n    local v1, v2 = nil, nil\n    s2 = \" (Distance) / Cells\"..SU.If(bCargo, \" / Return w/o cargo\")\n    if locFrom.isP then\n        s = s..\"\\nTo: \"..locTo.parm..\"\\nFrom\"..s2\n    else\n        s = s..\"\\nFrom: \"..locFrom.parm..\"\\nTo\"..s2\n    end\n    for _,v in pairs(WaypointInfo[0]) do\n        if not v.isAsteroid and (pMoons or not v.isMoon) then\n            offset = 2 * v.radius\n            if locFrom.isP then\n                locFrom.parm = v.name[1]\n                locFrom.v = v.centerV3\n                offset = offset + locTo.offset\n            else\n                locTo.parm = v.name[1]\n                locTo.v = v.centerV3\n                offset = offset + locFrom.offset\n            end\n            local distance = mabs(vec3(locFrom.v - locTo.v):len()) - offset\n            if distance > 100000 then\n                s = s .. \"\\n\" ..\n                    process(SU.If(locFrom.isP, locFrom.parm),\n                            SU.If(locTo.isP, locTo.parm),\n                            distance, tons, pCargo)\n            end\n        end\n    end\n    P(s)\n    ScreenOutput(s)\nend\n\nend)\npackage.preload['YFS-Tools:../util/wpoint.lua']=(function()\nlocal tonum, strlen, strmatch = tonumber, string.len, string.match\n\n---@comment Simple Waypoint class to store a name with a location.\n--- No location conversions or changes are done in this class!\n--- The set method is flexible, though, in what it accepts as source for a location.\n--- @class Waypoint\nWaypoint = { mapPos = {}, name = \"\", parent = nil }\n\n-- Waypoint methods\nWaypoint.new = function(parent)\n    local obj = setmetatable(\n        { parent = parent, name = \"\",\n          mapPos = { systemId = 0, id = 0, latitude = 0.0, longitude = 0.0, altitude = 0.0 } },\n        { __index = Waypoint }\n    )\n    return obj\nend\n\n---@comment Returns the waypoint as { systemId, id, latitude, longitude, altitude }\n---@return table\nWaypoint.get = function(self)\n    return self.mapPos\nend\n\nWaypoint.getPosPattern = function()\n    local num = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\n    return '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' .. num ..  ',' .. num .. '}'\nend\n\n---@comment Sets a waypoint to the given map position (::pos{}, vec3 or table with 3 or 5 pos data)\nWaypoint.set = function(self, newMapPos)\n    if type(newMapPos) == \"string\" and strlen(newMapPos) < 16 then\n        print(\"[E] Invalid position: \"..newMapPos)\n        return {}\n    end\n\n    if type(newMapPos) == \"string\" then\n        local s, p, x, y, z = strmatch(newMapPos, self.getPosPattern())\n        if s then\n            self.mapPos.systemId = tonum(s)\n            self.mapPos.id = tonum(p)\n            self.mapPos.latitude = tonum(x)\n            self.mapPos.longitude = tonum(y)\n            self.mapPos.altitude = tonum(z)\n        else\n            print(newMapPos..\" - Invalid string format. Use '::pos{s, p, x, y, z}'.\")\n        end\n    elseif type(newMapPos) == \"table\" and #newMapPos == 3 then\n        self.mapPos.latitude = tonum(newMapPos[1])\n        self.mapPos.longitude = tonum(newMapPos[2])\n        self.mapPos.altitude = tonum(newMapPos[3])\n    elseif type(newMapPos) == \"table\" and #newMapPos == 5 then\n        self.mapPos.systemId = tonum(newMapPos[1])\n        self.mapPos.id = tonum(newMapPos[2])\n        self.mapPos.latitude = tonum(newMapPos[3])\n        self.mapPos.longitude = tonum(newMapPos[4])\n        self.mapPos.altitude = tonum(newMapPos[5])\n    elseif type(newMapPos) == \"table\" and newMapPos.x and newMapPos.y and newMapPos.z then\n        self.mapPos.systemId = 0\n        self.mapPos.id = 0\n        self.mapPos.latitude = tonum(newMapPos.x)\n        self.mapPos.longitude = tonum(newMapPos.y)\n        self.mapPos.altitude = tonum(newMapPos.z)\n    else\n        print(\"Invalid input. Provide a ::pos{} string, vec3() or {s,p,x,y,z} table.\")\n    end\n    return self\nend\n\n---@comment Set the name for the waypoint. Can be empty.\n---@param self table\nWaypoint.setName = function(self, newName)\n    if newName == nil then self.name = \"\" return end\n    if type(newName) == \"string\" and newName:gmatch(\"^%a[%w_- ]*$\") then\n        self.name = newName\n    else\n        print(tostring(newName)..\"\\n[E] WP: Invalid name format. Should only contain printable characters.\")\n    end\n    return self\nend\n\n---@comment Returns the name for the waypoint. Can be empty.\nWaypoint.getName = function(self)\n    return self.name\nend\n\n---@comment Returns just the altitude value (number).\nWaypoint.getAltitude = function(self)\n    return self.mapPos.altitude\nend\n\n---@comments Returns ::pos{} string of the waypoint\n---@return string\nWaypoint.AsString = function(self)\n    return string.format(\"::pos{%d, %d, %.4f, %.4f, %.4f}\",\n                         self.mapPos.systemId, self.mapPos.id,\n                         self.mapPos.latitude, self.mapPos.longitude, self.mapPos.altitude)\nend\n\nWaypoint.__Waypoint = function(self) return true end\nend)\npackage.preload['YFS-Tools:../util/wpointmgr.lua']=(function()\nlocal tonum, strlen, strmatch = tonumber, string.len, string.match\n\n\n---@class WaypointMgr\nWaypointMgr = { name = \"\", waypoints = {} }\n\n--- comment Add a waypoint object to the list at position 'index'\n--- @param self table\n--- @param waypoint any\n--- @param index any\n--- @return nil\nWaypointMgr.add = function(self, waypoint, index)\n    if waypoint.__Waypoint and waypoint.__Waypoint() then\n        -- If the waypoint has no name, skip duplicate check\n        if waypoint.name and waypoint.name ~= \"\" then\n            -- Check if a waypoint with the same name already exists\n            for _,v in ipairs(self.waypoints) do\n                if v.name == waypoint.name then\n                    return nil\n                end\n            end\n        end\n        local wplus1 = 1 + #self.waypoints\n        if index then\n            -- Check if the specified index is within the valid range\n            if index < 1 or index > wplus1 then\n                print(\"[E] Invalid index. Must be in the range 1 to \" .. wplus1)\n                return nil\n            end\n            waypoint.parent = self\n            table.insert(self.waypoints, index, waypoint)\n        else\n            waypoint.parent = self\n            table.insert(self.waypoints, wplus1, waypoint)\n        end\n        return waypoint\n    else\n        print(\"[E] Invalid waypoint parameter!\")\n        return nil\n    end\nend\n\n---@comment List of waypoints' data as table.\n---@return table (systemId, planetId, latitude, longitude, altitude)\nWaypointMgr.getWaypointsData = function(self)\n    local res = {}\n    for k,v in ipairs(self.waypoints) do\n        table.insert(res, k, v:get())\n    end\n    return res\nend\n\n---@comment List of all waypoints as Waypoint objects.\n---@return table Array of all Waypoint instances\nWaypointMgr.getWaypointsInst = function(self)\n    return self.waypoints\nend\n\n---@comment Returns the count of all waypoints\n---@return integer Count of all waypoints\nWaypointMgr.getCount = function(self)\n    return #self.waypoints\nend\n\n---@comment Returns array of all waypoint instances sorted by their name\n---@return table Array\nWaypointMgr.getSorted = function(self)\n    local sortedPoints = {}\n\n    -- Copy waypoints to a new table for sorting\n    for _,v in pairs(self.waypoints) do\n        table.insert(sortedPoints, v)\n    end\n\n    -- Sort the copied table by waypoint names\n    table.sort(sortedPoints, function(a, b)\n        return a.name < b.name\n    end)\n    return sortedPoints\nend\n\n---@comment Moves waypoint at given index up by one, but 1 as minimum\nWaypointMgr.moveUp = function(self, index)\n    local waypointsCount = #self.waypoints\n\n    if index and index > 1 and index <= waypointsCount then\n        self.waypoints[index], self.waypoints[index - 1] = self.waypoints[index - 1], self.waypoints[index]\n    end\nend\n\n---@comment Moves waypoint at given index down by one, but to end index as maximum\nWaypointMgr.moveDown = function(self, index)\n    local waypointsCount = #self.waypoints\n\n    if index and index >= 1 and index < waypointsCount then\n        self.waypoints[index], self.waypoints[index + 1] = self.waypoints[index + 1], self.waypoints[index]\n    end\nend\n\n---@comment Removes only the first waypoint with the given name and returns that waypoint instance, otherwise nil\n---@return any Either removed waypoint instance or nil if not found\nWaypointMgr.removeByName = function(self, waypointName)\n    for i, waypoint in ipairs(self.waypoints) do\n        if waypoint.name == waypointName then\n            local removedWaypoint = table.remove(self.waypoints, i)\n            return removedWaypoint  -- Return the removed waypoint\n        end\n    end\n    return nil  -- Return nil if not found\nend\n\n---@comment Returns true if at least one waypoint exist, else false\n---@return boolean\nWaypointMgr.hasPoints = function(self, param)\n    return #self.waypoints > 0\nend\n\n---@comment Checks if a waypoint exists in 3 different ways: name, waypoint instance or same data\n---@return any If not found, returns nil, otherwise the found waypoint instance\nWaypointMgr.exists = function(self, param)\n    for _, v in ipairs(self.waypoints) do\n        if type(param) == \"string\" and v.name == param then\n            return v\n        elseif param and param.__Waypoint and Waypoint.__Waypoint() then\n            if v == param then\n                return v\n            end\n        elseif type(param) == \"table\" and #param == 5 then\n            -- Check if a waypoint with the same nums exists\n            if v.mapPos.systemId  == tonum(param[1]) and\n               v.mapPos.id        == tonum(param[2]) and\n               v.mapPos.latitude  == tonum(param[3]) and\n               v.mapPos.longitude == tonum(param[4]) and\n               v.mapPos.altitude  == tonum(param[5]) then\n                return v\n            end\n        end\n    end\n    return nil\nend\n\nWaypointMgr.getName = function(self)\n    return self.name\nend\n\nWaypointMgr.new = function(name)\n    local obj = setmetatable(\n        { waypoints = {}, name = name or \"\" },\n        { __index = WaypointMgr }\n    )\n    return obj\nend\n\nreturn WaypointMgr\n\nend)\npackage.preload['YFS-Tools:libmain.lua']=(function()\n-- require used classes and instantiate important ones\nSU = require('YFS-Tools:../util/SU.lua') -- string utils\nOut = require('YFS-Tools:../util/out.lua') -- output utils\nP = Out.PrintLines\nE = Out.Error\n\nrequire('YFS-Tools:../util/Dtbk.lua') -- databank\n\nrequire('YFS-Tools:libutils.lua') -- helper functions\nCmd = require('YFS-Tools:commands.lua') -- all YFS Tools commands\nHelp = require('YFS-Tools:help.lua') -- help utils\n\nrequire('YFS-Tools:warpcost.lua') -- warp calculator function\n\nrequire('YFS-Tools:../util/wpoint.lua') -- waypoint class\nWM = require('YFS-Tools:../util/wpointmgr.lua').new(\"MAIN\") -- instantiate MAIN waypoint manager\n\nWaypointInfo = require('atlas')\n\nWolfAR = nil -- customized Wolf Labs' AR waypointing\nend)\npackage.preload['YFS-Tools:../util/pos.lua']=(function()\n--- Class related to positions/coordinates like local/world conversion etc.\n--- requires global WaypointInfo table (= atlas), vec3 library; classes SU, Out\nlocal max, cos, macos, mdeg, msin, mabs, atan, ceil, floor, mpi = math.max, math.cos, math.acos, math.deg, math.sin, math.abs, math.atan, math.ceil, math.floor, math.pi\nlocal tonum, strlen, strmatch, sformat = tonumber, string.len, string.match, string.format\nlocal uclamp, vec3 = utils.clamp, vec3\n\nlocal o = {}\no.__index = o\nfunction o.New(pCore, pConstruct, pWM)\n    -- Private attribute\n    local s = {\n        core = pCore,\n        construct = pConstruct,\n        Alioth1G = 9.891,\n        waypointNames = {},\n        waypointCount = 0,\n        planetNames = {},\n        p = {}, -- Planet object\n        pIdx = 0, -- Atlas planet index\n        wm = pWM -- Waypoint Manager instance\n    }\n\n    local function float_eq(a, b) -- float equation\n        if a == 0 then\n            return mabs(b) < 1e-09\n        elseif b == 0 then\n            return mabs(a) < 1e-09\n        else\n            return mabs(a - b) < math.max(mabs(a), mabs(b)) * epsilon\n        end\n    end\n\n    ---@return boolean\n    local function constructPresent()\n        return s.construct ~= nil\n    end\n\n    ---@return boolean\n    local function corePresent()\n        return s.core ~= nil\n    end\n\n    -- Public functions\n\n    ---@return number amount of warp cells\n    function o.ComputeCells(distance, tons)\n        return ceil(max(floor(tons*floor(((distance/1000)/200))*0.00024), 1))\n    end\n\n    ---@return string\n    function o.GetPosPattern()\n        local num = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\n        return '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' .. num ..  ',' .. num .. '}'\n    end\n\n    ---@return number # of entries in WaypointInfo/Atlas\n    function o.GetWaypointCount()\n        return s.wm:getCount()\n    end\n\n    ---@param posStr string ::pos{} string\n    ---@return table|nil returns a MapPos table of the coords or nil if invalid string\n    function o.SplitPos(posStr)\n        -- min. length is 16: \"::pos{0,1,2,3,4}\"\n        if type(posStr) ~= \"string\" then\n            P(\"[E] Invalid position: \"..type(posStr))\n            return nil\n        end\n        if strlen(posStr) < 16 or not strmatch(posStr, \"^::pos{\") then\n            P(\"[E] Invalid position: \"..posStr)\n            return nil\n        end\n        local sysId, pId, lat, lng, alt = strmatch(posStr, o.GetPosPattern())\n        return { systemId  = tonum(sysId),\n                 id        = tonum(pId),\n                 latitude  = tonum(lat),\n                 longitude = tonum(lng),\n                 altitude  = tonum(alt) }\n    end\n\n    ---@param posString string The ::pos{} string in local coords!\n    ---@return number Altitude in meters (if a local pos -> relative to sea level)\n    function o.GetAltitudeFromPos(posString)\n        local p = o.SplitPos(posStr)\n        if p and p.altitude then return p.altitude end\n        return 0\n    end\n\n    ---@param posStr string The ::pos{} string\n    ---@return integer Id of planet in Atlas, e.g. 2 for Alioth; 0 for Space!\n    function o.GetPlanetFromPos(posStr)\n        local p = o.SplitPos(posStr)\n        if p and p.id and p.id > 0 then return p.id end\n        return 0\n    end\n\n    function o.GetAtlasPlanet(pid)\n        if not pid or not WaypointInfo[0] or not WaypointInfo[0][tonum(pid)] then\n            return nil\n        end\n        return WaypointInfo[0][tonum(pid)]\n    end\n\n    function o.GetClosestPlanetId(worldPosVec)\n        local pIdx, dist = 0, 0\n        local planetDistance = math.huge\n        for i,v in pairs(WaypointInfo[0]) do\n            dist = (worldPosVec - vec3(v.center)):len()\n            if dist < planetDistance then\n                planetDistance = dist\n                pIdx = i\n            end\n        end\n        return pIdx\n    end\n\n    function o.GetClosestPlanet(worldPosVec)\n        local pid = o.GetClosestPlanetId(worldPosVec)\n        return o.GetAtlasPlanet(pid)\n    end\n\n    function o.GetCurrentPosString()\n        local v = o.WorldPosVec3()\n        return o.MapPos2String(o.WorldToMapPos(v))\n    end\n\n    ---@comment Formats a MapPos table to a ::pos{} string\n    ---@return string\n    function o.MapPos2String(mapPos)\n        if type(mapPos) ~= \"table\" then return \"\" end\n        return '::pos{' .. (mapPos.systemId or 0).. ',' .. (mapPos.id or 0) .. ',' ..\n               sformat(\"%.4f\", (mapPos.latitude or 0)) .. ',' .. \n               sformat(\"%.4f\", (mapPos.longitude or 0)) ..  ',' ..\n               sformat(\"%.4f\", (mapPos.altitude or 0)) .. '}'\n    end\n\n    ---@comment Formats a vec3 world-pos table to a ::pos{} string (planet id 0!)\n    ---@return string\n    function o.Vec3ToPosString(v3)\n        if type(v3) ~= \"table\" then return \"\" end\n        return '::pos{0,0,' ..\n               sformat(\"%.4f\", (v3.x or 0)) .. ',' ..\n               sformat(\"%.4f\", (v3.y or 0)) ..  ',' ..\n               sformat(\"%.4f\", (v3.z or 0)) .. '}'\n    end\n\n    ---@comment Formats a vec3 world-pos table to a ::pos{} string (planet id 0!)\n    ---@return string\n    function o.Vec3String(v3)\n        if type(v3) ~= \"table\" then return \"\" end\n        v3 = vec3(v3)\n        return sformat(\"%.4f\", (v3.x or 0)) .. ', ' ..\n               sformat(\"%.4f\", (v3.y or 0)) .. ', ' ..\n               sformat(\"%.4f\", (v3.z or 0))\n    end\n\n    ---@param posStr string ::pos{} string for change\n    ---@param newAltitude number? new altitude value\n    ---@return string\n    function o.ReplaceAltitudeInPos(posStr, newAltitude)\n        --TODO: move this to Waypoint class; allow class as param\n        local p = o.SplitPos(posStr)\n        if not p or not p.altitude or not newAltitude then\n            return posStr\n        end\n        p.altitude = tonum(newAltitude)\n        return o.MapPos2String(p)\n    end\n\n    ---@comment Returns current planet id if in game, otherwise 2\n    ---@return number\n    function o.PlanetId()\n        if not corePresent() then return 0 end\n        if not INGAME then\n            return 2 -- Alioth\n        end\n        return s.core.getCurrentPlanetId()\n    end\n\n    ---@comment If code is run outside of game, a fixed vec3 will be returned for testing!\n    ---@return any Vec3 position of construct (or nil)\n    function o.WorldPosVec3()\n        if not INGAME then\n            return { x = -25140.37011013, y = 100812.26194182, z = -52412.710373821}\n        end\n        if constructPresent() then\n            ---@diagnostic disable-next-line: missing-parameter\n            return vec3(construct.getWorldPosition())\n        end\n        if corePresent() then\n            ---@diagnostic disable-next-line: missing-parameter\n            return vec3(core.getWorldPosition())\n        end\n        return nil\n    end\n\n    ---@comment If close to planet, returns the current altitude\n    ---@return number Altitude in meters; 0 if not close to a planet!\n    function o.Altitude()\n        local p = o.GetAtlasPlanet(o.PlanetId())\n        if not p or not p.center then return 0 end\n        return (o.WorldPosVec3() - vec3(p.center)):len() - (p.radius or 0)\n    end\n\n    ---@comment Returns distance between\n    --- a) current construct position and the one passed in\n    ---   posStr (distTo not specified) in ::pos{0,x,...} format!\n    --- OR\n    --- b) both params specified, each separate coords.\n    ---@param posStr string ::pos() string to measure FROM\n    ---@param distTo nil optional ::pos() to measure TO; if empty -> current position\n    ---@return number\n    function o.GetDistance(posStr, distToStr)\n        local curPos = o.WorldPosVec3()\n        if type(distToStr) == \"string\" then\n            curPos = o.MapPosToWorldVec3(distToStr)\n        elseif type(distToStr) == \"table\" then\n            curPos = vec3(distToStr)\n        end\n        local wPos = o.MapPosToWorldVec3(posStr)\n        local dist = vec3(wPos - curPos):len()\n        return dist\n    end\n\n    ---@comment experimental/unused; credit to Jeronimo\n    ---@return number,number,number with x,y,z\n    function o.World2local(x,y,z)\n        --if not o.construct then return 0,0,0 end\n        local cWOUP = s.construct.getWorldOrientationUp()\n        local cWOF = s.construct.getWorldOrientationForward()\n        local cWOR = s.construct.getWorldOrientationRight()\n        local cWOUPx, cWOUPy, cWOUPz = cWOUP[1], cWOUP[2], cWOUP[3]\n        local cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]\n        local cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]\n\n        local v = library.systemResolution3(\n            {cWORx,  cWORy, cWORz},\n            {cWOFx,  cWOFy, cWOFz},\n            {cWOUPx, cWOUPy, cWOUPz},\n            {x, y, z})\n        return v[1],v[2],v[3]\n    end\n\n    ---@param v table the vec3() position to convert\n    ---@return any MapPos table or nil\n    function o.WorldToMapPos(v)\n        local body = o.GetClosestPlanet(v)\n        if not body or not body.center or not body.radius then\n            return { systemId = 0, id = 0, latitude = v.x, longitude = v.y, altitude = v.z }\n        end\n        local coords = v - vec3(body.center)\n        local dist = coords:len()\n        local alt = dist - body.radius\n        local latitude = 0\n        local longitude = 0\n        if not float_eq(dist, 0) then\n            local phi = atan(coords.y, coords.x)\n            --phi >= 0 ???\n            longitude = phi or (2 * mpi + phi)\n            latitude = mpi / 2 - macos(coords.z / dist)\n        end\n        return {\n            latitude  = mdeg(latitude),\n            longitude = mdeg(longitude),\n            altitude  = alt,\n            id        = body.systemId,\n            systemId  = body.id }\n    end\n\n    function o.PlanetByName(name)\n        if type(name) ~= \"string\" or name == \"\" then return nil end\n        name = name:lower()\n        if s.planetNames[name] then\n            local pid = tonum(s.planetNames[name])\n            return WaypointInfo[0][pid]\n        end\n        return nil\n    end\n\n    ---comment Converts ::pos{} string into vec3\n    ---@param posStr string ::pos{} string\n    ---@return any vec3() or nil\n    function o.MapPosToWorldVec3(posStr)\n        local p = o.SplitPos(posStr)\n        if not p or not p.systemId then return nil end\n        if (p.systemId == 0 and p.id == 0) then -- already WorldPos\n            return vec3(p.latitude, p.longitude, p.altitude)\n        end\n        if not WaypointInfo[p.systemId] then return nil end\n        local planet = WaypointInfo[p.systemId][p.id]\n        --credits to Saga for lat/lon calc\n        local lat = constants.deg2rad * uclamp(p.latitude, -90, 90)\n        local lon = constants.deg2rad * (p.longitude % 360)\n        local xproj = cos(lat)\n        local planetxyz = vec3(xproj*cos(lon), xproj*msin(lon), msin(lat))\n        return vec3(planet.center) + (planet.radius + p.altitude) * planetxyz\n    end\n\n    function o.PlanetInfo(id)\n        local pid = nil\n        if type(id) == \"string\" and id:len() == 0 then\n            id = o.GetClosestPlanetId(o.WorldPosVec3())\n        end\n        if type(id) == \"string\" and s.planetNames[id:lower()] then -- id as planet name\n            pid = tonum(s.planetNames[id:lower()])\n        elseif type(id) == \"number\" and tonum(id) > 0 then -- id as planet id\n            pid = tonum(id)\n        end\n        if pid == nil then\n            return E(\"[E] No valid planet name or id specified!\")\n        end\n        local p = o.GetAtlasPlanet(pid)\n        if not p or type(p.name) ~= \"table\" then\n            return E(\"[E] No planet found!\")\n        end\n        P\"~~~~~~~~ PLANET INFO ~~~~~~~~\"\n        if id == '' then\n          P(\"Hint: '/planetInfo 2' for Alioth\")\n        end\n        P(\"Name: \"..p.name[1]..\" (Id: \".. p.id ..\")\")\n        P(\"Center: \"..p.center[1]..\" / \"..p.center[2]..\" / \"..p.center[3])\n        P(\"Radius: \"..(p.radius or 0)..\"m\")\n        local tmp = \"\"\n        if p.gravity and p.gravity > 0 then\n            tmp = \" (\"..sformat(\"%.1f\", (p.gravity / s.Alioth1G)) ..\" g)\"\n        end\n        P(\"Gravity: \"..(p.gravity or 0)..tmp)\n        if p.satellites and #p.satellites > 0 then\n          P(\"Has Moons: \"..#p.satellites)\n        end\n        P(\"Surface Min Alt.: \"..(p.surfaceMinAltitude or 0)..\"m\")\n        P(\"Surface Max Alt.: \"..(p.surfaceMaxAltitude or 0)..\"m\")\n        P(\"Max Static Alt.: \"..(p.maxStaticAltitude or \"\")..\"m\")\n        P(\"Has atmosphere: \"..BoolStr(p.hasAtmosphere))\n        if p.hasAtmosphere then\n          P(\"Atmo Thickness: \"..(p.atmosphereThickness or 0)..\"m\")\n          P(\"Atmo altitude: \"..(p.atmoAltitude or 0)..\"m\")\n          P(\"Atmo 10%: \"..(p.atmo10 or 0)..\"m\")\n        end\n        P(\"Is in Safe Zone: \"..BoolStr(p.isInSafeZone))\n        P\"~~~~~~~~~~~~~~~~~~~~~~~~~~~\"\n    end\n\n    ---@comment Adds a named waypoint to the internal list.\n    --- Source position string can be local or world position.\n    --- World position will be converted to local and ::pos{}\n    --- changed accordingly - IF a closest body was in range.\n    ---@param posString string Local or world ::pos{} string\n    ---@param wpName string Name of the newly named waypoint\n    ---@return boolean true if added else false\n    function o.CreateWaypoint(posString, wpName)\n        if not s.wm or not wpName or wpName == '' or s.waypointNames[wpName] then\n            return false\n        end\n\n        -- convert between local and world pos if needed\n        local p = o.SplitPos(posString)\n        if not p or not p.systemId then return false end\n\n        -- if world pos, try to determine planet\n        if p.id == 0 then\n            local w = o.WorldToMapPos(vec3{ p.latitude, p.longitude, p.altitude })\n            if w and w.id and w.id > 0 then\n                -- update pos with converted values\n                p.latitude  = w.latitude\n                p.longitude = w.longitude\n                p.altitude  = w.altitude\n                p.id        = w.id\n                p.systemId  = w.systemId\n                posString = o.MapPos2String(p)\n            end\n        end\n\n        -- add waypoint to waypoint manager\n        local wp = Waypoint:new(s.wm):setName(wpName):set(posString)\n        if not wp or wp == {} then return false end\n        if s.wm:exists(wp) then return false end\n        return s.wm:add(wp)\n    end\n\n    ---@comment Simple test for coord conversion\n    function o.ConversionTest()\n        local p1 = \"::pos{0,2,35.5118,104.0375,285.3076}\"\n        local w1 = o.MapPosToWorldVec3(p1)\n        P(\"HQ local to world:\\n\"..p1..\" =\")\n        P(o.Vec3ToPosString(w1))\n        local w2 = o.WorldToMapPos(w1)\n        Out.DeepPrint(w2)\n        P(\"World to local (should show same as above):\")\n        P(o.MapPos2String(w2))\n\n        local wp = \"::pos{0,0,-24955.2183,99771.5731,-52908.1353}\"\n        if o.CreateWaypoint(wp, \"WorldPos\") then\n          P(\"Added 'WorldPos' waypoint\")\n        else\n          P(\"Failed to add test waypoint!\")\n        end\n    end\n\n    local function init()\n        s.pIdx = 0\n        s.p = o.GetAtlasPlanet(o.PlanetId())\n        if s.p then s.pIdx = s.p.id end\n        if not WaypointInfo[0] then return end\n        s.planetNames = {}\n        for i, v in pairs(WaypointInfo[0]) do\n            s.planetNames[v.name[1]:lower()] = i\n            -- remove junk\n            WaypointInfo[0][i].biosphere = nil\n            WaypointInfo[0][i].classification = nil\n            WaypointInfo[0][i].description = nil\n            WaypointInfo[0][i].habitability = nil\n            WaypointInfo[0][i].ores = nil\n            -- new props\n            WaypointInfo[0][i].centerV3 = vec3(WaypointInfo[0][i].centerVec)\n            if v.hasAtmosphere then\n                local res = v.atmosphereRadius - v.radius\n                WaypointInfo[0][i].atmoAltitude = res\n                WaypointInfo[0][i].atmo10 = res * 0.9\n            end\n            WaypointInfo[0][i].isAsteroid = WaypointInfo[0][i].type[1] == \"Asteroid\"\n            WaypointInfo[0][i].isMoon = WaypointInfo[0][i].type[1] == \"Moon\"\n            WaypointInfo[0][i].isPlanet = WaypointInfo[0][i].type[1] == \"Planet\"\n        end\n\n        if s.wm then\n            P(\"[I] WaypointMgr assigned: \"..s.wm:getName())\n        else\n            P(\"[E] NO WaypointMgr assigned!\")\n        end\n    end\n\n    init()\n    return setmetatable(s, o)\nend -- .New\n\nreturn o\nend)\npackage.preload['YFS-Tools:startup.lua']=(function()\n---@diagnostic disable: undefined-field\nlocal onlyForRoute=\"\"--export: Load waypoints only for this route (enclosed in double quotes!)\nlocal onlySelectableWP=true--export: Check to only display custom route waypoints that are marked as selectable\nlocal loadWaypoints=true--export: Enable to load custom waypoints from databank\nlocal outputFont=\"FiraMono\"--export: Name of font used for screen output. Default: \"FiraMono\"\n\nonlyForRoute = onlyForRoute or \"\"\nOutputFont = outputFont or \"FiraMono\"\n\nP(\"=========================================\")\nP(\"YFS-Tools 1.6 (unofficial)\")\nP(\"created by tobitege (c) 2023\")\nP(\"Thanks to Yoarii (SVEA) for YFS and LUA help!\")\nP(\"YFS 1.4+ databank link required (Routes).\")\nP(\"=========================================\")\nP(\"* WARNING: do not run commands that change\")\nP(\"* waypoints/routes while YFS runs!\")\nP(\"=========================================\")\nP(\"LUA parameter(s):\")\nP(\"Load waypoints from databank: \" .. BoolStr(loadWaypoints))\nP(\"Only waypoints for route: \" .. onlyForRoute)\nP(\"Only selectable waypoints: \" .. BoolStr(onlySelectableWP))\nP(\"Screen output font name: \" .. OutputFont)\nP(\"=========================================\")\n\nlocal status, err = false, nil\nif INGAME then\n    status, err, _ = xpcall(function()\n        Config.core = library.getCoreUnit()\n        Config.databanks = library.getLinksByClass('DataBank', true) -- true is important!\n        Config.screens = library.getLinksByClass('Screen', true)\n    end, Traceback)\n    if not status then\n        P(\"Error in Link Detection:\\n\" .. err)\n        unit.exit()\n        return\n    end\nelse\n    -- this requires du-mocks\n    Config.core = unit.core\n    Config.databanks =  { unit.databank }\n    Config.screens =  { unit.screen }\nend\n\nif Config.core == nil then\n    P(\"[E] No Core connected! Ending script.\")\n    unit.exit()\n    return\nend\n\nPM = require('YFS-Tools:../util/pos.lua').New(Config.core, construct, WM) -- Positions and waypoint management\n\nif #Config.databanks > 0 then\n    local plural = \"\"\n    if #Config.databanks > 1 then plural = \"s\" else plural = \" '\"..Config.databanks[1].getName()..\"'\" end\n    P(#Config.databanks .. \" databank\" .. plural .. \" connected.\")\nelse\n    P(\"[E] DataBank not found.\")\nend\n\nif #Config.screens > 0 then\n    local plural = \"\"\n    if #Config.screens > 1 then plural = \"s\" end\n    P(#Config.screens .. \" screen\" .. plural .. \" connected.\")\nend\n\n-- for local debugging, see mockaround file for demo data!\nif not INGAME then\n    onlyForRoute = \"Garni\"\nend\n\n-- load waypoints from databank(s) (ArchHUD or YFS)?\nif loadWaypoints ~= true then\n    P(\"[I] Waypoints loading is off.\")\nelseif #Config.databanks > 0 then\n    local prevCount = 0\n    for ix=1, #Config.databanks, 1 do\n        ---@diagnostic disable-next-line: assign-type-mismatch\n        local db = Config.databanks[ix] ---@type table DataBank\n        P(\"===== Checking db '\"..db.getName()..\"' =====\")\n        if db.hasKey(ARCH_SAVED_LOCATIONS) then\n            P('ArchHud databank detected.')\n            DetectedArch = ix\n            local names = db.getStringValue(ARCH_SAVED_LOCATIONS)\n            if names ~= \"\" then\n                P('Searching stored locations...')\n                local locations = json.decode(names)\n                if IsTable(locations) then\n                    Cmd.GetStoredLocations(locations)\n                end\n            end\n        end\n        if db.hasKey(YFS_ROUTES) or db.hasKey(YFS_NAMED_POINTS) then\n            P('YFS databank detected.')\n            YFSDB = Dtbk.new(db)\n            DetectedYFS = true\n            if not onlySelectableWP then\n                Cmd.YFSLoadNamedWaypoints()\n            end\n            Cmd.YFSLoadRoutepoints(onlySelectableWP, onlyForRoute)\n        end\n        local count = PM.GetWaypointCount()\n        if count == prevCount then\n            P(\"[I] No waypoints loaded from db \"..ix)\n        else\n            P(\"[I] \"..(count - prevCount)..\" waypoints loaded from db \"..ix)\n        end\n        prevCount = PM.GetWaypointCount()\n    end\n    P(\"=======================\")\n    if PM.GetWaypointCount() > 0 then\n        P(\"[I] Total \"..PM.GetWaypointCount()..\" waypoints loaded.\")\n    else\n        P(\"[I] No waypoints loaded.\")\n    end\n    P(\"=======================\")\nend\nend)\npackage.preload['YFS-Tools:sys_onInputText.lua']=(function()\n-- requires utils, global instances Cmd, SU\n\nlocal inputTextFunc = {}\n\nfunction inputTextFunc.Run(t)\n    if not SU.StartsWith(t, \"/\") then return end\n    if not Cmd then\n        return E(\"[FATAL ERROR] Commands processor not assigned!\")\n    end\n    local cmdList = {}\n    cmdList['arch-save-named'] = 1\n    cmdList['conversionTest'] = 1\n    cmdList['posData'] = 1\n    cmdList['help'] = 'Help'\n    cmdList['planetInfo'] = 1\n    cmdList['printAltitude'] = 1\n    cmdList['printPos'] = 1\n    cmdList['printWorldPos'] = 1\n    cmdList['warpCost'] = 1\n    cmdList['wp-altitude-ceiling'] = 1\n    cmdList['wp-export'] = 1\n    cmdList['yfs-add-altitude-wp'] = 1\n    cmdList['yfs-build-route-from-wp'] = 1\n    cmdList['yfs-save-named'] = 1\n    cmdList['yfs-save-route'] = 1\n    cmdList['yfs-replace-wp'] = 1\n    cmdList['yfs-route-altitude'] = 1\n    cmdList['yfs-route-nearest'] = 1\n    cmdList['yfs-route-to-named'] = 1\n    cmdList['yfs-wp-altitude'] = 1\n    cmdList['DumpRoutes'] = 1\n    cmdList['DumpPoints'] = 1\n    cmdList['routes'] = 1\n    if DEBUG then\n        cmdList['YfsTestData'] = 1\n        cmdList['x'] = 1\n    end\n\n    for k, func in pairs(cmdList) do\n        if SU.StartsWith(t, \"/\"..k) then\n            local params = t:sub(k:len()+2) or \"\"\n            params = SU.Trim(params)\n            if k == 'help' then -- special case\n                k = \"PrintHelp\"\n            end\n            -- map command to function name, which must end with \"Cmd\"!\n            local fn = SU.SplitAndCapitalize(k,'-')..\"Cmd\"\n            -- default use global Cmd class, unless a value is specified other than 1\n            local cmdName = SU.If(type(func) == \"string\", func, \"Cmd\")\n            P(\"Executing /\"..k..SU.If(params ~= \"\", \" with: \"..params))\n            if not _G[cmdName] then\n                return E(\"[FATAL ERROR] \"..cmdName..\" not found!\")\n            end\n            if _G[cmdName][fn] then\n                return _G[cmdName][fn](params)\n            end\n        end\n    end\n    P(\"~~~~~~~~~~~~~~~~~~~~~\")\n    P(\"[E] Unknown command: \"..t)\n    P(\"[I] Supported commands:\")\n    for _,fn in ipairs(GetSortedAssocKeys(cmdList)) do\n       P(\"/\"..fn)\n    end\nend\n\nreturn inputTextFunc\nend)"},{"key":4,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":"library.addEventHandlers(library)\nlibrary.addEventHandlers(system)\nlibrary.addEventHandlers(player)\nlibrary.addEventHandlers(construct)\nlibrary.addEventHandlers(unit)"},{"key":5,"filter":{"slotKey":-4,"signature":"onActionStart(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionStart',action)"},{"key":6,"filter":{"slotKey":-4,"signature":"onActionLoop(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionLoop',action)"},{"key":7,"filter":{"slotKey":-4,"signature":"onActionStop(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionStop',action)"},{"key":8,"filter":{"slotKey":-4,"signature":"onUpdate()","args":[]},"code":"system:triggerEvent('onUpdate')"},{"key":9,"filter":{"slotKey":-4,"signature":"onFlush()","args":[]},"code":"system:triggerEvent('onFlush')"},{"key":10,"filter":{"slotKey":-4,"signature":"onInputText(text)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onInputText',text)"},{"key":11,"filter":{"slotKey":-4,"signature":"onCameraChanged(mode)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onCameraChanged',mode)"},{"key":12,"filter":{"slotKey":-3,"signature":"onParentChanged(oldId,newId)","args":[{"variable":"*"},{"variable":"*"}]},"code":"player:triggerEvent('onParentChanged',oldId,newId)"},{"key":13,"filter":{"slotKey":-2,"signature":"onDocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onDocked',id)"},{"key":14,"filter":{"slotKey":-2,"signature":"onUndocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onUndocked',id)"},{"key":15,"filter":{"slotKey":-2,"signature":"onPlayerBoarded(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onPlayerBoarded',id)"},{"key":16,"filter":{"slotKey":-2,"signature":"onVRStationEntered(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onVRStationEntered',id)"},{"key":17,"filter":{"slotKey":-2,"signature":"onConstructDocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onConstructDocked',id)"},{"key":18,"filter":{"slotKey":-2,"signature":"onPvPTimer(active)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onPvPTimer',active)"},{"key":19,"filter":{"slotKey":-1,"signature":"onStop()","args":[]},"code":"unit:triggerEvent('onStop')"},{"key":20,"filter":{"slotKey":-1,"signature":"onTimer(timerId)","args":[{"variable":"*"}]},"code":"unit:triggerEvent('onTimer',timerId)"},{"key":21,"filter":{"slotKey":-1,"signature":"onStart()","args":[]},"code":"\n\n-- Important for local debugging:\npackage.path = \"lua/?.lua;util/wpointer/?.lua;\"..package.path\nrequire('YFS-Tools:globals.lua')\n\n-- DU-LuaC checks for true are last, so that local debugging sees true!\n--WP_EG_ENABLED = true\n\nWP_WOLF_ENABLED = true\n\nDEBUG = false\nrequire('YFS-Tools:libmain.lua')\n\nif INGAME then\n    local Traceback = traceback\nelse\n    function Traceback(o)\n        if o then P(tostring(o)) end\n    end\n    require 'mockaround'\nend\n\nlocal status, err, _ = xpcall(function() require('YFS-Tools:startup.lua') end, Traceback)\nif not status then\n    P(\"[E] Error in startup!\")\n    if err then P(err) end\n    unit.exit()\n    return\nend\n\nlocal inp = require('YFS-Tools:sys_onInputText.lua')\nif inp ~= nil then\n    system:onEvent('onInputText', function (self, text) inp.Run(text) end)\nend\n\n\n\n\n\nif not WP_EG_ENABLED and not WP_WOLF_ENABLED then\n    P('[I] Waypointer module disabled.')\nelse\n    P('[I] Waypointer module enabled.')\n\n    unit.setTimer(\"update\", 1/60) -- The timer to update the screen\n    system.showScreen(1)\nend\n\nif INGAME then\n    if DEBUGx then\n        status, err, _ = xpcall(function() PM.ConversionTest() end, Traceback)\n        if not status then\n            if err then P(\"[E] Error in test call:\\n\" .. err) end\n            unit.exit()\n            return\n        end\n    else\n        unit.hideWidget()\n    end\n    P(\"Type /help for available commands.\")\n\nend"}],"events":[],"methods":[]}