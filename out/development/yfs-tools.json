{"slots":{"-5":{"name":"library","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}}},"handlers":[{"key":1,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":";(function()\nlocal a={}local b=0;function library.addEventHandlers(c)if not c or c.onEvent and c.triggerEvent then return false end;b=b+1;a[b]=c;local d,e,f='table','function','thread'if d~=type(c)then error('You can only add event handlers to table objects!')end;local g={}local function h(c)local i=type(c)return e==i or d==i and h(getmetatable(c).__call)or f==i end;c.onEvent=function(self,j,k,l)if not h(k)then error('Event handler must be a function, a callable object or a thread!')end;l=l or self;if d~=type(l)then error('The value of self must be a table!')end;if not g[j]then g[j]={_=0}end;local m=f==type(k)and function(...)coroutine.resume(k,...)end or k;local k=g[j]local n=k._+1;k[n]={m,l}k._=n;return n end;c.clearEvent=function(self,j,o)if g[j]and g[j][o]then g[j][o]=nil end end;c.clearAllEvents=function(self)g={}end;c.triggerEvent=function(self,j,...)local p=g[j]if p then for q=1,p._ do local k=p[q]if k then k[1](k[2],...)end end end end;return true end;function library.clearAllEventHandlers()for q=1,b do local c=a[q]if c and c.clearAllEvents then c:clearAllEvents()end end end\nend)()"},{"key":2,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":";(function()\nlocal a=DULibrary or{}function a.getLinks(b,c)local d={}if not b then b={}end;for e,f in pairs(unit.getOutPlugs())do local g=unit[f.name]if'table'==type(g)and'function'==type(g.getClass)then local h=true;for i,j in pairs(b)do if not('function'==type(g[i])and j==g[i]():sub(1,#j))then h=false;break end end;if h then if c then table.insert(d,g)else d[f.name]=g end end end end;return d end;function a.getLinksByClass(k,c)return a.getLinks({getClass=k},c)end;function a.getLinkByClass(k)return a.getLinksByClass(k,true)[1]end;function a.getCoreUnit()return a.getLinkByClass('CoreUnit')end;function a.getLinkByName(l)local m=a.getCoreUnit()if not m then error('getLinkByName requires a linked CoreUnit to work')end;local d=a.getLinks()for n,o in pairs(d)do if l==m.getElementNameById(o.getLocalId())then return o end end end\nend)()"},{"key":3,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":"package.preload['YFS-Tools:globals.lua']=(function()\nConfig = { core = nil, databanks = {}, screens = {} }\nDetectedArch = 0\nDetectedYFS = false\nYFSDB = nil\nYFS_NAMED_POINTS = \"NamedPoints\"\nYFS_ROUTES = \"NamedRoutes\"\nARCH_SAVED_LOCATIONS = \"SavedLocations\"\nDEBUG = false\nScriptStartTime = 0\nINGAME = system ~= nil\n\nif not INGAME then\n\nelse\n    ScriptStartTime = system.getArkTime()\n    print = system.print\nend\n\nprojector = nil\nclicked = false \nWP_EG_ENABLED = false WP_WOLF_ENABLED = false \nCNID = construct.getId()\nend)\npackage.preload['YFS-Tools:../util/SU.lua']=(function()\nlocal SU = {}\n\nlocal strmatch, strlen, tonum = string.match, string.len, tonumber\n\nfunction SU.Trim(s)\n    if strlen(s) == 0 then return \"\" end\n    return SU.Ltrim(SU.Rtrim(s))\nend\n\nfunction SU.Ltrim(s)\n    local res, _ = string.gsub(s, \"^%s+\", \"\")\n    return res\nend\n\nfunction SU.Rtrim(s)\n    local res, _ = string.gsub(s, \"%s+$\", \"\")\n    return res\nend\n\nfunction SU.Pad(s, padChar, length)\n    if not s or not length or not padChar or tonum(length) < 1 then return s end\n    return string.rep(padChar, length - s:len()) .. s\nend\n\nfunction SU.StartsWith(s, prefix)\n    if not s or not prefix then return false end\n    return string.sub(s, 1, #prefix) == prefix\nend\n\nfunction SU.EndsWith(s, suffix)\n    if not s or not suffix then return false end\n    return string.sub(s, -#suffix) == suffix\nend\n\nfunction SU.RtrimChar(s,char)\n    if not s or not char then return s end\n    while #s > 0 and SU.EndsWith(s, char) do\n        s = string.sub(s,1,#s - #char)\n    end\n    return s\nend\n\nfunction SU.SplitQuoted(s)\n    local function isQuote(c) return c == '\"' or c == \"'\" end\n    local function isSpace(c) return c == \" \" end\n\n    local function add(target, v)\n        v = SU.Trim(v)\n        if v:len() > 0 then\n            table.insert(target, #target + 1, v)\n        end\n    end\n\n    local inQuote = false\n    local parts = {}     if type(s) ~= \"string\" or s == \"\" then\n        return parts\n    end\n\n    local current = \"\"\n    for c in string.gmatch(s, \".\") do\n        if isSpace(c) and not inQuote then\n                        add(parts, current)\n            current = \"\"\n        elseif isQuote(c) then\n            if inQuote then                 add(parts, current)\n                current = \"\"\n                inQuote = false\n            else                 add(parts, current)\n                current = \"\"\n                inQuote = true\n            end\n        else\n            current = current .. c\n        end\n    end\n\n        add(parts, current)\n\n    return parts\nend\n\nfunction SU.If(cond, trueValue, falseValue)\n    if cond then\n        return tostring(trueValue or \"\")\n    end\n    return tostring(falseValue or \"\")\nend\n\nfunction SU.isPrintable(char)\n    return strmatch(char, \"[%g%s]\") ~= nil\nend\n\nfunction SU.SplitAndCapitalize(inputString, delimiter)\n    if not inputString or not SU.isPrintable(delimiter) then\n        return inputString\n    end\n    local parts = {}\n    for part in inputString:gmatch(\"[^\" .. delimiter .. \"]+\") do\n        table.insert(parts, part)\n    end\n    for i = 1, #parts do\n        parts[i] = parts[i]:sub(1, 1):upper() .. parts[i]:sub(2)\n    end\n    return table.concat(parts)\nend\n\nreturn SU\nend)\npackage.preload['YFS-Tools:../util/out.lua']=(function()\nlocal o = {}\n\nfunction o.PrettyDistance(dist)\n    if dist < 10000 then\n        return Round(dist,2)..\" m\"\n    end\n    if dist < 200000 then\n        return Round(dist/1000,2)..\" km\"\n    end\n    return Round(dist/200000,2)..\" SU\"\nend\n\nfunction o.PrettyMass(mass)\n    if mass > 1000000 then\n        return Round(mass / 1000000,2)..\" KT\"\n    end\n    if mass > 1000 then\n        return Round(mass / 1000,2)..\" tons\"\n    end\n    return Round(mass,2)..\" kg\"\nend\n\nfunction o.PrintLines(s)\n    if not s then return end\n    if type(s) ~= \"string\" then s = tostring(s) end\n    for str in s:gmatch(\"([^\\n]+)\") do\n         print(str)\n    end\nend\n\nfunction o.Error(err)\n    o.PrintLines(err)\n    return false\nend\n\nfunction o.DeepPrint(e, maxItems)\n    if IsTable(e) then\n        local cnt = 0\n        maxItems = maxItems or 0\n        for k,v in pairs(e) do\n            if IsTable(v) then\n                P(\"-> \"..k)\n                o.DeepPrint(v, maxItems)\n            elseif type(v) == \"boolean\" then\n                P(k..\": \"..BoolStr(v))\n            elseif type(v) == \"function\" then\n                P(k..\"()\")\n            elseif v == nil then\n                P(k..\" (\"..type(v)..\")\")\n            else\n                P(k..\": \"..tostring(v))\n            end\n            cnt = cnt + 1\n            if maxItems > 0 and cnt >= maxItems then\n               P(\"^:^:^:^: cutoff reached :^:^:^:^\")\n                return\n            end\n        end\n    elseif type(e) == \"boolean\" then\n       P(BoolStr(e))\n    else\n       P(e)\n    end\nend\n\nfunction o.DumpVar(data)\n        local tablecache = {}\n    local buffer = \"\"\n    local padder = \"    \"\n    local function _dumpvar(d, depth)\n        local t = type(d)\n        local str = tostring(d)\n        if (t == \"table\") then\n            if (tablecache[str]) then\n                                                buffer = buffer..\"<\"..str..\">\\n\"\n            else\n                tablecache[str] = (tablecache[str] or 0) + 1\n                buffer = buffer..\"(\"..str..\") {\\n\"\n                for k, v in pairs(d) do\n                    buffer = buffer..string.rep(padder, depth+1)..\"[\"..k..\"] => \"\n                    _dumpvar(v, depth+1)\n                end\n                buffer = buffer..string.rep(padder, depth)..\"}\\n\"\n            end\n        elseif (t == \"boolean\") then\n            buffer = buffer..\"(\"..BoolStr(t)..\")\\n\"\n        elseif (t == \"number\") then\n            buffer = buffer..\"(\"..t..\") \"..str..\"\\n\"\n        else\n            buffer = buffer..\"(\"..t..\") \\\"\"..str..\"\\\"\\n\"\n        end\n    end\n    _dumpvar(data, 0)\n    return buffer\nend\n\nreturn o\nend)\npackage.preload['YFS-Tools:../util/Dtbk.lua']=(function()\nDtbk = {}\nDtbk.__index = Dtbk;\nfunction Dtbk.new(bank)\n    local self = setmetatable({}, Dtbk)\n    self.DB = bank\n    self.concat = table.concat\n    return self\nend\nfunction Dtbk.hasKey(self,tag)\n    return self.DB.hasKey(tag)\nend\nfunction Dtbk.getString(self,tag)\n    return self.DB.getStringValue(tag)\nend\nfunction Dtbk.setString(self,tag,value)\n    self.DB.setStringValue(tag,value)\nend\nfunction Dtbk.setData(self,tag,value)\n    local str = json.encode(value)\n    self.DB.setStringValue(tag,str)\nend\nfunction Dtbk.getData(self,tag)\n    local tmp = self.DB.getStringValue(tag)\n    if tmp == nil then return nil end\n    local str = json.decode(tmp)\n    return str\nend\nfunction Dtbk.remove(self,key)\n    self.DB.clearValue(key)\nend\nfunction Dtbk.ResetAll(self)\n    self.DB.clear()\nend\nend)\npackage.preload['YFS-Tools:libutils.lua']=(function()\nlocal tonum, strmatch = tonumber, string.match\n\nfunction IsTable(obj)\n    return obj ~= nil and type(obj) == \"table\"\nend\n\nfunction GetSortedAssocKeys(source)\n    local L = {}\n    if not IsTable(source) then E(\"[E] Invalid object for GetSortedKeys()!\") return L end\n    for k,_ in pairs(source) do\n        table.insert(L, k)\n    end\n    table.sort(L)\n    return L\nend\n\nfunction Round(num, decimals)\n    local mult = 10^(decimals or 0)\n    return ((num*mult) + (2^52 + 2^51) - (2^52 + 2^51))/mult\nend\n\nfunction TableLen(source)\n    if not IsTable(source) then return 0 end\n    local cnt = 0\n    for _ in pairs(source) do\n      cnt = cnt + 1\n    end\n    return cnt\nend\n\nfunction GetIndex(source, value)\n    if not IsTable(source) then return -1 end\n    for k, v in pairs(source) do\n      if value == v then return k end\n    end\n    return -1\nend\n\nfunction GetParamValue(srcTable, paramName, reqType, reqMsg)\n    local err = \"[E] Parameter value missing for \"..paramName\n    if srcTable == nil or not IsTable(srcTable) then\n        if reqMsg == true then P(err) end\n        return nil\n    end\n    for k, v in ipairs(srcTable) do\n        if v == paramName then\n            local idx = k + 1\n            if #srcTable < idx then\n                if reqMsg == true then P(err) end\n                return nil\n            end\n            local val = srcTable[idx]\n            if not reqType or reqType == \"string\" or reqType == \"s\" then\n                if val == '\"\"' or val == \"''\" then return nil end\n                return val\n            elseif ((reqType == \"int\" or reqType == \"i\") and not strmatch(val, \"%D\")) then\n                return tonum(val)\n            elseif reqType == \"number\" or reqType == \"n\" then\n                return tonum(val)\n            elseif reqType == \"bool\" or reqType == \"b\" then\n                if val then return true else return false end\n            end\n            return nil\n        end\n    end\n    if reqMsg == true then E(err) end\n    return nil\nend\n\nfunction PairsByKeys(t, f)\n    local a = {}\n    for n in pairs(t) do table.insert(a, n) end\n    table.sort(a, f)\n    local i = 0     local iter = function ()         i = i + 1\n        if a[i] == nil then\n            return nil\n        else\n            return a[i], t[a[i]]\n        end\n    end\n    return iter\nend\n\nfunction BoolState(bool)\n    if bool then\n        return \"enabled\"\n    else\n        return \"disabled\"\n    end\nend\n\nfunction BoolStr(b)\n    if b == true then\n        return \"true\"\n    else\n        return \"false\"\n    end\nend\n\nfunction ScreenOutput(output, chatFooter)\n    local chat = \"Point at screen, CTRL+L, then copy text!\"\n    if #Config.screens >  0 then\n                                        local font = OutputFont or \"FiraMono\"\n        local pre = \"local text = [[\\n\"..output..\"\\n]]\\n\"..\n[[\nlocal rslib = require('rslib')\nlocal layer = createLayer()\nlocal rx, ry = getResolution()\nlocal fontSize = 15\nlocal font = loadFont(\"]]..font..[[\", fontSize)\nlocal line = 1\nfor str in text:gmatch(\"([^\\n]+)\") do\n    addText(layer, font, str, 20, line*(fontSize+4))\n    line = line + 1\nend ]]\n                Config.screens[1].setRenderScript(pre)\n        if chatFooter and chatFooter:len() then\n            chat = chatFooter..\"\\n\"..chat\n        end\n    else\n        chat = \"Hint: link a screen to PB to easily copy text from it!\"\n    end\n    P(chat)\n    return true\nend\nend)\npackage.preload['YFS-Tools:commands.lua']=(function()\nlocal cmd = {}\n\n\nlocal strmatch, sformat, strlen = string.match, string.format, string.len\nlocal tonum, uclamp, mabs, max, floor, ceil = tonumber, utils.clamp, math.abs, math.max, math.floor, math.ceil\n\n\nlocal function yfsAddAltitudeWaypoints(wpdata, wpnames, altitude, suffix)\n    local cnt = 0\n    local names = {}\n    local wpCnt = #wpnames\n    for _,k in ipairs(wpnames) do\n        local wp = wpdata.v[k]\n        if wp ~= nil then\n            cnt = cnt + 1\n            local wpN = k .. suffix\n            if cnt > 1 then table.insert(names, wpN) end\n            table.insert(names, k)\n            if cnt < wpCnt then table.insert(names, wpN) end\n            local newPos = PM.ReplaceAltitudeInPos(wp.pos, altitude)\n            if wpdata.v[wpN] ~= nil then\n                wpdata.v[wpN].pos = newPos\n            else\n                wpdata.v[wpN] = { pos = newPos }\n                P(wpN ..\"  \" .. newPos)\n            end\n        end\n    end\n    if cnt == 0 then\n        P(\"[E] No waypoints processed!\")\n        return nil,nil\n    end\n    P(\"[I] \"..cnt..\" waypoints at \"..altitude..\"m added (or changed)!\")\n    return wpdata, names\nend\n\nlocal function storeYFSData(keyName, data)\n    if not DetectedYFS or not keyName then return false end\n    YFSDB:setData(keyName, data)\n    return true\nend\n\nlocal function getYFSData(keyName)\n    if not DetectedYFS or not keyName then return false end\n    local data = YFSDB:getData(keyName)\n    if data == nil or not IsTable(data.v) then\n        return false\n    end\n    return data\nend\n\nlocal function storeYFSNamedWaypoints(data)\n    storeYFSData(YFS_NAMED_POINTS, data)\nend\n\nlocal function storeYFSRoutes(data)\n    storeYFSData(YFS_ROUTES, data)\nend\n\n\nfunction cmd.FindCenterCmd(text)\n    if not WM or not WM:hasPoints() then\n        return E(\"[E] No waypoints to export.\")\n    end\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n\n    local parts = SU.SplitQuoted(text)\n    if #parts < 1 then\n        return E(\"[E] Parameter(s) missing: routename\\nExample: /findCenter 'Cryo' -onlySelectable\")\n    end\n    local onlySelectable = GetIndex(parts, \"-onlySelectable\") > 0\n    local routename = parts[1]\n    local route = routes.v[routename]\n    if not route or not IsTable(route.points) or #route.points == 0 then\n        return E(\"[E] Route '\"..routename..\"' not found or empty\")\n    end\n\n    local wpdata = cmd.GetYFSNamedWaypoints()\n\n        local pointlist = {}\n    local wpIdx = 1\n    for _,v in ipairs(route.points) do\n        local wppos = \"\"\n        local wpName = \"WP \"..sformat(\"%03d\", wpIdx)\n        if v.waypointRef and wpdata then\n            wpName = v.waypointRef\n            wppos = wpdata.v[wpName].pos\n        else\n            wppos = v.pos\n        end\n\n        if wppos and ((not onlySelectable) or (v.opt[\"selectable\"] ~= false)) then\n            P(\"Using \"..wpName)\n            pointlist[wpIdx] = PM.MapPosToWorldVec3(wppos)\n        end\n        wpIdx = wpIdx + 1\n    end\n    local center = GetCentralPoint(pointlist)\n    if center then\n        local locPos = PM.WorldToMapPos(center)\n        local output = \"[I] Center coords: \"..PM.MapPos2String(locPos)\n        P(output)\n    else\n        P(\"[E] Could not calculate center, sorry!\")\n    end\nend\n\nfunction cmd.GetYFSNamedWaypoints(muteMsg)\n    if not DetectedYFS then\n        return E(\"[E] Linked YFS databank required!\")\n    end\n    local namedWP = getYFSData(YFS_NAMED_POINTS)\n    if not namedWP and not muteMsg then\n        P(\"[I] No named waypoints\")\n    end\n    return namedWP\nend\n\nfunction cmd.GetYFSRoutes()\n    if not DetectedYFS then\n        return E(\"[E] Linked YFS databank required!\")\n    end\n    local data = getYFSData(YFS_ROUTES)\n    if not data then\n        return E('[I] No YFS routes found.')\n    end\n    return data\nend\n\nfunction cmd.PlanetInfoCmd(text)\n    PM.PlanetInfo(text)\nend\n\nfunction cmd.PrintAltitudeCmd(text)\n    P(Out.PrettyDistance(PM.Altitude()))\nend\n\nfunction cmd.PrintPosCmd(text)\n    P(PM.GetCurrentPosString())\nend\n\nfunction cmd.PrintWorldPosCmd(text)\n    P(PM.Vec3ToPosString(PM.WorldPosVec3()))\nend\n\nfunction cmd.WarpCostCmd(text)\n    CalcWarpCost(text)\nend\n\nfunction cmd.WpSaveNamedCmd(text, isYfs)\n    if not WM or not WM:hasPoints() then\n        return E(\"[E] No waypoints to export.\")\n    end\n    local output = \"\"\n    for _,wp in ipairs(WM:getSorted()) do\n        local pos = wp:AsString()\n        if isYfs then\n            pos = \"pos-save-as '\" .. wp:getName() .. \"' -pos '\" .. pos .. \"'\"\n        else\n            pos = \"/addlocation \" .. wp:getName() .. \" \" .. pos\n        end\n        output = output .. pos .. \"\\n\"\n        P(pos)\n    end\n    ScreenOutput(output)\nend\n\nfunction cmd.ArchSaveNamedCmd(text)\n    cmd.WpSaveNamedCmd(text, false)\nend\n\nfunction cmd.WpExportCmd(text)\n    if not WM or not WM:hasPoints() then\n        return E(\"[E] No waypoints to export.\")\n    end\n    local output = \"\"\n    local wplist = WM:getSorted()\n    for _,wp in ipairs(wplist) do\n        local s = wp:getName() .. \"\\n\" .. wp:AsString() .. \"\\n\"\n        output = output .. s\n    end\n    P(output)\n    ScreenOutput(output)\nend\n\nfunction cmd.WpAltitudeCeilingCmd(text)\n    local wpnames = cmd.GetYFSNamedWaypoints()\n    if not wpnames then return end\n\n        local parts = SU.SplitQuoted(text)\n    if #parts ~= 2 then\n        P(\"[E] Parameter(s) missing: 'name 1' 'name 2'\")\n        return E(\"Example: /wp-altitude-ceiling 'Base 1' 'Base 2'\")\n    end\n    local wpName1 = parts[1]\n    local wpName2 = parts[2]\n\n        local wp1found, wp2found = true, true\n    if wpnames.v[wpName1] == nil or wpnames.v[wpName1] == \"\" then\n        P(\"[E] Waypoint '\".. wpName1 ..\"' not found.\")\n        wp1found = false\n    end\n    if wpnames.v[wpName2] == nil or wpnames.v[wpName2] == \"\" then\n        P(\"[E] Waypoint '\".. wpName2 ..\"' not found.\")\n        wp2found = false\n    end\n    if not wp1found or not wp2found then return end\n    if wpnames.v[wpName1] == wpnames.v[wpName2] then\n        return E(\"[E] Parameters invalid (same names).\")\n    end\n\n        local alt1 = PM.GetAltitudeFromPos(wpnames.v[wpName1].pos)\n    local alt2 = PM.GetAltitudeFromPos(wpnames.v[wpName2].pos)\n    if alt1 == alt2 then\n        P(\"[I] Waypoints had same altitude, no changes applied.\")\n        return\n    end\n    local target, targetAlt = \"\", 0\n    if alt1 > alt2 then\n        target = wpName2\n        targetAlt = alt1\n    else\n        target = wpName1\n        targetAlt = alt2\n    end\n    local newPos = PM.ReplaceAltitudeInPos(wpnames.v[target].pos, targetAlt)\n    wpnames.v[target].pos = newPos\n    P(\"[I] Waypoint '\"..target..\"' changed to:\")\n    P(newPos)\n\n        storeYFSNamedWaypoints(wpnames)\n    return true\nend\n\nfunction cmd.GetStoredLocations(points)     if not points or not IsTable(points) then return end\n    for _,p in ipairs(points) do\n        if p.name and p.position and p.position.x and p.position.y and p.position.z then\n            P(\"[I] Location '\".. p.name ..\"' found.\")\n            local pos = '::pos{0,0,'.. p.position.x .. ',' .. p.position.y .. ',' .. p.position.z ..'}'\n            PM.CreateWaypoint(pos, p.name)\n        end\n    end\nend\n\nfunction cmd.YfsAddAltitudeWpCmd(text)\n    local wpdata = cmd.GetYFSNamedWaypoints()\n    if not wpdata or not IsTable(wpdata.v) or TableLen(wpdata.v) == 0 then\n        return E(\"[E] No waypoints.\")\n    end\n\n    local example = \"\\nExample: /yfs-add-altitude-wp -altitude 450 -suffix 'F'\"\n    local args = SU.SplitQuoted(text)\n    local pStart = GetParamValue(args, \"-wpStartsWith\", \"s\")\n    if #args < 1 then\n        return E(\"[E] Parameter missing: -altitude\"..example)\n    end\n    local pAlt = GetParamValue(args, \"-altitude\", \"n\", true)\n    local pSuf = GetParamValue(args, \"-suffix\", \"s\")\n    if not pSuf or pSuf == \"\" then pSuf = \"F\" end\n    if pAlt < -100 or pAlt > 20000 then\n        return E(\"[E] -altitude value out of range (-100 .. 20000)\"..example)\n    end\n\n        local wplist = {}\n    for k in PairsByKeys(wpdata.v) do\n        if not pStart or k:find(pStart) > 0 then\n            table.insert(wplist, k)\n        end\n    end\n    local newData, names = yfsAddAltitudeWaypoints(wpdata, wplist, pAlt, pSuf)\n    if newData ~= nil and names ~= nil then\n        storeYFSNamedWaypoints(newData)\n    end\n    return true\nend\n\nfunction cmd.YfsBuildRouteFromWpCmd(text)\n    local wpdata = cmd.GetYFSNamedWaypoints()\n    if not wpdata or not IsTable(wpdata.v) or TableLen(wpdata.v) == 0 then\n        return E(\"[E] No waypoints.\")\n    end\n\n    local rdata = cmd.GetYFSRoutes()\n    if not rdata or not IsTable(rdata.v) or TableLen(rdata.v) == 0 then\n                rdata = { v = {}, t = \"table\" }\n    else\n    end\n\n    local example = \"\\nExample: /yfs-build-route-from-wp -name 'Route' -altitude 450 -wpStartsWith 'Chr' -suffix 'F'\\n-suffix is optional, default F (Flight)\"\n    local args = SU.SplitQuoted(text)\n    if #args < 1 then\n        return E(\"[E] Parameters missing!\"..example)\n    end\n\n    local pName  = GetParamValue(args, \"-name\", \"s\", true)\n    if not pName then return end\n    local pStart = GetParamValue(args, \"-wpStartsWith\", \"s\")\n    local pAlt   = GetParamValue(args, \"-altitude\", \"n\", true)\n    if not pAlt then return end\n    local pSuf   = GetParamValue(args, \"-prefix\", \"s\")\n    local pMarginL = GetParamValue(args, \"-marginL\", \"n\")\n    local pMarginF = GetParamValue(args, \"-marginF\", \"n\")\n    local pMaxSpeed = GetParamValue(args, \"-maxSpeed\", \"n\")\n    local pFinalSpeedF = GetParamValue(args, \"-finalSpeedF\", \"n\")\n        pMarginL = uclamp(pMarginL or 0.1, 0.1, 100)     pMarginF = uclamp(pMarginF or 0.1, 0.1, 100)     pMaxSpeed = uclamp(pMaxSpeed or 0, 0, 1200)     pFinalSpeedF = uclamp(pFinalSpeedF or 0, 0, 1200)     if rdata.v[pName] ~= nil then\n        return E(\"[E] Route \"..pName..\"already exists, aborting!\")\n    end\n    if type(pSuf) ~= \"string\" or pSuf == \"\" then pSuf = \"F\" end\n    if strlen(pSuf) > 3 then\n        return E(\"[E] -suffix accepts max. 3 characters\"..example)\n    end\n    if pAlt < -600 or pAlt > 20000 then\n        return E(\"[E] -altitude value out of range (-100 .. 20000)\"..example)\n    end\n\n            local wplist = {}\n    for k in PairsByKeys(wpdata.v) do\n        if not pStart or k:find(pStart) > 0 then\n            table.insert(wplist, k)\n        end\n    end\n\n        local wpdata, wplistNew = yfsAddAltitudeWaypoints(wpdata, wplist, pAlt, pSuf)\n    if wpdata == nil or wplistNew == nil then\n        return E(\"[I] No waypoints processed: no changes made.\")\n    end\n\n        rdata.v[pName] = { points = {} }\n\n            local cnt = 0\n    for _,k in ipairs(wplistNew) do\n        local wp = wpdata.v[k]\n        if wp ~= nil then\n                        cnt = cnt + 1\n            local rOpt = { margin = 0.1, maxSpeed = 0 }\n            local rp = { opt = rOpt, pos = wp.pos, waypointRef = k }\n                        if GetIndex(wplist, k) < 1 then\n                                if pFinalSpeedF and pFinalSpeedF > 0 and GetIndex(wplist, k) < 1 then\n                    rp.opt.finalSpeed = pFinalSpeedF\n                end\n                                if pMaxSpeed and pMaxSpeed > 0 then\n                    rp.opt.maxSpeed = pMaxSpeed\n                end\n                                if pMarginF and pMarginF > 0.1 then\n                    rp.opt.margin = pMarginF\n                end\n                rp.opt.selectable = false\n                rp.opt.skippable = false\n            else                                 if pMarginL and pMarginL > 0.1 then\n                    rp.opt.margin = pMarginL\n                end\n                rp.opt.selectable = true\n                rp.opt.skippable = true\n            end\n            table.insert(rdata.v[pName].points, rp)\n        end\n    end\n    P(\"[I] \"..cnt..\" positions added to route '\"..pName..\"'\")\n    storeYFSNamedWaypoints(wpdata)\n    storeYFSRoutes(rdata)\nend\n\nfunction cmd.YfsSaveRouteCmd(text)\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n\n    local parts = SU.SplitQuoted(text)\n    if #parts < 1 then\n        return E(\"[E] Parameter(s) missing: routename\\nExample: /yfs-save-route 'Cryo' -onlySelectable -withOptions -prefix 'Cryo'\")\n    end\n    local wpPrefix = GetParamValue(parts, \"-prefix\", \"s\")\n    if not wpPrefix then wpPrefix = \"WP\" end\n    local onlySelectable = GetIndex(parts, \"-onlySelectable\") > 0\n    local withOptions = GetIndex(parts, \"-withOptions\") > 0\n    local routename = parts[1]\n    local route = routes.v[routename]\n    if not route or not IsTable(route.points) or #route.points == 0 then\n        return E(\"[E] Route '\"..routename..\"' not found or empty\")\n    end\n    local output1, output2 = \"route-create '\"..routename..\"'\\r\\n\", \"\"\n\n    local wpdata = cmd.GetYFSNamedWaypoints()\n\n            local wpIdx = 1\n    local wpNames = {}     for _,v in ipairs(route.points) do\n        local wppos = \"\"\n        local wpName = wpPrefix..\" \"..sformat(\"%03d\", wpIdx)\n        if v.waypointRef and wpdata then\n            wpName = v.waypointRef\n            wppos = wpdata.v[wpName].pos\n        else\n            wppos = v.pos or \"<unknown>\"\n        end\n\n        if GetIndex(wpNames, wpName) < 0 then\n            wpNames[#wpNames + 1] = wpName\n            local tmp = \"pos-save-as '\"..wpName..\"' -pos '\"..wppos..\"'\"\n            output1 = output1 .. tmp .. \"\\n\"\n        end\n        if (not onlySelectable) or (v.opt[\"selectable\"] ~= false) then\n            local tmp = \"route-add-named-pos '\"..wpName..\"'\"\n            if withOptions then\n                                                if v.opt[\"maxSpeed\"] and v.opt[\"maxSpeed\"] ~= 0 then\n                    tmp = tmp..\" -maxspeed \"..v.opt[\"maxSpeed\"]\n                end\n                if v.opt[\"margin\"] and v.opt[\"margin\"] ~= 0.1 then\n                    tmp = tmp..\" -margin \"..v.opt[\"margin\"]\n                end\n                                local routeLvlOptions = false\n                local routeOptStr = \"\"\n                if v.opt[\"skippable\"] == true then\n                    routeLvlOptions = true\n                    routeOptStr = routeOptStr .. \" -toggleSkippable\"\n                end\n                if v.opt[\"selectable\"] == false then\n                    routeLvlOptions = true\n                    routeOptStr = routeOptStr .. \" -toggleSelectable\"\n                end\n                if v.opt[\"finalSpeed\"] and v.opt[\"finalSpeed\"] ~= 0 then\n                    routeLvlOptions = true\n                    routeOptStr = routeOptStr..\" -finalSpeed \"..v.opt[\"finalSpeed\"]\n                end\n                if routeLvlOptions then\n                    tmp = tmp .. \"\\nroute-set-pos-option -ix \"..wpIdx..routeOptStr\n                end\n            end\n            output2 = output2 .. tmp .. \"\\n\"\n            wpIdx = wpIdx + 1\n        end\n    end\n    output2 = output2..\"route-save\\r\\n\"\n    P(output1..output2)\n    ScreenOutput(output1..output2)\nend\n\nfunction cmd.YfsReplaceWpCmd(text)\n    local wpnames = cmd.GetYFSNamedWaypoints()\n    if not wpnames then return end\n\n    local ex = \"\\r\\nExample: /yfs-replace-wp 'base 1'\"\n    local params = SU.SplitQuoted(text)\n    if #params < 1 then\n        return E(\"[E] Parameter(s) missing: -name 'point'\"..ex)\n    end\n\n    local wpName = GetParamValue(params, \"-name\", \"s\", true)\n    if not wpName then return end\n    if not wpnames.v[wpName] or wpnames.v[wpName] == \"\" then\n        return E(\"[E] Waypoint '\".. wpName ..\"' not found.\"..ex)\n    end\n\n    local newPos = PM.GetCurrentPosString()\n    local pPos = GetParamValue(params, \"-pos\", \"s\")\n    if pPos then\n                local tmp = PM.SplitPos(pPos)\n        if not tmp then\n            return E(\"[E] Invalid ::pos{} specified!\")\n        end\n        newPos = pPos\n    end\n\n    wpnames.v[wpName].pos = newPos\n    P(\"[I] Waypoint '\"..wpName..\"' changed to:\")\n    P(newPos)\n\n    storeYFSNamedWaypoints(wpnames)\n    return true\nend\n\nfunction cmd.YfsOptionsResetCmd(text)\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n\n        local example = \"\\nExample:\\n/yfs-options-reset -route 'name' -ix 2 -endIx 3\\nWith -endIx being optional.\"\n    local parts  = SU.SplitQuoted(text)\n    local pName  = GetParamValue(parts, \"-route\", \"s\", true)\n    if not pName then return E(example) end\n    if not routes.v[pName] then\n        return E(\"[E] Route '\"..pName..\"' not found.\"..example)\n    end\n    if not routes.v[pName].points or #routes.v[pName].points == 0 then\n        return E(\"[E] Route '\"..pName..\"' empty.\")\n    end\n\n    local pStart = GetParamValue(parts, \"-ix\", \"i\", true)\n    local pEnd   = GetParamValue(parts, \"-endIx\", \"i\")\n    if not pEnd then pEnd = #routes.v[pName].points end\n    local isError = not pName or not pStart or (pStart < 1) or (pEnd and pEnd < pStart)\n    if isError then\n        return E(\"[E] Wrong number of parameters / invalid values!\"..example)\n    end\n    if not pEnd or pEnd < pStart then pEnd = pStart end\n\n            P(\"[I] Processing route '\"..pName..\"'\")\n    local changed = 0\n    local finalSpeed = 30 / 3.6     for i,v in ipairs(routes.v[pName].points) do\n        if i >= pStart and i <= pEnd then\n            local wpName = v.waypointRef\n            if not wpName then\n                wpName = i             end\n            changed = changed + 1\n                        routes.v[pName].points[i].opt.finalSpeed = finalSpeed\n            routes.v[pName].points[i].opt.maxSpeed = 0\n            routes.v[pName].points[i].opt.margin = 0.1\n            routes.v[pName].points[i].opt.lockDir = nil\n            P(\"[I] Options reset for route waypoint: \"..wpName)\n        end\n    end\n    if changed == 0 then\n        return E(\"[I] No waypoints in route changed.\\n[*] Make sure that start (and end-index) are valid.\")\n    end\n        storeYFSRoutes(routes)\n    P(\"[I] Routes saved.\")\nend\n\nfunction cmd.YfsRouteAltitudeCmd(text)\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n\n    local namedWP = cmd.GetYFSNamedWaypoints()\n    \n        local example = \"\\nExample:\\n/yfs-route-altitude -route 'name' -ix 2 -endIx 3 -alt 330\\nThe -endIx is optional.\"\n    local parts  = SU.SplitQuoted(text)\n    local pName  = GetParamValue(parts, \"-route\", \"s\", true)\n    if not pName then return end\n    if not routes.v[pName] then\n        return E(\"[E] Route '\"..pName..\"' not found.\"..example)\n    end\n    if not routes.v[pName].points or #routes.v[pName].points == 0 then\n        return E(\"[E] Route '\"..pName..\"' empty.\")\n    end\n\n    local pStart = GetParamValue(parts, \"-ix\", \"i\", true)\n    local pEnd   = GetParamValue(parts, \"-endIx\", \"i\")\n    local pAlt   = GetParamValue(parts, \"-alt\", \"n\", true)\n    if not pEnd then pEnd = #routes.v[pName].points end\n\n    local isError = not pName or not pStart or not pAlt or (pStart < 1) or (pEnd and pEnd < pStart) or (pAlt < -100) or (pAlt > 10000)\n    if isError then\n        return E(\"[E] Wrong number of parameters / invalid values!\"..example)\n    end\n    if not pEnd or pEnd < pStart then pEnd = pStart end\n\n            P(\"[I] Processing route '\"..pName..\"'\")\n    local changed = 0\n    local wpnames = {}\n    for i,v in ipairs(routes.v[pName].points) do\n        if i >= pStart and i <= pEnd then\n            local newPos = \"\"\n            local wpName = v.waypointRef\n            if wpName and namedWP and namedWP.v and namedWP.v[wpName] then\n                local wp = namedWP.v[wpName]\n                if GetIndex(wpnames, wpName) < 1 then\n                    table.insert(wpnames, wpName)\n                end\n                newPos = PM.ReplaceAltitudeInPos(wp.pos, pAlt)\n            else                 wpName = i\n                newPos = PM.ReplaceAltitudeInPos(v.pos, pAlt)\n            end\n            changed = changed + 1\n            routes.v[pName].points[i].pos = newPos\n            P(\"[I] Route Waypoint '\"..wpName..\"' changed to:\\n\"..newPos)\n        end\n    end\n    if changed == 0 then\n        return E(\"[I] No waypoints in route changed.\\n[*] Make sure that start (and end-index) are valid.\")\n    end\n        storeYFSRoutes(routes)\n    P(\"[I] Routes saved.\")\n\n        changed = 0\n    for _,entry in ipairs(wpnames) do\n        if namedWP and namedWP.v[entry] then\n            changed = changed + 1\n            local newPos = PM.ReplaceAltitudeInPos(namedWP.v[entry].pos, pAlt)\n            namedWP.v[entry].pos = newPos\n            P(\"[I] Named Waypoint '\"..entry..\"' changed to:\")\n            P(newPos)\n        else\n            P(\"[E] '\"..entry..\"' not found!\")\n        end\n    end\n        if changed > 0 then\n        storeYFSNamedWaypoints(namedWP)\n        P(\"[I] Named waypoints saved.\")\n    end\nend\n\nfunction cmd.YfsWpAltitudeCmd(text)\n        local wpnames = cmd.GetYFSNamedWaypoints()\n    if not wpnames then return E(\"[E] No named waypoints.\") end\n\n        local parts = SU.SplitQuoted(text)\n    if #parts ~= 2 then\n        return E(\"[E] Wrong number of parameters!\\nExample: /yfs-wp-altitude 'Base 1' 324.12\")\n    end\n    local pName = parts[1] or \"\"\n\n        if not pName or not parts[2] or not wpnames.v[pName] or wpnames.v[pName] == \"\" then\n         return E(\"[E] Waypoint '\".. pName ..\"' not found\")\n    end\n\n        local pAlt = tonum(parts[2] or 0)\n    local newPos = PM.ReplaceAltitudeInPos(wpnames.v[pName].pos, pAlt)\n    wpnames.v[pName].pos = newPos\n    P(\"[I] Waypoint '\"..pName..\"' changed to:\")\n    P(newPos)\n    P(\"[I] Note: routes' waypoints are updated on route activation, i.e. exporting route data before activation may still show old value!\")\n\n        storeYFSNamedWaypoints(wpnames)\n    return true\nend\n\nfunction cmd.YfsRouteNearestCmd(text)\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n        local params = SU.SplitQuoted(text)\n    if #params == 0 or #params > 2 then\n        P(\"[E] Wrong parameter count\\n[I] Example: /yfs-route-nearest 'Route 1'\")\n        P(\"\\nOptional parameter:\\n\")\n        P(\"-onlySelectable -> only show closest, selectable waypoints in route\")\n        return false\n    end\n        local routeName = params[1]\n    local route = routes.v[routeName]\n    if not route or not IsTable(route.points) then\n        return E(\"[E] Route '\" .. routeName ..\"' not found or empty\")\n    end\n    P(\"[I] Route '\"..routeName..\"' found.\")\n        local onlySelectable = GetIndex(params, \"-onlySelectable\") > 0\n\n        local wplist = cmd.GetYFSNamedWaypoints(true)\n    local idx = 0\n    local closestDist = 999999999\n    local sDist, sNearest = \"\", \"\"\n    local res =  {}\n    for k,v in ipairs(route.points) do\n        idx = idx + 1\n        if (not onlySelectable) or (v.opt and v.opt.selectable ~= false) then\n            local wpname = SU.Trim(sformat(\"%02d\", idx) .. \": '\"..(v.waypointRef or \"\")..\"'\")\n            local pos = v.pos\n            if v.waypointRef and wplist then\n                pos = wplist.v[v.waypointRef].pos\n            end\n            local dist = PM.GetDistance(pos)\n            if dist > 0.1 then\n                route.points[k].distance = dist\n                sDist = wpname .. \" = \" .. sformat(\"%.4f\", dist)\n                if dist < closestDist then\n                    sNearest = sDist\n                    closestDist = dist\n                end\n                local tmpDist = tostring(math.modf(dist * 10000))\n                local key = ('0'):rep(12-#tmpDist)..tmpDist\n                res[key] = idx\n            end\n        end\n    end\n    if not idx then return E(\"[I] No selectable waypoints found.\") end\n    local output = \"Route-Idx / Name / Distance (m)\\n\"\n    for _,key in pairs(GetSortedAssocKeys(res)) do\n        local routeIdx = res[key]\n        local wpName = route.points[routeIdx].waypointRef or routeIdx\n        local wpDist = route.points[routeIdx].distance\n        output = output .. sformat(\"%02d\", routeIdx)..\" / '\"..wpName..\"' / \"\n        output = output .. Out.PrettyDistance(wpDist)..\"\\n\"\n    end\n    output = output .. \"\\n[I] Nearest waypoint: \"..sNearest\n\n    Out.PrintLines(output)\n    ScreenOutput(output)\nend\n\nfunction cmd.YfsRouteToNamedCmd(text)\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n        local params = SU.SplitQuoted(text)\n    if #params == 0 or #params > 6 then\n        P(\"[E] Wrong parameter count\\n[I] Example: /yfs-route-to-named 'Route 1'\\nOptional parameters:\\n\")\n        P(\"-onlySelectable -> only write waypoints marked as selectable in route\")\n        P(\"-prefix Myprefix -> if unspecified, 'WP' is default\")\n        P(\"-toScreen -> output JSON of list to optional screen if linked\")\n        P(\"-toDB -> only if this is given, the changed list will be written to DB to avoid miscalls\")\n        P(\"Important: command aborts if ANY waypoint's name starts with given prefix to avoid errors!\")\n        return false\n    end\n        local routeName = params[1]\n    local route = routes.v[routeName]\n    if not route or not IsTable(route.points) then\n        return E(\"[E] Route '\" .. routeName ..\"' not found or empty\")\n    end\n    P(\"[I] Route '\"..routeName..\"' found.\")\n        local toDB = GetIndex(params, \"-toDB\") > 0\n    local toScreen = GetIndex(params, \"-toScreen\") > 0\n    local onlySelectable = GetIndex(params, \"-onlySelectable\") > 0\n    local wpPrefix = GetParamValue(params, \"-prefix\", \"s\")\n    if not wpPrefix then wpPrefix = \"WP\" end\n\n        local wplist = cmd.GetYFSNamedWaypoints(true)\n    if not wplist or not wplist.v then\n        wplist = { v = { } }\n    else\n                for k,_ in pairs(wplist.v) do\n            if string.find(k, wpPrefix) == 1 then\n                return E(\"[!] Waypoints with same prefix already exist!\\n[!] Command aborted.\")\n            end\n        end\n    end\n    local idx = 0\n    for _,v in ipairs(route.points) do\n        if (not onlySelectable) or (v.opt and v.opt.selectable ~= false) then\n            idx = idx + 1\n            local wpname = wpPrefix .. \" \" .. sformat(\"%02d\", idx)\n            local wp = { pos = v.pos, opt = v.opt}\n                        wplist.v[wpname] = wp\n            P(wpname ..\"  \" .. v.pos)\n        end\n    end\n    if not idx then return E(\"[I] No changes to waypoints done\") end\n\n        if toDB then\n        storeYFSNamedWaypoints(wplist)\n        P(\"[I] Waypoint changes saved to databank!\")\n    else\n        P(\"[I] -toDB not present, no changes saved to databank!\")\n    end\n    if toScreen then\n        ScreenOutput(json.encode(wplist.v))\n    end\nend\n\nfunction cmd.YFSLoadNamedWaypoints()\n    local wpnames = cmd.GetYFSNamedWaypoints()\n    if not wpnames then return end\n    for k,v in pairs(wpnames.v) do\n        PM.CreateWaypoint(v.pos, k)\n    end\nend\n\nfunction cmd.YFSLoadRoutepoints(onlySelectableWP, onlyWpForRoute)\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return false end\n    P('[I] Processing routes...')\n    for k,v in pairs(routes.v) do\n        if (onlyWpForRoute == \"\" or onlyWpForRoute == k) and IsTable(v) then\n            for k2,v2 in ipairs(v.points) do\n                if (not onlySelectableWP) or (v2.opt[\"selectable\"] ~= false) then\n                    local wpName = k .. \" \" .. k2\n                    if v2.waypointRef then\n                        wpName = v2.waypointRef\n                    end\n                    PM.CreateWaypoint(v2[\"pos\"], wpName)\n                end\n            end\n            P(\"[I] Route '\"..k..\"' read.\")\n        end\n    end\n    return true\nend\n\nfunction cmd.YfsSaveNamedCmd(text)\n    cmd.WpSaveNamedCmd(text, true)\nend\n\nfunction cmd.PosDataCmd()\n        P(\"getCameraHorizontalFov: \"..system.getCameraHorizontalFov())\n    P(\"getCameraVerticalFov: \"..system.getCameraVerticalFov())\n\n    P(\"getCameraPos: \"..PM.Vec3String(system.getCameraPos()))\n    P(\"getCameraForward: \"..PM.Vec3String(system.getCameraForward()))\n    P(\"getCameraRight: \"..PM.Vec3String(system.getCameraRight()))\n    P(\"getCameraUp: \"..PM.Vec3String(system.getCameraUp()))\n\n    P(\"getCameraWorldPos: \"..PM.Vec3String(system.getCameraWorldPos()))\n    P(\"getCameraWorldForward: \"..PM.Vec3String(system.getCameraWorldForward()))\n    P(\"getCameraWorldRight: \"..PM.Vec3String(system.getCameraWorldRight()))\n    P(\"getCameraWorldUp: \"..PM.Vec3String(system.getCameraWorldUp()))\n\n    P(\"construct.getWorldPosition: \"..PM.Vec3String(construct.getWorldPosition(CNID)))\n    P(\"construct.getOrientationForward: \"..PM.Vec3String(construct.getOrientationForward()))\n    P(\"construct.getOrientationRight: \"..PM.Vec3String(construct.getOrientationRight()))\n    P(\"construct.getOrientationUp: \"..PM.Vec3String(construct.getOrientationUp()))\nend\n\nfunction cmd.DumpPointsCmd()\n    if true then\n        P(\"~=~=~=~=~=~=~= DUMP START ~=~=~=~=~=~=\")\n        local tmp = Out.DumpVar(WM:getWaypointsInst())\n        P(tmp)\n        return ScreenOutput((tmp or \"[I] No waypoints.\"),\"\\n~=~=~=~=~=~=~= DUMP END ~=~=~=~=~=~=~=\")\n    end\n\nend\n\nfunction cmd.DumpRoutesCmd()\n    if not DetectedYFS then return E(\"[I] No YFS databank.\") end\n    P(\"~=~=~=~=~=~=~= ROUTES DUMP START ~=~=~=~=~=~=\")\n    local tmp = YFSDB:getString(YFS_ROUTES)\n    P(tmp)\n    ScreenOutput((tmp or \"[I] No routes.\"),\"\\n~=~=~=~=~=~=~= ROUTES DUMP END ~=~=~=~=~=~=~=\")\nend\n\nfunction cmd.RoutesCmd()\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n    P(\"[I] Available routes:\")\n    for k,_ in pairs(routes.v) do\n        P(k)\n    end\nend\n\n\nfunction cmd.YfsTestDataCmd(param)\n    if not (param == \"TESTING\") then return end\n    P(\"[*] Creating YFS test data...\")\n\n    YFSDB:remove(YFS_NAMED_POINTS)\n    local data = { }\n    data[\"Chr 01\"] = { pos = \"::pos{0,7,-20.7784,-153.7402,360.5184}\", opt = {} }\n    data[\"Chr 02\"] = { pos = \"::pos{0,7,-21.3610,-152.3447,345.8787}\", opt = {} }\n    data[\"Chr 03\"] = { pos = \"::pos{0,7,-23.0540,-152.8934,360.6677}\", opt = {} }\n    data[\"Chr 04\"] = { pos = \"::pos{0,7,-22.4445,-154.3119,320.1029}\", opt = {} }\n    data[\"Chr 05\"] = { pos = \"::pos{0,7,-20.5370,-154.7507,308.0151}\", opt = {} }\n    data[\"Chr 06\"] = { pos = \"::pos{0,7,-21.6295,-155.1465,292.7660}\", opt = {} }\n    data[\"Chr Hub\"] = { pos = \"::pos{0,7,-21.9903,-153.1008,391.4632}\", opt = {} }\n    local tmp = { v = data, t = type(data) }\n    storeYFSNamedWaypoints(tmp)\n\n    YFSDB:remove(YFS_ROUTES)\n    local r = { }\n            storeYFSRoutes({ v = r, t = type(r) })\n\n    P(\"[*] YFS test data saved!\")\n    cmd.DumpPointsCmd()\n    cmd.DumpRoutesCmd()\nend\n\nfunction cmd.ConversionTestCmd(param)\n    PM.ConversionTest()\nend\n\nfunction cmd.XCmd()\n            end\n\nreturn cmd\nend)\npackage.preload['YFS-Tools:help.lua']=(function()\nlocal help = {}\n\nfunction help.PrintHelpCmd()\n    local hlp = \"~~~~~~~~~~~~~~~~~~~~\\nYFS-Tools Commands:\\n~~~~~~~~~~~~~~~~~~~~\\n\"..\n    \"/arch-save-named\\n-> Builds list of chat commands for ArchHud to add locations for all named waypoints.\\n\"..\n    \"/findCenter\\n-> Calculates center between all points of a route, like for a central hub.\\n\"..\n    \"/planetInfo (id or name)\\n-> Info about current planet or for passed planet id or name, e.g. 2 for Alioth).\\n\"..\n    \"/printAltitude /printPos /printWorldPos\\n-> Prints info data.\\n\"..\n    \"/warpCost -from name/::pos{}/planets -to name/::pos{}/planets -mass tons -moons\\n-> Flexible warp cell calculator.\\n\"..\n    \"/wp-altitude-ceiling\\n-> Changes a waypoint to have the higher altitude of both.\\n\"..\n    \"/wp-export\\n-> Outputs list of plain waypoints to chat and an optional screen. Source can include ArchHud locations, too, if databank linked.\\n\"..\n    \"/yfs-add-altitude-wp\\n-> Adds waypoints for each existing WP at a specified altitude and name suffix.\\n\"..\n    \"/yfs-build-route-from-wp\\n-> Powerful route-building command based on existing named waypoints.\\n\"..\n    \"/yfs-options-reset\\n-> Reset options of route waypoints for a specific route.\\n\"..\n    \"/yfs-replace-wp 'name'\\n-> Replaces a named waypoint with the current location.\\n\"..\n    \"/yfs-route-altitude\\n-> Changes altitude for a range of waypoints of a specific YFS route.\\n\"..\n    \"/yfs-route-nearest\\n-> Show list of route waypoints by distance from current location.\\n\"..\n    \"/yfs-route-to-named\\n-> Converts a route's *unnamed* waypoints to named waypoints for YFS.\\n\"..\n    \"/yfs-save-named\\n-> Builds list of YFS commands to recreate all named waypoints.\\n\"..\n    \"/yfs-save-route\\n-> Builds list of YFS commands to recreate full route incl. named waypoints and their options.\\n\"..\n    \"/yfs-wp-altitude\\n-> Changes altitude of a named waypoint to specified altitude.\\n\"..\n    \"=========================================\\n\"..\n    \"Important: Enclose names (as parameters) in single quotes if they contain blanks!\\n\"..\n    \"*** DO NOT USE COMMANDS THAT CHANGE POINTS ***\\n*** OR ROUTES WHILE YFS IS RUNNING! ***\\n\"\n    ScreenOutput(hlp)\n    P(hlp)\nend\n\nreturn help\nend)\npackage.preload['YFS-Tools:warpcost.lua']=(function()\nlocal strmatch, sformat, strlen = string.match, string.format, string.len\nlocal tonum, uclamp, mabs, max, floor, ceil = tonumber, utils.clamp, math.abs, math.max, math.floor, math.ceil\n\n\nfunction CalcWarpCost(text)\n    local example = \"\\nExample 1:\\n/warpCost -from Madis -to Alioth -mass 534\"..\n        \"\\nExample 2:\\n/warpCost -from Alioth -to planets -moons\"..\n        \"\\nOptional '-from x' with x being either 'here', a planet name, ::pos{} or 'planets' (multi-result).\"..\n        \"\\nOptional '-to x' like -from, but for end location.\"..\n        \"\\nOptional '-mass x' with x the total mass in tons. If not given, the current constructs' total mass is used.\"..\n        \"\\nOptional '-cargo x' with x the cargo mass in tons. If specified, a cell count for a return trip is calculated, too.\"..\n        \"\\nOptional '-moons' only together with 'planets' to also include moons in the list.\"..\n        \"\\n- One of -from or -to can be left out, then the current construct's location (or planet) is used.\"..\n        \"\\n- If construct is landed on a planet or moon, the Atlas specified warp altitude is the starting point.\"..\n        \"\\n- Enclose names in single-quotes if they contain spaces!\"\n    local getCMass = construct.getMass\n    local pOn, onPlanet = {}, false\n    local s, s2 = \"~~~ WARP CELL CALCULATOR ~~~\", \"\"\n\n    local function checkParam(args, pName, isFrom)\n        local v, allPlanets, offs = {}, false, 0\n        local par = GetParamValue(args, pName, \"s\")\n        if not par or (par == \"\") or (par == \"here\") then\n            v = PM.WorldPosVec3()             if onPlanet and pOn then\n                offs = 2 * pOn.radius\n                par = pOn.name[1]\n                v = vec3(pOn.center)\n            else\n                offs = 12                 par = PM.Vec3ToPosString(v)\n            end\n        elseif par == \"planets\" then\n            allPlanets = true\n        elseif par > \"\" then\n            if SU.StartsWith(par, \"::pos{\") then\n                offs = 12                 v = PM.MapPosToWorldVec3(par)\n            else\n                local p = PM.PlanetByName(par)\n                if p then\n                    offs = 2 * p.radius\n                    v = vec3(p.center)\n                end\n            end\n        end\n        return { parm = par, v = v, isP = allPlanets, offset = offs }\n    end\n\n    local args = SU.SplitQuoted(text)\n    if #args < 1 then return E(\"[E] Parameter(s) missing!\"..example) end\n    local pMoons = GetIndex(args, \"-moons\") > 0\n\n            local offset = 0\n    pOn = PM.GetClosestPlanet(PM.WorldPosVec3())\n    if pOn then\n        offset = 2 * pOn.radius         onPlanet = PM.Altitude() < offset\n        if onPlanet then\n            s2 = \"Current\"\n        else\n            s2 = \"Nearest\"\n        end\n        s = s..\"\\n\"..s2..\" planet: \"..pOn.name[1]\n    else\n        s = s..\"\\n[I] No planet nearby!\"\n    end\n\n        local maxMass = 50000\n        local tons = getCMass(CNID) / 1000 \n        local pCargo, bCargo = 0, false\n    if GetIndex(args, \"-cargo\") > 0 then\n        local tmpCargo = GetParamValue(args, \"-cargo\", \"n\")\n        tmpCargo = tmpCargo or 0\n        if tmpCargo > 0 then\n            pCargo = uclamp(tmpCargo, 0, maxMass)\n            bCargo = pCargo > 0\n        else\n            return E(s..\"\\n[E] Invalid -cargo value, must be in range of 1-50000 tons!\")\n        end\n    end\n\n    local pMass = GetParamValue(args, \"-mass\", \"n\")\n    s2 = \"Mass: \"\n    if pMass then\n        tons = tonum(pMass)\n    else\n        s2 = \"Construct \"..s2\n    end\n    s = s..\"\\n\"..s2..Out.PrettyMass(tons*1000)\n    if bCargo then\n        s = s..\"  ~*~  Cargo: \"..Out.PrettyMass(pCargo*1000)\n    end\n    if tons < 100 then         return E(s..\"\\n[E] Impossibly low mass for a warp ship! ;)\")\n    elseif tons > maxMass then\n        return E(s..\"\\n[E] I don't accept you're warping that heavy! ;)\")\n    end\n\n    local locFrom = checkParam(args, \"-from\", true)\n    if not locFrom.isP and not locFrom.v then\n        return E(s..\"\\n[E] Invalid starting location!\")\n    end\n    local locTo = checkParam(args, \"-to\", false)\n    if not locTo.isP and not locTo.v then\n        return E(s..\"\\n[E] Invalid end location!\")\n    end\n\n    if locFrom.isP and locTo.isP then\n        return E(s..\"\\n[E] Only one 'planets' option supported!\")\n    end\n    if (locFrom.parm == locTo.parm) or (locFrom.v == locTo.v) then\n        return E(s..\"\\n[E] Start and end locations must be different!\")\n    end\n\n    local function process(from, to, distance, massT, cargo)\n        local out = \"\"\n        if from > \"\" then out = out .. from end\n        if from > \"\" and to > \"\" then out = out .. \" to \" end\n        if to > \"\" then out = out .. to end\n        out = out.. \" (\"..Out.PrettyDistance(distance)..\")\"\n\n                if distance < 200000 then\n            return out..\" -> too short!\"\n        elseif distance > 100000000 then\n            return out..\" -> too far!\"\n        end\n        local cnt = PM.ComputeCells(distance, massT)\n        out = out..\" = \"..cnt..\" cell\" .. SU.If(cnt > 1, \"s\")\n        if bCargo then\n            local cnt2 = PM.ComputeCells(distance, massT - cargo)\n            out = out..\" / \"..cnt2..\" cell\" .. SU.If(cnt > 1, \"s\")..\" = \"..(cnt+cnt2)..\" total\"\n        end\n        return out\n    end\n\n        if not locFrom.isP and not locTo.isP then\n        local distance = mabs(vec3(locFrom.v - locTo.v):len()) - locFrom.offset - locTo.offset\n        local res = process(locFrom.parm, locTo.parm, distance, tons, pCargo)\n        if type(res) == \"string\" then\n            s = s .. \"\\n\" .. res\n            P(s)\n            ScreenOutput(s)\n        else\n            E(\"[E] Sorry, something went wrong :(\")\n        end\n        return\n    end\n\n        local v1, v2 = nil, nil\n    s2 = \" (Distance) / Cells\"..SU.If(bCargo, \" / Return w/o cargo\")\n    if locFrom.isP then\n        s = s..\"\\nTo: \"..locTo.parm..\"\\nFrom\"..s2\n    else\n        s = s..\"\\nFrom: \"..locFrom.parm..\"\\nTo\"..s2\n    end\n    for _,v in pairs(WaypointInfo[0]) do\n        if not v.isAsteroid and (pMoons or not v.isMoon) then\n            offset = 2 * v.radius\n            if locFrom.isP then\n                locFrom.parm = v.name[1]\n                locFrom.v = v.centerV3\n                offset = offset + locTo.offset\n            else\n                locTo.parm = v.name[1]\n                locTo.v = v.centerV3\n                offset = offset + locFrom.offset\n            end\n            local distance = mabs(vec3(locFrom.v - locTo.v):len()) - offset\n            if distance > 100000 then\n                s = s .. \"\\n\" ..\n                    process(SU.If(locFrom.isP, locFrom.parm),\n                            SU.If(locTo.isP, locTo.parm),\n                            distance, tons, pCargo)\n            end\n        end\n    end\n    P(s)\n    ScreenOutput(s)\nend\nend)\npackage.preload['YFS-Tools:../util/wpoint.lua']=(function()\nlocal tonum, strlen, strmatch = tonumber, string.len, string.match\n\nWaypoint = { mapPos = {}, name = \"\", parent = nil }\n\nWaypoint.new = function(parent)\n    local obj = setmetatable(\n        { parent = parent, name = \"\",\n          mapPos = { systemId = 0, id = 0, latitude = 0.0, longitude = 0.0, altitude = 0.0 } },\n        { __index = Waypoint }\n    )\n    return obj\nend\n\nWaypoint.get = function(self)\n    return self.mapPos\nend\n\nWaypoint.getPosPattern = function()\n    local num = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\n    return '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' .. num ..  ',' .. num .. '}'\nend\n\nWaypoint.set = function(self, newMapPos)\n    if type(newMapPos) == \"string\" and strlen(newMapPos) < 16 then\n        print(\"[E] Invalid position: \"..newMapPos)\n        return {}\n    end\n\n    if type(newMapPos) == \"string\" then\n        local s, p, x, y, z = strmatch(newMapPos, self.getPosPattern())\n        if s then\n            self.mapPos.systemId = tonum(s)\n            self.mapPos.id = tonum(p)\n            self.mapPos.latitude = tonum(x)\n            self.mapPos.longitude = tonum(y)\n            self.mapPos.altitude = tonum(z)\n        else\n            print(newMapPos..\" - Invalid string format. Use '::pos{s, p, x, y, z}'.\")\n        end\n    elseif type(newMapPos) == \"table\" and #newMapPos == 3 then\n        self.mapPos.latitude = tonum(newMapPos[1])\n        self.mapPos.longitude = tonum(newMapPos[2])\n        self.mapPos.altitude = tonum(newMapPos[3])\n    elseif type(newMapPos) == \"table\" and #newMapPos == 5 then\n        self.mapPos.systemId = tonum(newMapPos[1])\n        self.mapPos.id = tonum(newMapPos[2])\n        self.mapPos.latitude = tonum(newMapPos[3])\n        self.mapPos.longitude = tonum(newMapPos[4])\n        self.mapPos.altitude = tonum(newMapPos[5])\n    elseif type(newMapPos) == \"table\" and newMapPos.x and newMapPos.y and newMapPos.z then\n        self.mapPos.systemId = 0\n        self.mapPos.id = 0\n        self.mapPos.latitude = tonum(newMapPos.x)\n        self.mapPos.longitude = tonum(newMapPos.y)\n        self.mapPos.altitude = tonum(newMapPos.z)\n    else\n        print(\"Invalid input. Provide a ::pos{} string, vec3() or {s,p,x,y,z} table.\")\n    end\n    return self\nend\n\nWaypoint.setName = function(self, newName)\n    if newName == nil then self.name = \"\" return end\n    if type(newName) == \"string\" and newName:gmatch(\"^%a[%w_- ]*$\") then\n        self.name = newName\n    else\n        print(tostring(newName)..\"\\n[E] WP: Invalid name format. Should only contain printable characters.\")\n    end\n    return self\nend\n\nWaypoint.getName = function(self)\n    return self.name\nend\n\nWaypoint.getAltitude = function(self)\n    return self.mapPos.altitude\nend\n\nWaypoint.AsString = function(self)\n    return string.format(\"::pos{%d, %d, %.4f, %.4f, %.4f}\",\n                         self.mapPos.systemId, self.mapPos.id,\n                         self.mapPos.latitude, self.mapPos.longitude, self.mapPos.altitude)\nend\n\nWaypoint.__Waypoint = function(self) return true end\nend)\npackage.preload['YFS-Tools:../util/wpointmgr.lua']=(function()\nlocal tonum, strlen, strmatch = tonumber, string.len, string.match\n\n\nWaypointMgr = { name = \"\", waypoints = {} }\n\nWaypointMgr.add = function(self, waypoint, index)\n    if waypoint.__Waypoint and waypoint.__Waypoint() then\n                if waypoint.name and waypoint.name ~= \"\" then\n                        for _,v in ipairs(self.waypoints) do\n                if v.name == waypoint.name then\n                    return nil\n                end\n            end\n        end\n        local wplus1 = 1 + #self.waypoints\n        if index then\n                        if index < 1 or index > wplus1 then\n                print(\"[E] Invalid index. Must be in the range 1 to \" .. wplus1)\n                return nil\n            end\n            waypoint.parent = self\n            table.insert(self.waypoints, index, waypoint)\n        else\n            waypoint.parent = self\n            table.insert(self.waypoints, wplus1, waypoint)\n        end\n        return waypoint\n    else\n        print(\"[E] Invalid waypoint parameter!\")\n        return nil\n    end\nend\n\nWaypointMgr.getWaypointsData = function(self)\n    local res = {}\n    for k,v in ipairs(self.waypoints) do\n        table.insert(res, k, v:get())\n    end\n    return res\nend\n\nWaypointMgr.getWaypointsInst = function(self)\n    return self.waypoints\nend\n\nWaypointMgr.getCount = function(self)\n    return #self.waypoints\nend\n\nWaypointMgr.getSorted = function(self)\n    local sortedPoints = {}\n\n        for _,v in pairs(self.waypoints) do\n        table.insert(sortedPoints, v)\n    end\n\n        table.sort(sortedPoints, function(a, b)\n        return a.name < b.name\n    end)\n    return sortedPoints\nend\n\nWaypointMgr.moveUp = function(self, index)\n    local waypointsCount = #self.waypoints\n\n    if index and index > 1 and index <= waypointsCount then\n        self.waypoints[index], self.waypoints[index - 1] = self.waypoints[index - 1], self.waypoints[index]\n    end\nend\n\nWaypointMgr.moveDown = function(self, index)\n    local waypointsCount = #self.waypoints\n\n    if index and index >= 1 and index < waypointsCount then\n        self.waypoints[index], self.waypoints[index + 1] = self.waypoints[index + 1], self.waypoints[index]\n    end\nend\n\nWaypointMgr.removeByName = function(self, waypointName)\n    for i, waypoint in ipairs(self.waypoints) do\n        if waypoint.name == waypointName then\n            local removedWaypoint = table.remove(self.waypoints, i)\n            return removedWaypoint          end\n    end\n    return nil  end\n\nWaypointMgr.hasPoints = function(self, param)\n    return #self.waypoints > 0\nend\n\nWaypointMgr.exists = function(self, param)\n    for _, v in ipairs(self.waypoints) do\n        if type(param) == \"string\" and v.name == param then\n            return v\n        elseif param and param.__Waypoint and Waypoint.__Waypoint() then\n            if v == param then\n                return v\n            end\n        elseif type(param) == \"table\" and #param == 5 then\n                        if v.mapPos.systemId  == tonum(param[1]) and\n               v.mapPos.id        == tonum(param[2]) and\n               v.mapPos.latitude  == tonum(param[3]) and\n               v.mapPos.longitude == tonum(param[4]) and\n               v.mapPos.altitude  == tonum(param[5]) then\n                return v\n            end\n        end\n    end\n    return nil\nend\n\nWaypointMgr.getName = function(self)\n    return self.name\nend\n\nWaypointMgr.new = function(name)\n    local obj = setmetatable(\n        { waypoints = {}, name = name or \"\" },\n        { __index = WaypointMgr }\n    )\n    return obj\nend\n\nreturn WaypointMgr\nend)\npackage.preload['YFS-Tools:../util/stl.lua']=(function()\nlocal function mkPrint(str)\nreturn 'print(\\'' .. str:gsub('\\'', '\\\\\\''):gsub('\\n', '\\\\n') .. '\\')'\nend\n\nlocal function tMerge(...)\nlocal tables = {...}\nlocal result = {}\nfor _, t in pairs(tables) do\n    for k, v in pairs(t) do\n    result[k] = v\n    end\nend\nreturn result\nend\n\nlocal function getLine(str, ln)\nlocal _ = 0\nfor s in str:gmatch(\"([^\\n]*)\\n?\") do\n    _ = _ + 1\n    if _ == ln then\n    return s\n    end\nend\nreturn nil\nend\n\nlocal function trim(str)\nreturn str:gsub(\"^%s*(.-)%s*$\", \"%1\")\nend\n\nlocal Template = {\nglobals = {\n    math = math,\n    table = table,\n    string = string,\n    ipairs = ipairs,\n    pairs = pairs,\n}\n}\n\nfunction Template.__call(self, ...)\nreturn Template.render(self, ({...})[1])\nend\n\nfunction Template:render(vars)\nif type(vars or {}) ~= 'table' then\n    error('Template parameters must be a table, got ' .. type(vars))\nend\n\nlocal _ = {}\n\nlocal env = tMerge(Template.globals, self.globals or {}, vars or {}, {\n    print = function (str) table.insert(_, tostring(str or '')) end,\n})\n\nself.callable(env)\n\nlocal result = table.concat(_, ''):gsub('%s+', ' ')\n\nresult = result:sub(result:find('[^%s]') or 1):gsub('%s*$', '')\n\nreturn result\nend\n\nfunction Template.new(source, globals, buildErrorHandler)\nlocal self = {\n    source = source,\n    globals = globals,\n}\n\nlocal yield = (coroutine and coroutine.isyieldable() and coroutine.yield) or function () end\n\nsource = source:gsub('{{(.-)}}', '{%% print(%1) %%}')\n\nsource = source:gsub('\\n%s*{%%', '{%%')\nsource = source:gsub('%%}\\n', '%%}')\n\nlocal tPieces = {}\n\nwhile #source > 0 do\n        local iLuaStart = source:find('{%%')\n\n        local iLuaEnd = source:find('%%}')\n\n        if iLuaStart then\n        if not iLuaEnd then\n        error('Template error, missing Lua closing tag near: ' .. source:sub(0, 16))\n    end\n\n        local currentText = source:sub(1, iLuaStart - 1)\n    if #currentText then\n        table.insert(tPieces, mkPrint(currentText))\n    end\n\n        local luaTagContent = source:sub(iLuaStart, iLuaEnd + 1):match('{%%(.-)%%}') or ''\n    table.insert(tPieces, luaTagContent)\n\n        source = source:sub(iLuaEnd + 2)\n    else\n        table.insert(tPieces, mkPrint(source))\n\n        source = ''\n    end\n\n        yield()\nend\n\nself.code = table.concat(tPieces, '\\n')\n\nlocal lua = string.format('return function (_) _ENV = _; _ = _ENV[_]\\n%s\\nend', self.code)\nlocal _, err = load(lua, nil, 't', {})\nif _ and not err then\n    _ = _()\nend\n\nif err then\n    local _, ln, msg = err:match('^(.-):(%d+):(.+)')\n    local nearSrc = getLine(self.source, ln - 1)\n    local nearLua = getLine(self.code, ln - 1)\n\n    local ex = {\n    raw = err,\n    line = ln - 1,\n    near = trim(nearSrc or 'N/A'),\n    nearLua = trim(nearLua or 'N/A'),\n    message = trim(msg),\n    }\n\n    if buildErrorHandler then\n    buildErrorHandler(self, ex)\n    else\n    error(('Failed compiling template!\\nError: %s\\nLine: %d\\nNear: %s\\nCode: %s'):format(ex.message, ex.line, ex.near, ex.nearLua))\n    end\n\n        return nil\nelse\n        self.callable = _\nend\n\nreturn setmetatable(self, Template)\nend\n\nreturn Template.new\nend)\npackage.preload['YFS-Tools:../util/wolfeCentralpoint.lua']=(function()\nlocal msqrt = math.sqrt\n\nfunction GetCentralPoint(waypoints, useCentroid)\n    if type(waypoints) ~= \"table\" or #waypoints == 0 then return nil end\n    if #waypoints == 1 then\n              return waypoints[1]\n    elseif #waypoints == 2 then\n                return (vec3(waypoints[1]) + vec3(waypoints[2])) / 2\n    end\n\n        local base_weight = 1 / #waypoints\n\n        local centroid = vec3(0, 0, 0)\n    for _, waypoint in pairs(waypoints) do\n        centroid = centroid + vec3(waypoint) * base_weight\n    end\n\n        local center = centroid\n\n            \n        if not useCentroid then\n                local avg_distance = 0\n        for _, waypoint in pairs(waypoints) do\n            avg_distance = avg_distance + base_weight * (vec3(waypoint) - center):len() ^ msqrt(2)\n        end\n\n                local center_accumulator = vec3(0, 0, 0)\n        for _, waypoint in pairs(waypoints) do\n            local point = vec3(waypoint)\n            local distance = (point - center):len() ^ msqrt(2)\n            local weight = distance / avg_distance\n            center_accumulator = center_accumulator + point * base_weight * weight\n        end\n\n                center = center_accumulator\n    end\n\n    return center\nend\nend)\npackage.preload['YFS-Tools:libmain.lua']=(function()\nSU = require('YFS-Tools:../util/SU.lua') Out = require('YFS-Tools:../util/out.lua') P = Out.PrintLines\nE = Out.Error\n\nrequire('YFS-Tools:../util/Dtbk.lua') \nrequire('YFS-Tools:libutils.lua') Cmd = require('YFS-Tools:commands.lua') Help = require('YFS-Tools:help.lua') \nrequire('YFS-Tools:warpcost.lua') \nrequire('YFS-Tools:../util/wpoint.lua') WM = require('YFS-Tools:../util/wpointmgr.lua').new(\"MAIN\") \nWaypointInfo = require('atlas')\n\nSTL = require('YFS-Tools:../util/stl.lua') require('YFS-Tools:../util/wolfeCentralpoint.lua') --     WolfeCenterPointRS = 'vec2 = vec2 or require(\\'cpml.vec2\\')\\nvec3 = vec3 or require(\\'cpml.vec3\\')\\n\\n--------------------------------------\\n-- Configuration\\n--------------------------------------\\n\\n-- Pulls upstream config\\nlocal config = data.config or {}\\n\\n-- How large each dot is\\nlocal dot_size = 2\\n\\n-- How many meters from center to screen edge\\nlocal screen_radius = config.screen_radius or 3000\\n\\n-- The grid circles\\nlocal grid_size = config.grid_size or 500\\n\\n-- Colors to be used\\nlocal colors = {\\n  background = { 0.1, 0.1, 0.1 },\\n  overlay = { 0, 0, 0, 0.5 },\\n  guides = {\\n    main = { 0, 0.5, 1.5, 0.2 },\\n    secondary = { 0, 0.5, 1.5, 0.15 },\\n  },\\n  center = { 0, 2, 1 },\\n  points = { 0, 2, 2 },\\n  messages = { 0.6, 0.6, 0.6 },\\n}\\n\\n-- Spacing\\nlocal spacing = { 8, 8 }\\n\\n-- Font to be used\\nlocal fonts = {\\n  title = loadFont(\\'Oxanium\\', 30),\\n  main = loadFont(\\'Oxanium\\', 24),\\n  sub = loadFont(\\'Oxanium\\', 15),\\n}\\n\\n--------------------------------------\\n-- Helpers\\n--------------------------------------\\n\\nlocal screen_width, screen_height = getResolution()\\nlocal cursor = vec2(getCursor())\\n\\n-- How close to detect hover\\nlocal proximity_distance = 0.02 * screen_height\\n\\n-- Helper function to convert color tables\\nlocal function rgba(color)\\n  return color[1], color[2], color[3], color[4] or 1\\nend\\n\\n-- Draws a small dot\\nlocal function draw_dot(layer, x, y, color, hover_handler, click_handler)\\n  setNextFillColor(layer, rgba(color))\\n  addCircle(layer, x, y, dot_size)\\n\\n  local is_hovering = (vec2(x, y) - cursor):len() <= proximity_distance\\n\\n  if hover_handler and is_hovering then\\n    hover_handler()\\n  end\\n\\n  if click_handler and is_hovering and getCursorReleased() then\\n    click_handler()\\n  end\\nend\\n\\n-- Draws a circle\\nlocal function draw_circle(layer, x, y, radius, color)\\n  setNextStrokeWidth(layer, 1)\\n  setNextStrokeColor(layer, rgba(color))\\n  setNextFillColor(layer, rgba({ 0, 0, 0, 0 }))\\n  addCircle(layer, x, y, radius)\\nend\\n\\n-- Draws line\\nlocal function draw_line(layer, x1, y1, x2, y2, color)\\n  setNextStrokeColor(layer, rgba(color))\\n  addLine(layer, x1, y1, x2, y2)\\nend\\n\\n-- Draws an overlay\\nlocal function draw_overlay(layer)\\n  setNextFillColor(layer, rgba(colors.overlay))\\n  addBox(layer, 0, 0, screen_width, screen_height)\\nend\\n\\n-- Draws info box\\nlocal function draw_info_box(layer, x, y, title, rows, color)\\n  draw_line(layer, x, y, x + 150, y, color)\\n\\n  if title then\\n    setNextFillColor(layer, rgba(color))\\n    setNextTextAlign(layer, AlignH_Left, AlignV_Bottom)\\n    addText(layer, fonts.sub, tostring(title), x + spacing[1], y - spacing[1])\\n  end\\n\\n  local next_x = x + spacing[1]\\n  local next_y = y + spacing[2]\\n  for _, row in pairs(rows) do\\n    local text = row\\n    local font = fonts.main\\n    if \\'table\\' == type(row) then\\n      font = fonts[row[1]]\\n      text = row[2]\\n    end\\n    local font_size = getFontSize(font)\\n\\n    setNextFillColor(layer, rgba(color))\\n    setNextTextAlign(layer, AlignH_Left, AlignV_Top)\\n    addText(layer, font, tostring(text), next_x, next_y)\\n    next_y = next_y + font_size\\n  end\\nend\\n\\n-- Draws cursor\\nlocal function draw_cursor(layer)\\n  local cursor_size = 16\\n  local x, y = cursor:unpack()\\n\\n  if x and y and x + y > 0 then\\n    setNextShadow(layer, 0.25 * cursor_size, 0, 0, 0, 1)\\n    setNextFillColor(layer, 1, 1, 1, 1)\\n    addQuad(\\n      layer,\\n      x, y,\\n      x + cursor_size, y + 0.5 * cursor_size,\\n      x + 0.5 * cursor_size, y + 0.5 * cursor_size,\\n      x + 0.5 * cursor_size, y + cursor_size\\n    )\\n  end\\nend\\n\\n--------------------------------------\\n-- Main render logic\\n--------------------------------------\\n\\nsetBackgroundColor(rgba(colors.background))\\n\\n-- Pre-calculate center of screen\\nlocal screen_center_x, screen_center_y = 0.5 * screen_width, 0.5 * screen_height\\n\\n-- Check if we have data\\nif not data.is_activated then\\n  -- Offline mode\\n  local layer = createLayer()\\n\\n  setNextTextAlign(layer, AlignH_Center, AlignV_Bottom)\\n  setNextFillColor(layer, rgba(colors.messages))\\n  addText(layer, fonts.title, \\'SCRIPT OFFLINE\\', screen_center_x, screen_center_y - 0.5 * spacing[2])\\n\\n  setNextTextAlign(layer, AlignH_Center, AlignV_Top)\\n  setNextFillColor(layer, rgba(colors.messages))\\n  addText(layer, fonts.sub, \\'activate programming board to start\\', screen_center_x, screen_center_y + 0.5 * spacing[2])\\nelseif not data.waypoints then\\n  -- Waiting on input\\n  local layer = createLayer()\\n\\n  setNextTextAlign(layer, AlignH_Center, AlignV_Bottom)\\n  setNextFillColor(layer, rgba(colors.messages))\\n  addText(layer, fonts.title, \\'AWAITING INPUT\\', screen_center_x, screen_center_y - 0.5 * spacing[2])\\n\\n  setNextTextAlign(layer, AlignH_Center, AlignV_Top)\\n  setNextFillColor(layer, rgba(colors.messages))\\n  addText(layer, fonts.sub, \\'input your first coordinate in the Lua chat to start\\', screen_center_x, screen_center_y + 0.5 * spacing[2])\\nelse\\n  -- Normal operation\\n  local center_body, center_world = data.center.body, vec3(data.center.world)\\n\\n  -- Intializes render script\\n  local layer_background, layer_data, layer_overlay, layer_info, layer_cursor = createLayer(), createLayer(), createLayer(), createLayer(), createLayer()\\n\\n  -- Cursor\\n  draw_cursor(layer_cursor)\\n\\n  -- Half screen size\\n  local screen_radius_pixels = screen_center_y\\n\\n  -- Renders guides\\n  for radius = grid_size, screen_radius, grid_size do\\n    local pixel_radius = screen_radius_pixels * radius / screen_radius\\n    local color = colors.guides.secondary\\n    if radius % 1000 == 0 then\\n      color = colors.guides.main\\n    end\\n\\n    draw_circle(layer_background, screen_center_x, screen_center_y, pixel_radius, color)\\n\\n    setNextFillColor(layer_background, rgba(color))\\n    setNextTextAlign(layer_background, AlignH_Center, AlignV_Top)\\n    addText(layer_background, fonts.sub, radius .. \\'m\\', screen_center_x, screen_center_y + pixel_radius + 0.5 * spacing[2])\\n  end\\n\\n  -- Renders center dot\\n  draw_dot(layer_data, screen_center_x, screen_center_y, colors.center, function()\\n    draw_circle(layer_info, screen_center_x, screen_center_y, proximity_distance, colors.center)\\n    draw_overlay(layer_overlay)\\n    draw_info_box(layer_info, screen_center_x + proximity_distance, screen_center_y, nil, {\\n      \\'center point\\',\\n      { \\'sub\\', \\'click to set waypoint\\' },\\n    }, colors.center)\\n  end, function()\\n    -- Sets waypoint on click\\n    setOutput((\\'{%s,%s,%s}\\'):format(center_world:unpack()))\\n  end)\\n\\n  -- Renders waypoints\\n  for _, waypoint in pairs(data.waypoints or {}) do\\n    local lat, lng = waypoint.body.lat - center_body.lat, waypoint.body.lng - center_body.lng\\n\\n    local offset = vec2(lng, lat * -1)\\n    local distance = (vec3(waypoint.world) - center_world):len()\\n\\n    -- Don\\'t render anything outside screen\\n    if distance <= screen_radius then\\n      -- Calculates pixel position\\n      local pixel = vec2(0.5 * screen_width, 0.5 * screen_height) + offset:normalize() * screen_radius_pixels * distance / screen_radius\\n\\n      -- Draws point on \"map\"\\n      draw_dot(layer_data, pixel.x, pixel.y, colors.points, function()\\n        -- Draws extra info on hover\\n        draw_circle(layer_info, pixel.x, pixel.y, proximity_distance, colors.points)\\n        draw_overlay(layer_overlay)\\n        draw_info_box(layer_info, pixel.x + proximity_distance, pixel.y, waypoint.label, {\\n          (\\'%.2fm\\'):format(distance),\\n          { \\'sub\\', \\'click to set waypoint\\' },\\n        }, colors.points)\\n      end, function()\\n        -- Sets waypoint on click\\n        setOutput((\\'{%s,%s,%s}\\'):format(vec3(waypoint.world):unpack()))\\n      end)\\n    end\\n  end\\n\\n  requestAnimationFrame(1)\\nend'\n\nWolfAR = nil\nend)\npackage.preload['YFS-Tools:../util/pos.lua']=(function()\nlocal max, min, mcos, macos, mdeg, msin, mabs, mrad, matan, ceil, floor, mpi = math.max, math.min, math.cos, math.acos, math.deg, math.sin, math.abs, math.rad, math.atan, math.ceil, math.floor, math.pi\nlocal tonum, strlen, strmatch, sformat = tonumber, string.len, string.match, string.format\nlocal uclamp, vec3 = utils.clamp, vec3\n\nlocal o = {}\no.__index = o\nfunction o.New(pCore, pConstruct, pWM)\n        local s = {\n        core = pCore,\n        construct = pConstruct,\n        Alioth1G = 9.891,\n        waypointNames = {},\n        waypointCount = 0,\n        planetNames = {},\n        p = {},         pIdx = 0,         wm = pWM     }\n\n    local function float_eq(a, b)         if a == 0 then\n            return mabs(b) < 1e-09\n        elseif b == 0 then\n            return mabs(a) < 1e-09\n        else\n            return mabs(a - b) < math.max(mabs(a), mabs(b)) * epsilon\n        end\n    end\n\n        local function constructPresent()\n        return s.construct ~= nil\n    end\n\n        local function corePresent()\n        return s.core ~= nil\n    end\n\n    \n        function o.ComputeCells(distance, tons)\n        return ceil(max(floor(tons*floor(((distance/1000)/200))*0.00024), 1))\n    end\n\n        function o.GetPosPattern()\n        local num = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\n        return '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' .. num ..  ',' .. num .. '}'\n    end\n\n        function o.GetWaypointCount()\n        return s.wm:getCount()\n    end\n\n            function o.SplitPos(posStr)\n                if type(posStr) ~= \"string\" then\n            P(\"[E] Invalid position: \"..type(posStr))\n            return nil\n        end\n        if strlen(posStr) < 16 or not strmatch(posStr, \"^::pos{\") then\n            P(\"[E] Invalid position: \"..posStr)\n            return nil\n        end\n        local sysId, pId, lat, lng, alt = strmatch(posStr, o.GetPosPattern())\n        return { systemId  = tonum(sysId),\n                 id        = tonum(pId),\n                 latitude  = tonum(lat),\n                 longitude = tonum(lng),\n                 altitude  = tonum(alt) }\n    end\n\n            function o.GetAltitudeFromPos(posString)\n        local p = o.SplitPos(posStr)\n        if p and p.altitude then return p.altitude end\n        return 0\n    end\n\n            function o.GetPlanetFromPos(posStr)\n        local p = o.SplitPos(posStr)\n        if p and p.id and p.id > 0 then return p.id end\n        return 0\n    end\n\n    function o.GetAtlasPlanet(pid)\n        if not pid or not WaypointInfo[0] or not WaypointInfo[0][tonum(pid)] then\n            return nil\n        end\n        return WaypointInfo[0][tonum(pid)]\n    end\n\n    function o.GetClosestPlanetId(worldPosVec)\n        local pIdx, dist = 0, 0\n        local planetDistance = math.huge\n        for i,v in pairs(WaypointInfo[0]) do\n            dist = (worldPosVec - vec3(v.center)):len()\n            if dist < planetDistance then\n                planetDistance = dist\n                pIdx = i\n            end\n        end\n        return pIdx\n    end\n\n    function o.GetClosestPlanet(worldPosVec)\n        local pid = o.GetClosestPlanetId(worldPosVec)\n        return o.GetAtlasPlanet(pid)\n    end\n\n    function o.GetCurrentPosString()\n        local v = o.WorldPosVec3()\n        return o.MapPos2String(o.WorldToMapPos(v))\n    end\n\n            function o.MapPos2String(mapPos)\n        if type(mapPos) ~= \"table\" then return \"\" end\n        return '::pos{' .. (mapPos.systemId or 0).. ',' .. (mapPos.id or 0) .. ',' ..\n               sformat(\"%.4f\", (mapPos.latitude or 0)) .. ',' ..\n               sformat(\"%.4f\", (mapPos.longitude or 0)) ..  ',' ..\n               sformat(\"%.4f\", (mapPos.altitude or 0)) .. '}'\n    end\n\n            function o.Vec3ToPosString(v3)\n        if type(v3) ~= \"table\" then return \"\" end\n        return '::pos{0,0,' ..\n               sformat(\"%.4f\", (v3.x or 0)) .. ',' ..\n               sformat(\"%.4f\", (v3.y or 0)) ..  ',' ..\n               sformat(\"%.4f\", (v3.z or 0)) .. '}'\n    end\n\n            function o.Vec3String(v3)\n        if type(v3) ~= \"table\" then return \"\" end\n        v3 = vec3(v3)\n        return sformat(\"%.4f\", (v3.x or 0)) .. ', ' ..\n               sformat(\"%.4f\", (v3.y or 0)) .. ', ' ..\n               sformat(\"%.4f\", (v3.z or 0))\n    end\n\n                function o.ReplaceAltitudeInPos(posStr, newAltitude)\n                local p = o.SplitPos(posStr)\n        if not p or not p.altitude or not newAltitude then\n            return posStr\n        end\n        p.altitude = tonum(newAltitude)\n        return o.MapPos2String(p)\n    end\n\n            function o.PlanetId()\n        if not corePresent() then return 0 end\n        if not INGAME then\n            return 2         end\n        return s.core.getCurrentPlanetId()\n    end\n\n            function o.WorldPosVec3()\n        if not INGAME then\n            return { x = -25140.37011013, y = 100812.26194182, z = -52412.710373821}\n        end\n        if constructPresent() then\n                        return vec3(construct.getWorldPosition())\n        end\n        if corePresent() then\n                        return vec3(core.getWorldPosition())\n        end\n        return nil\n    end\n\n            function o.Altitude()\n        local p = o.GetAtlasPlanet(o.PlanetId())\n        if not p or not p.center then return 0 end\n        return (o.WorldPosVec3() - vec3(p.center)):len() - (p.radius or 0)\n    end\n\n                                    function o.GetDistance(posStr, distToStr)\n        local curPos = o.WorldPosVec3()\n        if type(distToStr) == \"string\" then\n            curPos = o.MapPosToWorldVec3(distToStr)\n        elseif type(distToStr) == \"table\" then\n            curPos = vec3(distToStr)\n        end\n        local wPos = o.MapPosToWorldVec3(posStr)\n        local dist = vec3(wPos - curPos):len()\n        return dist\n    end\n\n            function o.World2local(x,y,z)\n                local cWOUP = s.construct.getWorldOrientationUp()\n        local cWOF = s.construct.getWorldOrientationForward()\n        local cWOR = s.construct.getWorldOrientationRight()\n        local cWOUPx, cWOUPy, cWOUPz = cWOUP[1], cWOUP[2], cWOUP[3]\n        local cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]\n        local cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]\n\n        local v = library.systemResolution3(\n            {cWORx,  cWORy, cWORz},\n            {cWOFx,  cWOFy, cWOFz},\n            {cWOUPx, cWOUPy, cWOUPz},\n            {x, y, z})\n        return v[1],v[2],v[3]\n    end\n\n                                function o.WorldPosFromBody(celestial_body, latitude, longitude, altitude)\n        if type(celestial_body) ~= \"table\" then return nil end\n        local radius = altitude + (celestial_body.radius or 0)\n        local phi, theta = mrad(latitude), mrad(longitude)\n        local pcos = mcos(phi)\n        local offset = vec3(pcos * mcos(theta), pcos * msin(theta), msin(phi))\n                return vec3(celestial_body.center) + offset * radius\n    end\n\n                    function o.BodyPosFromWorldPos(body, position)\n                local offset = position - vec3(body.center)\n        local offset_normalized = offset:normalize()\n\n        return {\n            systemId  = body.systemId,\n            id        = body.id,\n            latitude  = 90 - (macos(offset_normalized.z) * 180 / mpi),\n            longitude = matan(offset_normalized.y, offset_normalized.x) / mpi * 180,\n            altitude  = offset:len() - body.radius\n        }\n    end\n\n            function o.WorldToMapPos(v)\n        local body = o.GetClosestPlanet(v)\n        if not body or not body.center or not body.radius then\n            return { systemId = 0, id = 0, latitude = v.x, longitude = v.y, altitude = v.z }\n        end\n        return o.BodyPosFromWorldPos(body, v)\n    end\n\n    function o.PlanetByName(name)\n        if type(name) ~= \"string\" or name == \"\" then return nil end\n        name = name:lower()\n        if s.planetNames[name] then\n            local pid = tonum(s.planetNames[name])\n            return WaypointInfo[0][pid]\n        end\n        return nil\n    end\n\n                function o.MapPosToWorldVec3(posStr)\n        local p = o.SplitPos(posStr)\n        if not p or not p.systemId then return nil end\n        if (p.systemId == 0 and p.id == 0) then             return vec3(p.latitude, p.longitude, p.altitude)\n        end\n        if not WaypointInfo[p.systemId] then return nil end\n        local planet = WaypointInfo[p.systemId][p.id]\n                        local lat = 0.0174532925199 * max(min(p.latitude, 90), -90)\n        local lon = 0.0174532925199 * (p.longitude % 360)\n        local xproj = mcos(lat)\n        local planetxyz = vec3(xproj*mcos(lon), xproj*msin(lon), msin(lat))\n        return vec3(planet.center) + (planet.radius + p.altitude) * planetxyz\n    end\n\n    function o.PlanetInfo(id)\n        local pid = nil\n        if type(id) == \"string\" and id:len() == 0 then\n            id = o.GetClosestPlanetId(o.WorldPosVec3())\n        end\n        if type(id) == \"string\" and s.planetNames[id:lower()] then             pid = tonum(s.planetNames[id:lower()])\n        elseif type(id) == \"string\" and tonum(id) > 0 then             pid = tonum(id)\n        end\n        if pid == nil then\n            return E(\"[E] No valid planet name or id specified!\")\n        end\n        local p = o.GetAtlasPlanet(pid)\n        if not p or type(p.name) ~= \"table\" then\n            return E(\"[E] No planet found!\")\n        end\n        P\"~~~~~~~~ PLANET INFO ~~~~~~~~\"\n        if id == '' then\n          P(\"Hint: '/planetInfo 2' for Alioth\")\n        end\n        P(\"Name: \"..p.name[1]..\" (Id: \".. p.id ..\")\")\n        P(\"Center: \"..p.center[1]..\" / \"..p.center[2]..\" / \"..p.center[3])\n        P(\"Radius: \"..(p.radius or 0)..\"m\")\n        local tmp = \"\"\n        if p.gravity and p.gravity > 0 then\n            tmp = \" (\"..sformat(\"%.1f\", (p.gravity / s.Alioth1G)) ..\" g)\"\n        end\n        P(\"Gravity: \"..(p.gravity or 0)..tmp)\n        if p.satellites and #p.satellites > 0 then\n          P(\"Has Moons: \"..#p.satellites)\n        end\n        P(\"Surface Min Alt.: \"..(p.surfaceMinAltitude or 0)..\"m\")\n        P(\"Surface Max Alt.: \"..(p.surfaceMaxAltitude or 0)..\"m\")\n        P(\"Max Static Alt.: \"..(p.maxStaticAltitude or \"\")..\"m\")\n        P(\"Has atmosphere: \"..BoolStr(p.hasAtmosphere))\n        if p.hasAtmosphere then\n          P(\"Atmo Thickness: \"..(p.atmosphereThickness or 0)..\"m\")\n          P(\"Atmo altitude: \"..(p.atmoAltitude or 0)..\"m\")\n          P(\"Atmo 10%: \"..(p.atmo10 or 0)..\"m\")\n        end\n        P(\"Is in Safe Zone: \"..BoolStr(p.isInSafeZone))\n        P\"~~~~~~~~~~~~~~~~~~~~~~~~~~~\"\n    end\n\n                                function o.CreateWaypoint(posString, wpName)\n        if not s.wm or not wpName or wpName == '' or s.waypointNames[wpName] then\n            return false\n        end\n\n                local p = o.SplitPos(posString)\n        if not p or not p.systemId then return false end\n\n                if p.id == 0 then\n            local w = o.WorldToMapPos(vec3{ p.latitude, p.longitude, p.altitude })\n            if w and w.id and w.id > 0 then\n                                p.latitude  = w.latitude\n                p.longitude = w.longitude\n                p.altitude  = w.altitude\n                p.id        = w.id\n                p.systemId  = w.systemId\n                posString = o.MapPos2String(p)\n            end\n        end\n\n                local wp = Waypoint:new(s.wm):setName(wpName):set(posString)\n        if not wp or wp == {} then return false end\n        if s.wm:exists(wp) then return false end\n        return s.wm:add(wp)\n    end\n\n        function o.ConversionTest()\n        local p1 = \"::pos{0,2,35.5118,104.0375,285.3076}\"\n        local w1 = o.MapPosToWorldVec3(p1)\n        P(\"HQ local to world:\\n\"..p1..\" =\")\n        P(o.Vec3ToPosString(w1))\n        local w2 = o.WorldToMapPos(w1)\n        Out.DeepPrint(w2)\n        P(\"World to local (should show same as above):\")\n        P(o.MapPos2String(w2))\n\n        local wp = \"::pos{0,0,-24955.2183,99771.5731,-52908.1353}\"\n        if o.CreateWaypoint(wp, \"WorldPos\") then\n          P(\"Added 'WorldPos' waypoint\")\n        else\n          P(\"Failed to add test waypoint!\")\n        end\n    end\n\n    local function init()\n        s.pIdx = 0\n        s.p = o.GetAtlasPlanet(o.PlanetId())\n        if s.p then s.pIdx = s.p.id end\n        if not WaypointInfo[0] then return end\n        s.planetNames = {}\n        for i, v in pairs(WaypointInfo[0]) do\n            s.planetNames[v.name[1]:lower()] = i\n                        WaypointInfo[0][i].biosphere = nil\n            WaypointInfo[0][i].classification = nil\n            WaypointInfo[0][i].description = nil\n            WaypointInfo[0][i].habitability = nil\n            WaypointInfo[0][i].ores = nil\n                        WaypointInfo[0][i].centerV3 = vec3(WaypointInfo[0][i].center)\n            if v.hasAtmosphere then\n                local res = v.atmosphereRadius - v.radius\n                WaypointInfo[0][i].atmoAltitude = res\n                WaypointInfo[0][i].atmo10 = res * 0.9\n            end\n            WaypointInfo[0][i].isAsteroid = WaypointInfo[0][i].type[1] == \"Asteroid\"\n            WaypointInfo[0][i].isMoon = WaypointInfo[0][i].type[1] == \"Moon\"\n            WaypointInfo[0][i].isPlanet = WaypointInfo[0][i].type[1] == \"Planet\"\n        end\n\n        if s.wm then\n            P(\"[I] WaypointMgr assigned: \"..s.wm:getName())\n        else\n            P(\"[E] NO WaypointMgr assigned!\")\n        end\n    end\n\n    init()\n    return setmetatable(s, o)\nend \nreturn o\nend)\npackage.preload['YFS-Tools:startup.lua']=(function()\nlocal uclamp = utils.clamp\n\nlocal onlyForRoute=\"\"--export: Load waypoints only for this route (enclosed in double quotes!); default \"\".\nlocal onlySelectableWP=true--export: Check to only display custom route waypoints that are marked as selectable\nlocal loadWaypoints=true--export: Enable to load custom waypoints from databank\nlocal outputFont=\"FiraMono\"--export: Name of font used for screen output. Default: \"FiraMono\"\n\nonlyForRoute = onlyForRoute or \"\"\nOutputFont = outputFont or \"FiraMono\" \n\nP(\"=========================================\")\nP(\"YFS-Tools 1.7.7 (unofficial)\")\nP(\"created by tobitege (c) 2023\")\nP(\"Thanks to Yoarii (SVEA) for YFS and LUA help!\")\nP(\"YFS 1.4+ databank link required (Routes).\")\nP(\"=========================================\")\nP(\"* WARNING: do not run commands that change\")\nP(\"* waypoints/routes while YFS is running!\")\nP(\"=========================================\")\nP(\"LUA parameter(s):\")\nP(\"Load waypoints from databank: \" .. BoolStr(loadWaypoints))\nP(\"Only waypoints for route: \" .. onlyForRoute)\nP(\"Only selectable waypoints: \" .. BoolStr(onlySelectableWP))\nP(\"Screen output font name: \" .. OutputFont)\nP(\"=========================================\")\n\nlocal status, err = false, nil\nif INGAME then\n    status, err, _ = xpcall(function()\n        Config.core = library.getCoreUnit()\n        Config.databanks = library.getLinksByClass('DataBank', true)         Config.screens = library.getLinksByClass('Screen', true)\n    end, Traceback)\n    if not status then\n        P(\"Error in Link Detection:\\n\" .. err)\n        unit.exit()\n        return\n    end\nelse\n        Config.core = unit.core\n    Config.databanks =  { unit.databank }\n    Config.screens =  { unit.screen }\nend\n\nif Config.core == nil then\n    P(\"[E] No Core connected! Ending script.\")\n    unit.exit()\n    return\nend\n\nPM = require('YFS-Tools:../util/pos.lua').New(Config.core, construct, WM) \nif #Config.databanks > 0 then\n    local plural = \"\"\n    if #Config.databanks > 1 then plural = \"s\" else plural = \" '\"..Config.databanks[1].getName()..\"'\" end\n    P(#Config.databanks .. \" databank\" .. plural .. \" connected.\")\nelse\n    P(\"[E] DataBank not found.\")\nend\n\nif #Config.screens > 0 then\n    local plural = \"\"\n    if #Config.screens > 1 then plural = \"s\" end\n    P(#Config.screens .. \" screen\" .. plural .. \" connected.\")\nend\n\nif loadWaypoints ~= true or #Config.databanks == 0 then\n    P(\"[I] Waypoints loading is off.\")\n    return\nend\n\nif not INGAME then\n    onlyForRoute = \"Garni\"\nend\n\nlocal prevCount = 0\nfor ix=1, #Config.databanks, 1 do\n        local db = Config.databanks[ix]     P(\"===== Checking db '\"..db.getName()..\"' =====\")\n    if db.hasKey(ARCH_SAVED_LOCATIONS) then\n        P('ArchHud databank detected.')\n        DetectedArch = ix\n        local names = db.getStringValue(ARCH_SAVED_LOCATIONS)\n        if names ~= \"\" then\n            P('Searching stored locations...')\n            local locations = json.decode(names)\n            if IsTable(locations) then\n                Cmd.GetStoredLocations(locations)\n            end\n        end\n    end\n    if db.hasKey(YFS_ROUTES) or db.hasKey(YFS_NAMED_POINTS) then\n        P('YFS databank detected.')\n        YFSDB = Dtbk.new(db)\n        DetectedYFS = true\n        if not onlySelectableWP then\n            Cmd.YFSLoadNamedWaypoints()\n        end\n        Cmd.YFSLoadRoutepoints(onlySelectableWP, onlyForRoute)\n    end\n    local count = PM.GetWaypointCount()\n    if count == prevCount then\n        P(\"[I] No waypoints loaded from db \"..ix)\n    else\n        P(\"[I] \"..(count - prevCount)..\" waypoints loaded from db \"..ix)\n    end\n    prevCount = PM.GetWaypointCount()\nend\nP(\"=======================\")\nif PM.GetWaypointCount() > 0 then\n    P(\"[I] Total \"..PM.GetWaypointCount()..\" waypoints loaded.\")\nelse\n    P(\"[I] No waypoints loaded.\")\nend\nP(\"=======================\")\nend)\npackage.preload['YFS-Tools:sys_onInputText.lua']=(function()\nlocal inputTextFunc = {}\n\nfunction inputTextFunc.Run(t)\n    t = SU.Trim(t)\n    if not SU.StartsWith(t, \"/\") then return end\n    if not Cmd then\n        return E(\"[FATAL ERROR] Commands processor not assigned!\")\n    end\n    local cmdList = {}\n    cmdList['arch-save-named'] = 1\n    cmdList['conversionTest'] = 1\n    cmdList['findCenter'] = 1\n    cmdList['posData'] = 1\n    cmdList['help'] = 'Help'\n    cmdList['planetInfo'] = 1\n    cmdList['printAltitude'] = 1\n    cmdList['printPos'] = 1\n    cmdList['printWorldPos'] = 1\n    cmdList['warpCost'] = 1\n    cmdList['wp-altitude-ceiling'] = 1\n    cmdList['wp-export'] = 1\n    cmdList['yfs-add-altitude-wp'] = 1\n    cmdList['yfs-build-route-from-wp'] = 1\n    cmdList['yfs-save-named'] = 1\n    cmdList['yfs-save-route'] = 1\n    cmdList['yfs-replace-wp'] = 1\n    cmdList['yfs-route-altitude'] = 1\n    cmdList['yfs-route-nearest'] = 1\n    cmdList['yfs-options-reset'] = 1\n    cmdList['yfs-route-to-named'] = 1\n    cmdList['yfs-wp-altitude'] = 1\n    cmdList['DumpRoutes'] = 1\n    cmdList['DumpPoints'] = 1\n    cmdList['routes'] = 1\n    if DEBUG then\n        cmdList['YfsTestData'] = 1\n        cmdList['x'] = 1\n    end\n\n    for k, func in pairs(cmdList) do\n        if SU.StartsWith(t, \"/\"..k) then\n            local params = t:sub(k:len()+2) or \"\"\n            params = SU.Trim(params)\n            if k == 'help' then                 k = \"PrintHelp\"\n            end\n                        local fn = SU.SplitAndCapitalize(k,'-')..\"Cmd\"\n                        local cmdName = SU.If(type(func) == \"string\", func, \"Cmd\")\n            P(\"Executing /\"..k..SU.If(params ~= \"\", \" with: \"..params))\n            if not _G[cmdName] then\n                return E(\"[FATAL ERROR] \"..cmdName..\" not found!\")\n            end\n            if _G[cmdName][fn] then\n                return _G[cmdName][fn](params)\n            end\n        end\n    end\n    P(\"~~~~~~~~~~~~~~~~~~~~~\")\n    P(\"[E] Unknown command: \"..t)\n    P(\"[I] Supported commands:\")\n    for _,fn in ipairs(GetSortedAssocKeys(cmdList)) do\n       P(\"/\"..fn)\n    end\nend\n\nreturn inputTextFunc\nend)"},{"key":4,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":"library.addEventHandlers(library)\nlibrary.addEventHandlers(system)\nlibrary.addEventHandlers(player)\nlibrary.addEventHandlers(construct)\nlibrary.addEventHandlers(unit)"},{"key":5,"filter":{"slotKey":-4,"signature":"onActionStart(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionStart',action)"},{"key":6,"filter":{"slotKey":-4,"signature":"onActionLoop(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionLoop',action)"},{"key":7,"filter":{"slotKey":-4,"signature":"onActionStop(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionStop',action)"},{"key":8,"filter":{"slotKey":-4,"signature":"onUpdate()","args":[]},"code":"system:triggerEvent('onUpdate')"},{"key":9,"filter":{"slotKey":-4,"signature":"onFlush()","args":[]},"code":"system:triggerEvent('onFlush')"},{"key":10,"filter":{"slotKey":-4,"signature":"onInputText(text)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onInputText',text)"},{"key":11,"filter":{"slotKey":-4,"signature":"onCameraChanged(mode)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onCameraChanged',mode)"},{"key":12,"filter":{"slotKey":-3,"signature":"onParentChanged(oldId,newId)","args":[{"variable":"*"},{"variable":"*"}]},"code":"player:triggerEvent('onParentChanged',oldId,newId)"},{"key":13,"filter":{"slotKey":-2,"signature":"onDocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onDocked',id)"},{"key":14,"filter":{"slotKey":-2,"signature":"onUndocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onUndocked',id)"},{"key":15,"filter":{"slotKey":-2,"signature":"onPlayerBoarded(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onPlayerBoarded',id)"},{"key":16,"filter":{"slotKey":-2,"signature":"onVRStationEntered(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onVRStationEntered',id)"},{"key":17,"filter":{"slotKey":-2,"signature":"onConstructDocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onConstructDocked',id)"},{"key":18,"filter":{"slotKey":-2,"signature":"onPvPTimer(active)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onPvPTimer',active)"},{"key":19,"filter":{"slotKey":-1,"signature":"onStop()","args":[]},"code":"unit:triggerEvent('onStop')"},{"key":20,"filter":{"slotKey":-1,"signature":"onTimer(timerId)","args":[{"variable":"*"}]},"code":"unit:triggerEvent('onTimer',timerId)"},{"key":21,"filter":{"slotKey":-1,"signature":"onStart()","args":[]},"code":"package.path = \"lua/?.lua;util/wpointer/?.lua;\"..package.path\nrequire('YFS-Tools:globals.lua')\n\n\nWP_WOLF_ENABLED = true\n\nDEBUG = false\nrequire('YFS-Tools:libmain.lua')\n\nif INGAME then\n    local Traceback = traceback\nelse\n    function Traceback(o)\n        if o then P(tostring(o)) end\n    end\n    require 'mockaround'\nend\n\nlocal status, err, _ = xpcall(function() require('YFS-Tools:startup.lua') end, Traceback)\nif not status then\n    P(\"[E] Error in startup!\")\n    if err then P(err) end\n    unit.exit()\n    return\nend\n\nlocal inp = require('YFS-Tools:sys_onInputText.lua')\nif inp ~= nil then\n    system:onEvent('onInputText', function (self, text) inp.Run(text) end)\nend\n\n\n\n\n\nif not WP_EG_ENABLED and not WP_WOLF_ENABLED then\n    P('[I] Waypointer module disabled.')\nelse\n    P('[I] Waypointer module enabled.')\n\n    unit.setTimer(\"update\", 1/120)     system.showScreen(1)\nend\n\nif INGAME then\n    if DEBUGx then\n        status, err, _ = xpcall(function() PM.ConversionTest() end, Traceback)\n        if not status then\n            if err then P(\"[E] Error in test call:\\n\" .. err) end\n            unit.exit()\n            return\n        end\n    else\n        unit.hideWidget()\n    end\n    P(\"Type /help for available commands.\")\n\nend"}],"events":[],"methods":[]}