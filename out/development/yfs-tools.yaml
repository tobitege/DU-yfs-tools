slots:
  "-5":
    name: library
    class: null
    select: null
    type:
      events: []
      methods: []
  "-4":
    name: system
    class: null
    select: null
    type:
      events: []
      methods: []
  "-3":
    name: player
    class: null
    select: null
    type:
      events: []
      methods: []
  "-2":
    name: construct
    class: null
    select: null
    type:
      events: []
      methods: []
  "-1":
    name: unit
    class: null
    select: null
    type:
      events: []
      methods: []
handlers:
  - key: 1
    filter:
      slotKey: -5
      signature: onStart()
      args: []
    code: >-
      ;(function()

      local a={}local b=0;function library.addEventHandlers(c)if not c or c.onEvent and c.triggerEvent then return false end;b=b+1;a[b]=c;local d,e,f='table','function','thread'if d~=type(c)then error('You can only add event handlers to table objects!')end;local g={}local function h(c)local i=type(c)return e==i or d==i and h(getmetatable(c).__call)or f==i end;c.onEvent=function(self,j,k,l)if not h(k)then error('Event handler must be a function, a callable object or a thread!')end;l=l or self;if d~=type(l)then error('The value of self must be a table!')end;if not g[j]then g[j]={_=0}end;local m=f==type(k)and function(...)coroutine.resume(k,...)end or k;local k=g[j]local n=k._+1;k[n]={m,l}k._=n;return n end;c.clearEvent=function(self,j,o)if g[j]and g[j][o]then g[j][o]=nil end end;c.clearAllEvents=function(self)g={}end;c.triggerEvent=function(self,j,...)local p=g[j]if p then for q=1,p._ do local k=p[q]if k then k[1](k[2],...)end end end end;return true end;function library.clearAllEventHandlers()for q=1,b do local c=a[q]if c and c.clearAllEvents then c:clearAllEvents()end end end

      end)()
  - key: 2
    filter:
      slotKey: -5
      signature: onStart()
      args: []
    code: >-
      ;(function()

      local a=DULibrary or{}function a.getLinks(b,c)local d={}if not b then b={}end;for e,f in pairs(unit.getOutPlugs())do local g=unit[f.name]if'table'==type(g)and'function'==type(g.getClass)then local h=true;for i,j in pairs(b)do if not('function'==type(g[i])and j==g[i]():sub(1,#j))then h=false;break end end;if h then if c then table.insert(d,g)else d[f.name]=g end end end end;return d end;function a.getLinksByClass(k,c)return a.getLinks({getClass=k},c)end;function a.getLinkByClass(k)return a.getLinksByClass(k,true)[1]end;function a.getCoreUnit()return a.getLinkByClass('CoreUnit')end;function a.getLinkByName(l)local m=a.getCoreUnit()if not m then error('getLinkByName requires a linked CoreUnit to work')end;local d=a.getLinks()for n,o in pairs(d)do if l==m.getElementNameById(o.getLocalId())then return o end end end

      end)()
  - key: 3
    filter:
      slotKey: -5
      signature: onStart()
      args: []
    code: >-
      package.preload['YFS-Tools:globals.lua']=(function()

      ---@diagnostic disable: lowercase-global

      -- Initialize globals and constants

      Config = { core = nil, databanks = {}, screens = {} }

      DetectedArch = 0

      DetectedYFS = false

      YFSDB = nil

      YFS_NAMED_POINTS = "NamedPoints"

      YFS_ROUTES = "NamedRoutes"

      ARCH_SAVED_LOCATIONS = "SavedLocations"

      DEBUG = false

      ScriptStartTime = 0

      INGAME = system ~= nil


      if not INGAME then


      else
          ScriptStartTime = system.getArkTime()
          print = system.print
      end


      projector = nil

      clicked = false -- for waypointer


      WP_EG_ENABLED = false -- Waypointer by EasternGamer

      WP_WOLF_ENABLED = false -- Waypointer AR by Wolfe Labs


      CNID = construct.getId()

      end)

      package.preload['YFS-Tools:../util/SU.lua']=(function()

      local SU = {}


      local strmatch, strlen, tonum = string.match, string.len, tonumber


      ---@comment Returns s being trimmed of any whitespace from both start and end.

      ---@param s string

      ---@return string

      function SU.Trim(s)
          if strlen(s) == 0 then return "" end
          return SU.Ltrim(SU.Rtrim(s))
      end


      ---@comment Returns s being trimmed of any whitespace from the start.

      ---@param s string

      ---@return string

      function SU.Ltrim(s)
          local res, _ = string.gsub(s, "^%s+", "")
          return res
      end


      ---@comment Returns s being trimmed of any whitespace from the end.

      ---@param s string

      ---@return string

      function SU.Rtrim(s)
          local res, _ = string.gsub(s, "%s+$", "")
          return res
      end


      function SU.Pad(s, padChar, length)
          if not s or not length or not padChar or tonum(length) < 1 then return s end
          return string.rep(padChar, length - s:len()) .. s
      end


      ---@param s string

      ---@param prefix string

      ---@return boolean

      function SU.StartsWith(s, prefix)
          if not s or not prefix then return false end
          return string.sub(s, 1, #prefix) == prefix
      end


      ---@param s string

      ---@param suffix string

      ---@return boolean

      function SU.EndsWith(s, suffix)
          if not s or not suffix then return false end
          return string.sub(s, -#suffix) == suffix
      end


      ---@param s string

      ---@param suffix string

      ---@return string

      function SU.RtrimChar(s,char)
          if not s or not char then return s end
          while #s > 0 and SU.EndsWith(s, char) do
              s = string.sub(s,1,#s - #char)
          end
          return s
      end


      ---Splits the string into parts, honoring " and ' as quote chars to make multi-word arguments

      -- SplitQuoted() credits to Yoarii (SVEA)

      ---@param s string

      ---@return string[]

      function SU.SplitQuoted(s)
          local function isQuote(c) return c == '"' or c == "'" end
          local function isSpace(c) return c == " " end

          local function add(target, v)
              v = SU.Trim(v)
              if v:len() > 0 then
                  table.insert(target, #target + 1, v)
              end
          end

          local inQuote = false
          local parts = {} ---@type string[]
          if type(s) ~= "string" or s == "" then
              return parts
          end

          local current = ""
          for c in string.gmatch(s, ".") do
              if isSpace(c) and not inQuote then
                  -- End of non-quoted part
                  add(parts, current)
                  current = ""
              elseif isQuote(c) then
                  if inQuote then -- End of quote
                      add(parts, current)
                      current = ""
                      inQuote = false
                  else -- End current, start quoted
                      add(parts, current)
                      current = ""
                      inQuote = true
                  end
              else
                  current = current .. c
              end
          end

          -- Add whatever is at the end of the string.
          add(parts, current)

          return parts
      end


      ---@comment Returns trueValue if cond is true, otherwise falseValue. nil's will be checked and returned as empty strings.

      ---@param cond boolean cond should evaluate to true or false

      ---@param trueValue any

      ---@param falseValue any

      ---@return string

      function SU.If(cond, trueValue, falseValue)
          if cond then
              return tostring(trueValue or "")
          end
          return tostring(falseValue or "")
      end


      ---@comment Returns true if char is a printable character

      ---@param char string single character

      ---@return boolean

      function SU.isPrintable(char)
          return strmatch(char, "[%g%s]") ~= nil
      end


      ---@comment Returns true if char is a printable character

      ---@return any Returns the ready string. In case of invalid separator, the original string is returned.

      function SU.SplitAndCapitalize(inputString, delimiter)
          if not inputString or not SU.isPrintable(delimiter) then
              return inputString
          end
          local parts = {}
          for part in inputString:gmatch("[^" .. delimiter .. "]+") do
              table.insert(parts, part)
          end
          for i = 1, #parts do
              parts[i] = parts[i]:sub(1, 1):upper() .. parts[i]:sub(2)
          end
          return table.concat(parts)
      end


      return SU

      end)

      package.preload['YFS-Tools:../util/out.lua']=(function()

      --- functions with chat output

      local o = {}


      function o.PrettyDistance(dist)
          if dist < 10000 then
              return Round(dist,2).." m"
          end
          if dist < 200000 then
              return Round(dist/1000,2).." km"
          end
          return Round(dist/200000,2).." SU"
      end


      ---@param mass number mass in kg

      ---@return string prettyfied mass for display

      function o.PrettyMass(mass)
          if mass > 1000000 then
              return Round(mass / 1000000,2).." KT"
          end
          if mass > 1000 then
              return Round(mass / 1000,2).." tons"
          end
          return Round(mass,2).." kg"
      end


      ---@param s string|any

      function o.PrintLines(s)
          if not s then return end
          if type(s) ~= "string" then s = tostring(s) end
          for str in s:gmatch("([^\n]+)") do
               print(str)
          end
      end


      function o.Error(err)
          o.PrintLines(err)
          return false
      end


      function o.DeepPrint(e, maxItems)
          if IsTable(e) then
              local cnt = 0
              maxItems = maxItems or 0
              for k,v in pairs(e) do
                  if IsTable(v) then
                      P("-> "..k)
                      o.DeepPrint(v, maxItems)
                  elseif type(v) == "boolean" then
                      P(k..": "..BoolStr(v))
                  elseif type(v) == "function" then
                      P(k.."()")
                  elseif v == nil then
                      P(k.." ("..type(v)..")")
                  else
                      P(k..": "..tostring(v))
                  end
                  cnt = cnt + 1
                  if maxItems > 0 and cnt >= maxItems then
                     P("^:^:^:^: cutoff reached :^:^:^:^")
                      return
                  end
              end
          elseif type(e) == "boolean" then
             P(BoolStr(e))
          else
             P(e)
          end
      end


      function o.DumpVar(data)
          -- cache of tables already printed, to avoid infinite recursive loops
          local tablecache = {}
          local buffer = ""
          local padder = "    "
          local function _dumpvar(d, depth)
              local t = type(d)
              local str = tostring(d)
              if (t == "table") then
                  if (tablecache[str]) then
                      -- table already dumped before, so we dont
                      -- dump it again, just mention it
                      buffer = buffer.."<"..str..">\n"
                  else
                      tablecache[str] = (tablecache[str] or 0) + 1
                      buffer = buffer.."("..str..") {\n"
                      for k, v in pairs(d) do
                          buffer = buffer..string.rep(padder, depth+1).."["..k.."] => "
                          _dumpvar(v, depth+1)
                      end
                      buffer = buffer..string.rep(padder, depth).."}\n"
                  end
              elseif (t == "boolean") then
                  buffer = buffer.."("..BoolStr(t)..")\n"
              elseif (t == "number") then
                  buffer = buffer.."("..t..") "..str.."\n"
              else
                  buffer = buffer.."("..t..") \""..str.."\"\n"
              end
          end
          _dumpvar(data, 0)
          return buffer
      end


      return o

      end)

      package.preload['YFS-Tools:../util/Dtbk.lua']=(function()

      -- Dtbk by Jeronimo

      Dtbk = {}

      Dtbk.__index = Dtbk;

      function Dtbk.new(bank)
          local self = setmetatable({}, Dtbk)
          self.DB = bank
          self.concat = table.concat
          return self
      end

      function Dtbk.hasKey(self,tag)
          return self.DB.hasKey(tag)
      end

      function Dtbk.getString(self,tag)
          return self.DB.getStringValue(tag)
      end

      function Dtbk.setString(self,tag,value)
          self.DB.setStringValue(tag,value)
      end

      function Dtbk.setData(self,tag,value)
          local str = json.encode(value)
          self.DB.setStringValue(tag,str)
      end

      function Dtbk.getData(self,tag)
          local tmp = self.DB.getStringValue(tag)
          if tmp == nil then return nil end
          local str = json.decode(tmp)
          return str
      end

      function Dtbk.remove(self,key)
          self.DB.clearValue(key)
      end

      function Dtbk.ResetAll(self)
          self.DB.clear()
      end


      end)

      package.preload['YFS-Tools:libutils.lua']=(function()

      local tonum, strmatch = tonumber, string.match


      function IsTable(obj)
          return obj ~= nil and type(obj) == "table"
      end


      function GetSortedAssocKeys(source)
          local L = {}
          if not IsTable(source) then E("[E] Invalid object for GetSortedKeys()!") return L end
          for k,_ in pairs(source) do
              table.insert(L, k)
          end
          table.sort(L)
          return L
      end


      function Round(num, decimals)
          local mult = 10^(decimals or 0)
          return ((num*mult) + (2^52 + 2^51) - (2^52 + 2^51))/mult
      end


      function TableLen(source)
          if not IsTable(source) then return 0 end
          local cnt = 0
          for _ in pairs(source) do
            cnt = cnt + 1
          end
          return cnt
      end


      function GetIndex(source, value)
          if not IsTable(source) then return -1 end
          for k, v in pairs(source) do
            if value == v then return k end
          end
          return -1
      end


      ---@param srcTable any

      ---@param paramName string

      ---@param reqType string|nil

      ---@param reqMsg boolean|nil

      ---@return any

      function GetParamValue(srcTable, paramName, reqType, reqMsg)
          local err = "[E] Parameter value missing for "..paramName
          if srcTable == nil or not IsTable(srcTable) then
              if reqMsg == true then P(err) end
              return nil
          end
          for k, v in ipairs(srcTable) do
              if v == paramName then
                  local idx = k + 1
                  if #srcTable < idx then
                      if reqMsg == true then P(err) end
                      return nil
                  end
                  local val = srcTable[idx]
                  if not reqType or reqType == "string" or reqType == "s" then
                      if val == '""' or val == "''" then return nil end
                      return val
                  elseif ((reqType == "int" or reqType == "i") and not strmatch(val, "%D")) then
                      return tonum(val)
                  elseif reqType == "number" or reqType == "n" then
                      return tonum(val)
                  elseif reqType == "bool" or reqType == "b" then
                      if val then return true else return false end
                  end
                  return nil
              end
          end
          if reqMsg == true then E(err) end
          return nil
      end


      function PairsByKeys(t, f)
          local a = {}
          for n in pairs(t) do table.insert(a, n) end
          table.sort(a, f)
          local i = 0 -- iterator variable
          local iter = function () -- iterator function
              i = i + 1
              if a[i] == nil then
                  return nil
              else
                  return a[i], t[a[i]]
              end
          end
          return iter
      end


      function BoolState(bool)
          if bool then
              return "enabled"
          else
              return "disabled"
          end
      end


      function BoolStr(b)
          if b == true then
              return "true"
          else
              return "false"
          end
      end


      function ScreenOutput(output, chatFooter)
          local chat = "Point at screen, CTRL+L, then copy text!"
          if #Config.screens >  0 then
              -- local pre = "local rslib = require('rslib')\n"..
              -- "local text = [["..output.."]]\n"..
              -- "local config = { fontSize = 20 }\n"..
              -- "rslib.drawQuickText(text, config)\n"
              local font = OutputFont or "FiraMono"
              local pre = "local text = [[\n"..output.."\n]]\n"..
      [[

      local rslib = require('rslib')

      local layer = createLayer()

      local rx, ry = getResolution()

      local fontSize = 15

      local font = loadFont("]]..font..[[", fontSize)

      local line = 1

      for str in text:gmatch("([^\n]+)") do
          addText(layer, font, str, 20, line*(fontSize+4))
          line = line + 1
      end ]]

      --setNextFillColor(layer, 1, 0, 0, 1)

      --addBox(layer, rx/4, ry/4, rx/2, ry/2)

      --addText(layer, font, text, rx/1, ry/1)
              --Config.screens[1].setHTML(pre)
              Config.screens[1].setRenderScript(pre)
              if chatFooter and chatFooter:len() then
                  chat = chatFooter.."\n"..chat
              end
          else
              chat = "Hint: link a screen to PB to easily copy text from it!"
          end
          P(chat)
          return true
      end

      end)

      package.preload['YFS-Tools:commands.lua']=(function()

      --TODO: refactor commands to use WM instead of databank data

      local cmd = {}


      -- requires libutils, globals PM, SU, YFSDB etc.

      -- WaypointInfo only used for WarpCostCmd()


      local strmatch, sformat, strlen = string.match, string.format, string.len

      local tonum, uclamp, mabs, max, floor, ceil = tonumber, utils.clamp, math.abs, math.max, math.floor, math.ceil


      -- Local functions


      ---@comment Adds for each existing waypoint listed in "wpnames" an extra "Flight" waypoint

      --- at the given altitude with the given name suffix.

      --- Already existing waypoints with the suffix'ed name will have their altitude changed!

      --- Returns a list of "connected" waypoints, e.g.

      --- 1 landed -> 1 flight -> 2 flight -> 2 landed -> 2 flight -> 3 flight -> 3 landed  etc.

      --- as 2nd result; 1st result is the updated full waypoints list.

      ---@param wpdata table

      ---@param wpnames table

      ---@param altitude number

      ---@param suffix string

      local function yfsAddAltitudeWaypoints(wpdata, wpnames, altitude, suffix)
          local cnt = 0
          local names = {}
          local wpCnt = #wpnames
          for _,k in ipairs(wpnames) do
              local wp = wpdata.v[k]
              if wp ~= nil then
                  cnt = cnt + 1
                  local wpN = k .. suffix
                  if cnt > 1 then table.insert(names, wpN) end
                  table.insert(names, k)
                  if cnt < wpCnt then table.insert(names, wpN) end
                  local newPos = PM.ReplaceAltitudeInPos(wp.pos, altitude)
                  if wpdata.v[wpN] ~= nil then
                      wpdata.v[wpN].pos = newPos
                  else
                      wpdata.v[wpN] = { pos = newPos }
                      P(wpN .."  " .. newPos)
                  end
              end
          end
          if cnt == 0 then
              P("[E] No waypoints processed!")
              return nil,nil
          end
          P("[I] "..cnt.." waypoints at "..altitude.."m added (or changed)!")
          return wpdata, names
      end


      local function storeYFSData(keyName, data)
          if not DetectedYFS or not keyName then return false end
          YFSDB:setData(keyName, data)
          return true
      end


      local function getYFSData(keyName)
          if not DetectedYFS or not keyName then return false end
          local data = YFSDB:getData(keyName)
          if data == nil or not IsTable(data.v) then
              return false
          end
          return data
      end


      local function storeYFSNamedWaypoints(data)
          storeYFSData(YFS_NAMED_POINTS, data)
      end


      local function storeYFSRoutes(data)
          storeYFSData(YFS_ROUTES, data)
      end


      -- Class functions


      ---@comment with WM: output name and position for all waypoints

      function cmd.FindCenterCmd(text)
          if not WM or not WM:hasPoints() then
              return E("[E] No waypoints to export.")
          end
          local routes = cmd.GetYFSRoutes()
          if not routes then return end

          local parts = SU.SplitQuoted(text)
          if #parts < 1 then
              return E("[E] Parameter(s) missing: routename\nExample: /findCenter 'Cryo' -onlySelectable")
          end
          local onlySelectable = GetIndex(parts, "-onlySelectable") > 0
          local routename = parts[1]
          local route = routes.v[routename]
          if not route or not IsTable(route.points) or #route.points == 0 then
              return E("[E] Route '"..routename.."' not found or empty")
          end

          local wpdata = cmd.GetYFSNamedWaypoints()

          -- iterate route points and add to calculator
          local pointlist = {}
          local wpIdx = 1
          for _,v in ipairs(route.points) do
              local wppos = ""
              local wpName = "WP "..sformat("%03d", wpIdx)
              if v.waypointRef and wpdata then
                  wpName = v.waypointRef
                  wppos = wpdata.v[wpName].pos
              else
                  wppos = v.pos
              end

              if wppos and ((not onlySelectable) or (v.opt["selectable"] ~= false)) then
                  P("Using "..wpName)
                  pointlist[wpIdx] = PM.MapPosToWorldVec3(wppos)
              end
              wpIdx = wpIdx + 1
          end
          local center = GetCentralPoint(pointlist)
          if center then
              local locPos = PM.WorldToMapPos(center)
              local output = "[I] Center coords: "..PM.MapPos2String(locPos)
              P(output)
          else
              P("[E] Could not calculate center, sorry!")
          end
      end


      function cmd.GetYFSNamedWaypoints(muteMsg)
          if not DetectedYFS then
              return E("[E] Linked YFS databank required!")
          end
          local namedWP = getYFSData(YFS_NAMED_POINTS)
          if not namedWP and not muteMsg then
              P("[I] No named waypoints")
          end
          return namedWP
      end


      function cmd.GetYFSRoutes()
          if not DetectedYFS then
              return E("[E] Linked YFS databank required!")
          end
          local data = getYFSData(YFS_ROUTES)
          if not data then
              return E('[I] No YFS routes found.')
          end
          return data
      end


      function cmd.PlanetInfoCmd(text)
          PM.PlanetInfo(text)
      end


      function cmd.PrintAltitudeCmd(text)
          P(Out.PrettyDistance(PM.Altitude()))
      end


      function cmd.PrintPosCmd(text)
          P(PM.GetCurrentPosString())
      end


      function cmd.PrintWorldPosCmd(text)
          P(PM.Vec3ToPosString(PM.WorldPosVec3()))
      end


      function cmd.WarpCostCmd(text)
          CalcWarpCost(text)
      end


      ---@comment with WM: create commands to recreate waypoints in either YFS or ArchHud format

      function cmd.WpSaveNamedCmd(text, isYfs)
          if not WM or not WM:hasPoints() then
              return E("[E] No waypoints to export.")
          end
          local output = ""
          for _,wp in ipairs(WM:getSorted()) do
              local pos = wp:AsString()
              if isYfs then
                  pos = "pos-save-as '" .. wp:getName() .. "' -pos " .. pos
              else
                  pos = "/addlocation " .. wp:getName() .. " " .. pos
              end
              output = output .. pos .. "\n"
              P(pos)
          end
          ScreenOutput(output)
      end


      function cmd.ArchSaveNamedCmd(text)
          cmd.WpSaveNamedCmd(text, false)
      end


      ---@comment with WM: output name and position for all waypoints

      function cmd.WpExportCmd(text)
          if not WM or not WM:hasPoints() then
              return E("[E] No waypoints to export.")
          end
          local output = ""
          local wplist = WM:getSorted()
          for _,wp in ipairs(wplist) do
              local s = wp:getName() .. "\n" .. wp:AsString() .. "\n"
              output = output .. s
          end
          P(output)
          ScreenOutput(output)
      end


      function cmd.WpAltitudeCeilingCmd(text)
          local wpnames = cmd.GetYFSNamedWaypoints()
          if not wpnames then return end

          -- 0 parse params to find a) name and b) new altitude value
          local parts = SU.SplitQuoted(text)
          if #parts ~= 2 then
              P("[E] Parameter(s) missing: 'name 1' 'name 2'")
              return E("Example: /wp-altitude-ceiling 'Base 1' 'Base 2'")
          end
          local wpName1 = parts[1]
          local wpName2 = parts[2]

          -- 1 find the 2 named waypoints per params
          local wp1found, wp2found = true, true
          if wpnames.v[wpName1] == nil or wpnames.v[wpName1] == "" then
              P("[E] Waypoint '".. wpName1 .."' not found.")
              wp1found = false
          end
          if wpnames.v[wpName2] == nil or wpnames.v[wpName2] == "" then
              P("[E] Waypoint '".. wpName2 .."' not found.")
              wp2found = false
          end
          if not wp1found or not wp2found then return end
          if wpnames.v[wpName1] == wpnames.v[wpName2] then
              return E("[E] Parameters invalid (same names).")
          end

          -- 3 get waypoint's altitudes and update the lower one
          local alt1 = PM.GetAltitudeFromPos(wpnames.v[wpName1].pos)
          local alt2 = PM.GetAltitudeFromPos(wpnames.v[wpName2].pos)
          if alt1 == alt2 then
              P("[I] Waypoints had same altitude, no changes applied.")
              return
          end
          local target, targetAlt = "", 0
          if alt1 > alt2 then
              target = wpName2
              targetAlt = alt1
          else
              target = wpName1
              targetAlt = alt2
          end
          local newPos = PM.ReplaceAltitudeInPos(wpnames.v[target].pos, targetAlt)
          wpnames.v[target].pos = newPos
          P("[I] Waypoint '"..target.."' changed to:")
          P(newPos)

          -- 4 json.encode data and write back to DB
          storeYFSNamedWaypoints(wpnames)
          return true
      end


      function cmd.GetStoredLocations(points) -- for ArchHud only
          if not points or not IsTable(points) then return end
          for _,p in ipairs(points) do
              if p.name and p.position and p.position.x and p.position.y and p.position.z then
                  P("[I] Location '".. p.name .."' found.")
                  local pos = '::pos{0,0,'.. p.position.x .. ',' .. p.position.y .. ',' .. p.position.z ..'}'
                  PM.CreateWaypoint(pos, p.name)
              end
          end
      end


      function cmd.YfsAddAltitudeWpCmd(text)
          local wpdata = cmd.GetYFSNamedWaypoints()
          if not wpdata or not IsTable(wpdata.v) or TableLen(wpdata.v) == 0 then
              return E("[E] No waypoints.")
          end

          local example = "\nExample: /yfs-add-altitude-wp -altitude 450 -suffix 'F'"
          local args = SU.SplitQuoted(text)
          local pStart = GetParamValue(args, "-wpStartsWith", "s")
          if #args < 1 then
              return E("[E] Parameter missing: -altitude"..example)
          end
          local pAlt = GetParamValue(args, "-altitude", "n", true)
          local pSuf = GetParamValue(args, "-suffix", "s")
          if not pSuf or pSuf == "" then pSuf = "F" end
          if pAlt < -100 or pAlt > 20000 then
              return E("[E] -altitude value out of range (-100 .. 20000)"..example)
          end

          -- need a sorted list of names, can't use wpdata as that is being modified
          local wplist = {}
          for k in PairsByKeys(wpdata.v) do
              if not pStart or k:find(pStart) > 0 then
                  table.insert(wplist, k)
              end
          end
          local newData, names = yfsAddAltitudeWaypoints(wpdata, wplist, pAlt, pSuf)
          if newData ~= nil and names ~= nil then
              storeYFSNamedWaypoints(newData)
          end
          return true
      end


      function cmd.YfsBuildRouteFromWpCmd(text)
          local wpdata = cmd.GetYFSNamedWaypoints()
          if not wpdata or not IsTable(wpdata.v) or TableLen(wpdata.v) == 0 then
              return E("[E] No waypoints.")
          end

          local rdata = cmd.GetYFSRoutes()
          if not rdata or not IsTable(rdata.v) or TableLen(rdata.v) == 0 then
              -- Initializing routes
              rdata = { v = {}, t = "table" }
          else
          end

          local example = "\nExample: /yfs-build-route-from-wp -name 'Route' -altitude 450 -wpStartsWith 'Chr' -suffix 'F'\n-suffix is optional, default F (Flight)"
          local args = SU.SplitQuoted(text)
          if #args < 1 then
              return E("[E] Parameters missing!"..example)
          end

          local pName  = GetParamValue(args, "-name", "s", true)
          if not pName then return end
          local pStart = GetParamValue(args, "-wpStartsWith", "s")
          local pAlt   = GetParamValue(args, "-altitude", "n", true)
          if not pAlt then return end
          local pSuf   = GetParamValue(args, "-prefix", "s")
          local pMarginL = GetParamValue(args, "-marginL", "n")
          local pMarginF = GetParamValue(args, "-marginF", "n")
          local pMaxSpeed = GetParamValue(args, "-maxSpeed", "n")
          local pFinalSpeedF = GetParamValue(args, "-finalSpeedF", "n")
          -- some sanity checks, review later
          pMarginL = uclamp(pMarginL or 0.1, 0.1, 100) -- landed position margin
          pMarginF = uclamp(pMarginF or 0.1, 0.1, 100) -- flight position margin
          pMaxSpeed = uclamp(pMaxSpeed or 0, 0, 1200) -- max speed at flight
          pFinalSpeedF = uclamp(pFinalSpeedF or 0, 0, 1200) -- speed reaching the wp
          if rdata.v[pName] ~= nil then
              return E("[E] Route "..pName.."already exists, aborting!")
          end
          if type(pSuf) ~= "string" or pSuf == "" then pSuf = "F" end
          if strlen(pSuf) > 3 then
              return E("[E] -suffix accepts max. 3 characters"..example)
          end
          if pAlt < -600 or pAlt > 20000 then
              return E("[E] -altitude value out of range (-100 .. 20000)"..example)
          end

          -- need a sorted list of names, can't use wpdata as that is being modified *live*
          -- names could be filtered by pStart
          local wplist = {}
          for k in PairsByKeys(wpdata.v) do
              if not pStart or k:find(pStart) > 0 then
                  table.insert(wplist, k)
              end
          end

          -- lets add new "flight" waypoints and get updated tables back
          local wpdata, wplistNew = yfsAddAltitudeWaypoints(wpdata, wplist, pAlt, pSuf)
          if wpdata == nil or wplistNew == nil then
              return E("[I] No waypoints processed: no changes made.")
          end

          -- add new route
          rdata.v[pName] = { points = {} }

          -- assume that wplistNew now contains all required wp names in order
          -- so these can be added to the route
          local cnt = 0
          for _,k in ipairs(wplistNew) do
              local wp = wpdata.v[k]
              if wp ~= nil then
                  -- add wp to route
                  cnt = cnt + 1
                  local rOpt = { margin = 0.1, maxSpeed = 0 }
                  local rp = { opt = rOpt, pos = wp.pos, waypointRef = k }
                  -- for "flight" waypoints:
                  if GetIndex(wplist, k) < 1 then
                      -- set final approaching speed for landing waypoints if specified
                      if pFinalSpeedF and pFinalSpeedF > 0 and GetIndex(wplist, k) < 1 then
                          rp.opt.finalSpeed = pFinalSpeedF
                      end
                      -- set max speed for flight waypoints if specified
                      if pMaxSpeed and pMaxSpeed > 0 then
                          rp.opt.maxSpeed = pMaxSpeed
                      end
                      -- set margin for flight waypoints if specified
                      if pMarginF and pMarginF > 0.1 then
                          rp.opt.margin = pMarginF
                      end
                      rp.opt.selectable = false
                      rp.opt.skippable = false
                  else -- for Landed waypoints:
                      -- set margin for landed waypoints if specified
                      if pMarginL and pMarginL > 0.1 then
                          rp.opt.margin = pMarginL
                      end
                      rp.opt.selectable = true
                      rp.opt.skippable = true
                  end
                  table.insert(rdata.v[pName].points, rp)
              end
          end
          P("[I] "..cnt.." positions added to route '"..pName.."'")
          storeYFSNamedWaypoints(wpdata)
          storeYFSRoutes(rdata)
      end


      function cmd.YfsSaveRouteCmd(text)
          local routes = cmd.GetYFSRoutes()
          if not routes then return end

          local parts = SU.SplitQuoted(text)
          if #parts < 1 then
              return E("[E] Parameter(s) missing: routename\nExample: /yfs-save-route 'Cryo' -onlySelectable -withOptions -prefix 'Cryo'")
          end
          local wpPrefix = GetParamValue(parts, "-prefix", "s")
          if not wpPrefix then wpPrefix = "WP" end
          local onlySelectable = GetIndex(parts, "-onlySelectable") > 0
          local withOptions = GetIndex(parts, "-withOptions") > 0
          local routename = parts[1]
          local route = routes.v[routename]
          if not route or not IsTable(route.points) or #route.points == 0 then
              return E("[E] Route '"..routename.."' not found or empty")
          end
          local output1, output2 = "create-route '"..routename.."'\r\n", ""

          local wpdata = cmd.GetYFSNamedWaypoints()

          -- iterate points, build one commands output for wp creation and one for
          -- adding each with options (optionally) to the route
          local wpIdx = 1
          local wpNames = {} -- to avoid duplicates
          for _,v in ipairs(route.points) do
              local wppos = ""
              local wpName = wpPrefix.." "..sformat("%03d", wpIdx)
              if v.waypointRef and wpdata then
                  wpName = v.waypointRef
                  wppos = wpdata.v[wpName].pos
              else
                  wppos = v.pos or "<unknown>"
              end

              if GetIndex(wpNames, wpName) < 0 then
                  wpNames[#wpNames + 1] = wpName
                  local tmp = "pos-save-as '"..wpName.."' -pos "..wppos
                  output1 = output1 .. tmp .. "\n"
              end
              if (not onlySelectable) or (v.opt["selectable"] ~= false) then
                  local tmp = "route-add-named-pos '"..wpName.."'"
                  if withOptions then
                      -- named-waypoint level options
                      -- Note: "lockdir" option is presently not transferrable!
                      if v.opt["maxSpeed"] and v.opt["maxSpeed"] ~= 0 then
                          tmp = tmp.." -maxspeed "..v.opt["maxSpeed"]
                      end
                      if v.opt["margin"] and v.opt["margin"] ~= 0.1 then
                          tmp = tmp.." -margin "..v.opt["margin"]
                      end
                      -- route-level options require a 2nd command
                      local routeLvlOptions = false
                      local routeOptStr = ""
                      if v.opt["skippable"] == true then
                          routeLvlOptions = true
                          routeOptStr = routeOptStr .. " -toggleSkippable"
                      end
                      if v.opt["selectable"] == false then
                          routeLvlOptions = true
                          routeOptStr = routeOptStr .. " -toggleSelectable"
                      end
                      if v.opt["finalSpeed"] and v.opt["finalSpeed"] ~= 0 then
                          routeLvlOptions = true
                          routeOptStr = routeOptStr.." -finalSpeed "..v.opt["finalSpeed"]
                      end
                      if routeLvlOptions then
                          tmp = tmp .. "\nroute-set-pos-option -ix "..wpIdx..routeOptStr
                      end
                  end
                  output2 = output2 .. tmp .. "\n"
                  wpIdx = wpIdx + 1
              end
          end
          output2 = output2.."route-save\r\n"
          P(output1..output2)
          ScreenOutput(output1..output2)
      end


      ---@comment Replaces a given YFS waypoint (by -name) with current pos (default) or -pos ::pos{...}

      function cmd.YfsReplaceWpCmd(text)
          local wpnames = cmd.GetYFSNamedWaypoints()
          if not wpnames then return end

          local ex = "\r\nExample: /yfs-replace-wp 'base 1'"
          local params = SU.SplitQuoted(text)
          if #params < 1 then
              return E("[E] Parameter(s) missing: -name 'point'"..ex)
          end

          local wpName = GetParamValue(params, "-name", "s", true)
          if not wpName then return end
          if not wpnames.v[wpName] or wpnames.v[wpName] == "" then
              return E("[E] Waypoint '".. wpName .."' not found."..ex)
          end

          local newPos = PM.GetCurrentPosString()
          local pPos = GetParamValue(params, "-pos", "s")
          if pPos then
              ---@diagnostic disable-next-line: cast-local-type
              local tmp = PM.SplitPos(pPos)
              if not tmp then
                  return E("[E] Invalid ::pos{} specified!")
              end
              newPos = pPos
          end

          wpnames.v[wpName].pos = newPos
          P("[I] Waypoint '"..wpName.."' changed to:")
          P(newPos)

          storeYFSNamedWaypoints(wpnames)
          return true
      end


      ---@comment Resets waypoint options for a range of waypoints in a specified route

      function cmd.YfsOptionsResetCmd(text)
          local routes = cmd.GetYFSRoutes()
          if not routes then return end

          -- 1 check parameters
          local example = "\nExample:\n/yfs-options-reset -route 'name' -ix 2 -endIx 3\nWith -endIx being optional."
          local parts  = SU.SplitQuoted(text)
          local pName  = GetParamValue(parts, "-route", "s", true)
          if not pName then return E(example) end
          if not routes.v[pName] then
              return E("[E] Route '"..pName.."' not found."..example)
          end
          if not routes.v[pName].points or #routes.v[pName].points == 0 then
              return E("[E] Route '"..pName.."' empty.")
          end

          local pStart = GetParamValue(parts, "-ix", "i", true)
          local pEnd   = GetParamValue(parts, "-endIx", "i")
          if not pEnd then pEnd = #routes.v[pName].points end
          local isError = not pName or not pStart or (pStart < 1) or (pEnd and pEnd < pStart)
          if isError then
              return E("[E] Wrong number of parameters / invalid values!"..example)
          end
          if not pEnd or pEnd < pStart then pEnd = pStart end

          -- 2 process route waypoints and collect named waypoint names
          -- /yfs-options-reset -route 'Peta' -ix 2 -endIx 3
          P("[I] Processing route '"..pName.."'")
          local changed = 0
          local finalSpeed = 30 / 3.6 -- 30 km/h -> 8.333 m/s
          for i,v in ipairs(routes.v[pName].points) do
              if i >= pStart and i <= pEnd then
                  local wpName = v.waypointRef
                  if not wpName then
                      wpName = i -- unnamed WP, use index
                  end
                  changed = changed + 1
                  -- only reset specific attributes, so that selectable/skippable stays intact!
                  routes.v[pName].points[i].opt.finalSpeed = finalSpeed
                  routes.v[pName].points[i].opt.maxSpeed = 0
                  routes.v[pName].points[i].opt.margin = 0.1
                  routes.v[pName].points[i].opt.lockDir = nil
                  P("[I] Options reset for route waypoint: "..wpName)
              end
          end
          if changed == 0 then
              return E("[I] No waypoints in route changed.\n[*] Make sure that start (and end-index) are valid.")
          end
          -- 3 store route back to db
          storeYFSRoutes(routes)
          P("[I] Routes saved.")
      end


      ---@comment Replaces altitude for a range of waypoints in a specified route

      function cmd.YfsRouteAltitudeCmd(text)
          local routes = cmd.GetYFSRoutes()
          if not routes then return end

          local namedWP = cmd.GetYFSNamedWaypoints()
          --if not namedWP then return end

          -- 1 check parameters
          local example = "\nExample:\n/yfs-route-altitude -route 'name' -ix 2 -endIx 3 -alt 330\nThe -endIx is optional."
          local parts  = SU.SplitQuoted(text)
          local pName  = GetParamValue(parts, "-route", "s", true)
          if not pName then return end
          if not routes.v[pName] then
              return E("[E] Route '"..pName.."' not found."..example)
          end
          if not routes.v[pName].points or #routes.v[pName].points == 0 then
              return E("[E] Route '"..pName.."' empty.")
          end

          local pStart = GetParamValue(parts, "-ix", "i", true)
          local pEnd   = GetParamValue(parts, "-endIx", "i")
          local pAlt   = GetParamValue(parts, "-alt", "n", true)
          if not pEnd then pEnd = #routes.v[pName].points end

          local isError = not pName or not pStart or not pAlt or (pStart < 1) or (pEnd and pEnd < pStart) or (pAlt < -100) or (pAlt > 10000)
          if isError then
              return E("[E] Wrong number of parameters / invalid values!"..example)
          end
          if not pEnd or pEnd < pStart then pEnd = pStart end

          -- 2 process route waypoints and collect named waypoint names
          -- /yfs-route-altitude -route 'Peta' -ix 2 -endIx 3 -alt 750
          P("[I] Processing route '"..pName.."'")
          local changed = 0
          local wpnames = {}
          for i,v in ipairs(routes.v[pName].points) do
              if i >= pStart and i <= pEnd then
                  local newPos = ""
                  local wpName = v.waypointRef
                  if wpName and namedWP and namedWP.v and namedWP.v[wpName] then
                      local wp = namedWP.v[wpName]
                      if GetIndex(wpnames, wpName) < 1 then
                          table.insert(wpnames, wpName)
                      end
                      newPos = PM.ReplaceAltitudeInPos(wp.pos, pAlt)
                  else -- unnamed WP
                      wpName = i
                      newPos = PM.ReplaceAltitudeInPos(v.pos, pAlt)
                  end
                  changed = changed + 1
                  routes.v[pName].points[i].pos = newPos
                  P("[I] Route Waypoint '"..wpName.."' changed to:\n"..newPos)
              end
          end
          if changed == 0 then
              return E("[I] No waypoints in route changed.\n[*] Make sure that start (and end-index) are valid.")
          end
          -- 3 store routes back to db
          storeYFSRoutes(routes)
          P("[I] Routes saved.")

          -- 4 process named waypoints list
          changed = 0
          for _,entry in ipairs(wpnames) do
              if namedWP and namedWP.v[entry] then
                  changed = changed + 1
                  local newPos = PM.ReplaceAltitudeInPos(namedWP.v[entry].pos, pAlt)
                  namedWP.v[entry].pos = newPos
                  P("[I] Named Waypoint '"..entry.."' changed to:")
                  P(newPos)
              else
                  P("[E] '"..entry.."' not found!")
              end
          end
          -- 5 write back to DB
          if changed > 0 then
              storeYFSNamedWaypoints(namedWP)
              P("[I] Named waypoints saved.")
          end
      end


      function cmd.YfsWpAltitudeCmd(text)
          -- 1 read named waypoints from DB
          local wpnames = cmd.GetYFSNamedWaypoints()
          if not wpnames then return E("[E] No named waypoints.") end

          -- 2 parse params to find a) name and b) new altitude value
          local parts = SU.SplitQuoted(text)
          if #parts ~= 2 then
              return E("[E] Wrong number of parameters!\nExample: /yfs-wp-altitude 'Base 1' 324.12")
          end
          local pName = parts[1] or ""

          -- 3 find named waypoint
          if not pName or not parts[2] or not wpnames.v[pName] or wpnames.v[pName] == "" then
               return E("[E] Waypoint '".. pName .."' not found")
          end

          -- 4 alter waypoint's altitude
          local pAlt = tonum(parts[2] or 0)
          local newPos = PM.ReplaceAltitudeInPos(wpnames.v[pName].pos, pAlt)
          wpnames.v[pName].pos = newPos
          P("[I] Waypoint '"..pName.."' changed to:")
          P(newPos)
          P("[I] Note: routes' waypoints are updated on route activation, i.e. exporting route data before activation may still show old value!")

          -- 4 write back to DB
          storeYFSNamedWaypoints(wpnames)
          return true
      end


      function cmd.YfsRouteNearestCmd(text)
          local routes = cmd.GetYFSRoutes()
          if not routes then return end
          -- 1 process params
          local params = SU.SplitQuoted(text)
          if #params == 0 or #params > 2 then
              P("[E] Wrong parameter count\n[I] Example: /yfs-route-nearest 'Route 1'")
              P("\nOptional parameter:\n")
              P("-onlySelectable -> only show closest, selectable waypoints in route")
              return false
          end
          -- 2 find the route
          local routeName = params[1]
          local route = routes.v[routeName]
          if not route or not IsTable(route.points) then
              return E("[E] Route '" .. routeName .."' not found or empty")
          end
          P("[I] Route '"..routeName.."' found.")
          -- 3 check optional parameters
          local onlySelectable = GetIndex(params, "-onlySelectable") > 0

          -- 4 process route waypoints
          local wplist = cmd.GetYFSNamedWaypoints(true)
          local idx = 0
          local closestDist = 999999999
          local sDist, sNearest = "", ""
          local res =  {}
          for k,v in ipairs(route.points) do
              idx = idx + 1
              if (not onlySelectable) or (v.opt and v.opt.selectable ~= false) then
                  local wpname = SU.Trim(sformat("%02d", idx) .. ": '"..(v.waypointRef or "").."'")
                  local pos = v.pos
                  if v.waypointRef and wplist then
                      pos = wplist.v[v.waypointRef].pos
                  end
                  local dist = PM.GetDistance(pos)
                  if dist > 0.1 then
                      route.points[k].distance = dist
                      sDist = wpname .. " = " .. sformat("%.4f", dist)
                      if dist < closestDist then
                          sNearest = sDist
                          closestDist = dist
                      end
                      local tmpDist = tostring(math.modf(dist * 10000))
                      local key = ('0'):rep(12-#tmpDist)..tmpDist
                      res[key] = idx
                  end
              end
          end
          if not idx then return E("[I] No selectable waypoints found.") end
          local output = "Route-Idx / Name / Distance (m)\n"
          for _,key in pairs(GetSortedAssocKeys(res)) do
              local routeIdx = res[key]
              local wpName = route.points[routeIdx].waypointRef or routeIdx
              local wpDist = route.points[routeIdx].distance
              output = output .. sformat("%02d", routeIdx).." / '"..wpName.."' / "
              output = output .. Out.PrettyDistance(wpDist).."\n"
          end
          output = output .. "\n[I] Nearest waypoint: "..sNearest

          Out.PrintLines(output)
          ScreenOutput(output)
      end


      function cmd.YfsRouteToNamedCmd(text)
          local routes = cmd.GetYFSRoutes()
          if not routes then return end
          -- 1 process params
          local params = SU.SplitQuoted(text)
          if #params == 0 or #params > 6 then
              P("[E] Wrong parameter count\n[I] Example: /yfs-route-to-named 'Route 1'\nOptional parameters:\n")
              P("-onlySelectable -> only write waypoints marked as selectable in route")
              P("-prefix Myprefix -> if unspecified, 'WP' is default")
              P("-toScreen -> output JSON of list to optional screen if linked")
              P("-toDB -> only if this is given, the changed list will be written to DB to avoid miscalls")
              P("Important: command aborts if ANY waypoint's name starts with given prefix to avoid errors!")
              return false
          end
          -- 2 find the route
          local routeName = params[1]
          local route = routes.v[routeName]
          if not route or not IsTable(route.points) then
              return E("[E] Route '" .. routeName .."' not found or empty")
          end
          P("[I] Route '"..routeName.."' found.")
          -- 3 check optional parameters
          local toDB = GetIndex(params, "-toDB") > 0
          local toScreen = GetIndex(params, "-toScreen") > 0
          local onlySelectable = GetIndex(params, "-onlySelectable") > 0
          local wpPrefix = GetParamValue(params, "-prefix", "s")
          if not wpPrefix then wpPrefix = "WP" end

          -- 4 process route waypoints
          local wplist = cmd.GetYFSNamedWaypoints(true)
          if not wplist or not wplist.v then
              wplist = { v = { } }
          else
              -- if any WP with same prefix already exists, abort!
              for k,_ in pairs(wplist.v) do
                  if string.find(k, wpPrefix) == 1 then
                      return E("[!] Waypoints with same prefix already exist!\n[!] Command aborted.")
                  end
              end
          end
          local idx = 0
          for _,v in ipairs(route.points) do
              if (not onlySelectable) or (v.opt and v.opt.selectable ~= false) then
                  idx = idx + 1
                  local wpname = wpPrefix .. " " .. sformat("%02d", idx)
                  local wp = { pos = v.pos, opt = v.opt}
                  --if margin then wp.opt.margin = margin end
                  wplist.v[wpname] = wp
                  P(wpname .."  " .. v.pos)
              end
          end
          if not idx then return E("[I] No changes to waypoints done") end

          -- 5 write waypoints back to DB, if at least 1 point was added
          if toDB then
              storeYFSNamedWaypoints(wplist)
              P("[I] Waypoint changes saved to databank!")
          else
              P("[I] -toDB not present, no changes saved to databank!")
          end
          if toScreen then
              ScreenOutput(json.encode(wplist.v))
          end
      end


      function cmd.YFSLoadNamedWaypoints()
          local wpnames = cmd.GetYFSNamedWaypoints()
          if not wpnames then return end
          for k,v in pairs(wpnames.v) do
              PM.CreateWaypoint(v.pos, k)
          end
      end


      function cmd.YFSLoadRoutepoints(onlySelectableWP, onlyWpForRoute)
          local routes = cmd.GetYFSRoutes()
          if not routes then return false end
          P('[I] Processing routes...')
          for k,v in pairs(routes.v) do
              if (onlyWpForRoute == "" or onlyWpForRoute == k) and IsTable(v) then
                  for k2,v2 in ipairs(v.points) do
                      if (not onlySelectableWP) or (v2.opt["selectable"] ~= false) then
                          local wpName = k .. " " .. k2
                          if v2.waypointRef then
                              wpName = v2.waypointRef
                          end
                          PM.CreateWaypoint(v2["pos"], wpName)
                      end
                  end
                  P("[I] Route '"..k.."' read.")
              end
          end
          return true
      end


      function cmd.YfsSaveNamedCmd(text)
          cmd.WpSaveNamedCmd(text, true)
      end


      function cmd.PosDataCmd()
          --P("GetCameraCmd() called")
          P("getCameraHorizontalFov: "..system.getCameraHorizontalFov())
          P("getCameraVerticalFov: "..system.getCameraVerticalFov())

          P("getCameraPos: "..PM.Vec3String(system.getCameraPos()))
          P("getCameraForward: "..PM.Vec3String(system.getCameraForward()))
          P("getCameraRight: "..PM.Vec3String(system.getCameraRight()))
          P("getCameraUp: "..PM.Vec3String(system.getCameraUp()))

          P("getCameraWorldPos: "..PM.Vec3String(system.getCameraWorldPos()))
          P("getCameraWorldForward: "..PM.Vec3String(system.getCameraWorldForward()))
          P("getCameraWorldRight: "..PM.Vec3String(system.getCameraWorldRight()))
          P("getCameraWorldUp: "..PM.Vec3String(system.getCameraWorldUp()))

          P("construct.getWorldPosition: "..PM.Vec3String(construct.getWorldPosition(CNID)))
          P("construct.getOrientationForward: "..PM.Vec3String(construct.getOrientationForward()))
          P("construct.getOrientationRight: "..PM.Vec3String(construct.getOrientationRight()))
          P("construct.getOrientationUp: "..PM.Vec3String(construct.getOrientationUp()))
      end


      function cmd.DumpPointsCmd()
          if true then
              P("~=~=~=~=~=~=~= DUMP START ~=~=~=~=~=~=")
              local tmp = Out.DumpVar(WM:getWaypointsInst())
              P(tmp)
              return ScreenOutput((tmp or "[I] No waypoints."),"\n~=~=~=~=~=~=~= DUMP END ~=~=~=~=~=~=~=")
          end

      end


      function cmd.DumpRoutesCmd()
          if not DetectedYFS then return E("[I] No YFS databank.") end
          P("~=~=~=~=~=~=~= ROUTES DUMP START ~=~=~=~=~=~=")
          local tmp = YFSDB:getString(YFS_ROUTES)
          P(tmp)
          ScreenOutput((tmp or "[I] No routes."),"\n~=~=~=~=~=~=~= ROUTES DUMP END ~=~=~=~=~=~=~=")
      end


      function cmd.RoutesCmd()
          local routes = cmd.GetYFSRoutes()
          if not routes then return end
          P("[I] Available routes:")
          for k,_ in pairs(routes.v) do
              P(k)
          end
      end


      -- *** Dev/Testing functions ***


      function cmd.YfsTestDataCmd(param)
          if not (param == "TESTING") then return end
          P("[*] Creating YFS test data...")

          YFSDB:remove(YFS_NAMED_POINTS)
          local data = { }
          data["Chr 01"] = { pos = "::pos{0,7,-20.7784,-153.7402,360.5184}", opt = {} }
          data["Chr 02"] = { pos = "::pos{0,7,-21.3610,-152.3447,345.8787}", opt = {} }
          data["Chr 03"] = { pos = "::pos{0,7,-23.0540,-152.8934,360.6677}", opt = {} }
          data["Chr 04"] = { pos = "::pos{0,7,-22.4445,-154.3119,320.1029}", opt = {} }
          data["Chr 05"] = { pos = "::pos{0,7,-20.5370,-154.7507,308.0151}", opt = {} }
          data["Chr 06"] = { pos = "::pos{0,7,-21.6295,-155.1465,292.7660}", opt = {} }
          data["Chr Hub"] = { pos = "::pos{0,7,-21.9903,-153.1008,391.4632}", opt = {} }
          local tmp = { v = data, t = type(data) }
          storeYFSNamedWaypoints(tmp)

          YFSDB:remove(YFS_ROUTES)
          local r = { }
          -- r["Test"] = { points = { } }
          -- r["Test"].points[1] = { pos = "::pos{0,7,-20.8094,-153.7308,366.1022}", waypointRef = "Chr 01" }
          storeYFSRoutes({ v = r, t = type(r) })

          P("[*] YFS test data saved!")
          cmd.DumpPointsCmd()
          cmd.DumpRoutesCmd()
      end


      function cmd.ConversionTestCmd(param)
          PM.ConversionTest()
      end


      function cmd.XCmd()
          -- local s = "-name C -altitude 440 -marginL 0.5 -marginF 1 -finalSpeedF 10 -suffix 'F'"
          -- P("X params: "..s)
          -- cmd.YfsBuildRouteFromWpCmd(s)
      end


      return cmd

      end)

      package.preload['YFS-Tools:help.lua']=(function()

      local help = {}


      function help.PrintHelpCmd()
          local hlp = "~~~~~~~~~~~~~~~~~~~~\nYFS-Tools Commands:\n~~~~~~~~~~~~~~~~~~~~\n"..
          "/arch-save-named\n-> Builds list of chat commands for ArchHud to add locations for all named waypoints.\n"..
          "/findCenter\n-> Calculates center between all points of a route, like for a central hub.\n"..
          "/planetInfo (id or name)\n-> Info about current planet or for passed planet id or name, e.g. 2 for Alioth).\n"..
          "/printAltitude /printPos /printWorldPos\n-> Prints info data.\n"..
          "/warpCost -from name/::pos{}/planets -to name/::pos{}/planets -mass tons -moons\n-> Flexible warp cell calculator.\n"..
          "/wp-altitude-ceiling\n-> Changes a waypoint to have the higher altitude of both.\n"..
          "/wp-export\n-> Outputs list of plain waypoints to chat and an optional screen. Source can include ArchHud locations, too, if databank linked.\n"..
          "/yfs-add-altitude-wp\n-> Adds waypoints for each existing WP at a specified altitude and name suffix.\n"..
          "/yfs-build-route-from-wp\n-> Powerful route-building command based on existing named waypoints.\n"..
          "/yfs-options-reset\n-> Reset options of route waypoints for a specific route.\n"..
          "/yfs-replace-wp 'name'\n-> Replaces a named waypoint with the current location.\n"..
          "/yfs-route-altitude\n-> Changes altitude for a range of waypoints of a specific YFS route.\n"..
          "/yfs-route-nearest\n-> Show list of route waypoints by distance from current location.\n"..
          "/yfs-route-to-named\n-> Converts a route's *unnamed* waypoints to named waypoints for YFS.\n"..
          "/yfs-save-named\n-> Builds list of YFS commands to recreate all named waypoints.\n"..
          "/yfs-save-route\n-> Builds list of YFS commands to recreate full route incl. named waypoints and their options.\n"..
          "/yfs-wp-altitude\n-> Changes altitude of a named waypoint to specified altitude.\n"..
          "=========================================\n"..
          "Important: Enclose names (as parameters) in single quotes if they contain blanks!\n"..
          "*** DO NOT USE COMMANDS THAT CHANGE POINTS ***\n*** OR ROUTES WHILE YFS IS RUNNING! ***\n"
          ScreenOutput(hlp)
          P(hlp)
      end


      return help

      end)

      package.preload['YFS-Tools:warpcost.lua']=(function()

      -- requires SU, PM

      local strmatch, sformat, strlen = string.match, string.format, string.len

      local tonum, uclamp, mabs, max, floor, ceil = tonumber, utils.clamp, math.abs, math.max, math.floor, math.ceil



      ---@comment Calculates # of warp cells for distance and mass

      ---@param text string List of space-separated params

      function CalcWarpCost(text)
          local example = "\nExample 1:\n/warpCost -from Madis -to Alioth -mass 534"..
              "\nExample 2:\n/warpCost -from Alioth -to planets -moons"..
              "\nOptional '-from x' with x being either 'here', a planet name, ::pos{} or 'planets' (multi-result)."..
              "\nOptional '-to x' like -from, but for end location."..
              "\nOptional '-mass x' with x the total mass in tons. If not given, the current constructs' total mass is used."..
              "\nOptional '-cargo x' with x the cargo mass in tons. If specified, a cell count for a return trip is calculated, too."..
              "\nOptional '-moons' only together with 'planets' to also include moons in the list."..
              "\n- One of -from or -to can be left out, then the current construct's location (or planet) is used."..
              "\n- If construct is landed on a planet or moon, the Atlas specified warp altitude is the starting point."..
              "\n- Enclose names in single-quotes if they contain spaces!"
          local getCMass = construct.getMass
          local pOn, onPlanet = {}, false
          local s, s2 = "~~~ WARP CELL CALCULATOR ~~~", ""

          local function checkParam(args, pName, isFrom)
              local v, allPlanets, offs = {}, false, 0
              local par = GetParamValue(args, pName, "s")
              if not par or (par == "") or (par == "here") then
                  v = PM.WorldPosVec3() -- current position
                  if onPlanet and pOn then
                      offs = 2 * pOn.radius
                      par = pOn.name[1]
                      v = vec3(pOn.center)
                  else
                      offs = 12 -- min. 12 km warp distance
                      par = PM.Vec3ToPosString(v)
                  end
              elseif par == "planets" then
                  allPlanets = true
              elseif par > "" then
                  if SU.StartsWith(par, "::pos{") then
                      offs = 12 -- min. 12 km warp distance
                      v = PM.MapPosToWorldVec3(par)
                  else
                      local p = PM.PlanetByName(par)
                      if p then
                          offs = 2 * p.radius
                          v = vec3(p.center)
                      end
                  end
              end
              return { parm = par, v = v, isP = allPlanets, offset = offs }
          end

          local args = SU.SplitQuoted(text)
          if #args < 1 then return E("[E] Parameter(s) missing!"..example) end
          local pMoons = GetIndex(args, "-moons") > 0

          -- for current location, check if we are "on" a planet (within atmo-radius),
          -- and set an offset of 2*radius from center as "warp barrier"
          local offset = 0
          pOn = PM.GetClosestPlanet(PM.WorldPosVec3())
          if pOn then
              offset = 2 * pOn.radius -- warp exclusion distance from center
              onPlanet = PM.Altitude() < offset
              if onPlanet then
                  s2 = "Current"
              else
                  s2 = "Nearest"
              end
              s = s.."\n"..s2.." planet: "..pOn.name[1]
          else
              s = s.."\n[I] No planet nearby!"
          end

          ---@diagnostic disable-next-line: missing-parameter
          local maxMass = 50000
          ---@diagnostic disable-next-line: missing-parameter
          local tons = getCMass(CNID) / 1000 -- CNID in globals.lua!

          -- check -cargo param and value
          local pCargo, bCargo = 0, false
          if GetIndex(args, "-cargo") > 0 then
              local tmpCargo = GetParamValue(args, "-cargo", "n")
              tmpCargo = tmpCargo or 0
              if tmpCargo > 0 then
                  pCargo = uclamp(tmpCargo, 0, maxMass)
                  bCargo = pCargo > 0
              else
                  return E(s.."\n[E] Invalid -cargo value, must be in range of 1-50000 tons!")
              end
          end

          local pMass = GetParamValue(args, "-mass", "n")
          s2 = "Mass: "
          if pMass then
              tons = tonum(pMass)
          else
              s2 = "Construct "..s2
          end
          s = s.."\n"..s2..Out.PrettyMass(tons*1000)
          if bCargo then
              s = s.."  ~*~  Cargo: "..Out.PrettyMass(pCargo*1000)
          end
          if tons < 100 then -- warp drive alone is 75 tons!
              return E(s.."\n[E] Impossibly low mass for a warp ship! ;)")
          elseif tons > maxMass then
              return E(s.."\n[E] I don't accept you're warping that heavy! ;)")
          end

          local locFrom = checkParam(args, "-from", true)
          if not locFrom.isP and not locFrom.v then
              return E(s.."\n[E] Invalid starting location!")
          end
          local locTo = checkParam(args, "-to", false)
          if not locTo.isP and not locTo.v then
              return E(s.."\n[E] Invalid end location!")
          end

          if locFrom.isP and locTo.isP then
              return E(s.."\n[E] Only one 'planets' option supported!")
          end
          if (locFrom.parm == locTo.parm) or (locFrom.v == locTo.v) then
              return E(s.."\n[E] Start and end locations must be different!")
          end

          local function process(from, to, distance, massT, cargo)
              local out = ""
              if from > "" then out = out .. from end
              if from > "" and to > "" then out = out .. " to " end
              if to > "" then out = out .. to end
              out = out.. " ("..Out.PrettyDistance(distance)..")"

              -- min 1 SU, max 500 SU (1 SU = 200000 m)
              if distance < 200000 then
                  return out.." -> too short!"
              elseif distance > 100000000 then
                  return out.." -> too far!"
              end
              local cnt = PM.ComputeCells(distance, massT)
              out = out.." = "..cnt.." cell" .. SU.If(cnt > 1, "s")
              if bCargo then
                  local cnt2 = PM.ComputeCells(distance, massT - cargo)
                  out = out.." / "..cnt2.." cell" .. SU.If(cnt > 1, "s").." = "..(cnt+cnt2).." total"
              end
              return out
          end

          -- Single source and destination
          if not locFrom.isP and not locTo.isP then
              local distance = mabs(vec3(locFrom.v - locTo.v):len()) - locFrom.offset - locTo.offset
              local res = process(locFrom.parm, locTo.parm, distance, tons, pCargo)
              if type(res) == "string" then
                  s = s .. "\n" .. res
                  P(s)
                  ScreenOutput(s)
              else
                  E("[E] Sorry, something went wrong :(")
              end
              return
          end

          -- Planets processing
          local v1, v2 = nil, nil
          s2 = " (Distance) / Cells"..SU.If(bCargo, " / Return w/o cargo")
          if locFrom.isP then
              s = s.."\nTo: "..locTo.parm.."\nFrom"..s2
          else
              s = s.."\nFrom: "..locFrom.parm.."\nTo"..s2
          end
          for _,v in pairs(WaypointInfo[0]) do
              if not v.isAsteroid and (pMoons or not v.isMoon) then
                  offset = 2 * v.radius
                  if locFrom.isP then
                      locFrom.parm = v.name[1]
                      locFrom.v = v.centerV3
                      offset = offset + locTo.offset
                  else
                      locTo.parm = v.name[1]
                      locTo.v = v.centerV3
                      offset = offset + locFrom.offset
                  end
                  local distance = mabs(vec3(locFrom.v - locTo.v):len()) - offset
                  if distance > 100000 then
                      s = s .. "\n" ..
                          process(SU.If(locFrom.isP, locFrom.parm),
                                  SU.If(locTo.isP, locTo.parm),
                                  distance, tons, pCargo)
                  end
              end
          end
          P(s)
          ScreenOutput(s)
      end


      end)

      package.preload['YFS-Tools:../util/wpoint.lua']=(function()

      local tonum, strlen, strmatch = tonumber, string.len, string.match


      ---@comment Simple Waypoint class to store a name with a location.

      --- No location conversions or changes are done in this class!

      --- The set method is flexible, though, in what it accepts as source for a location.

      --- @class Waypoint

      Waypoint = { mapPos = {}, name = "", parent = nil }


      -- Waypoint methods

      Waypoint.new = function(parent)
          local obj = setmetatable(
              { parent = parent, name = "",
                mapPos = { systemId = 0, id = 0, latitude = 0.0, longitude = 0.0, altitude = 0.0 } },
              { __index = Waypoint }
          )
          return obj
      end


      ---@comment Returns the waypoint as { systemId, id, latitude, longitude, altitude }

      ---@return table

      Waypoint.get = function(self)
          return self.mapPos
      end


      Waypoint.getPosPattern = function()
          local num = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'
          return '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' .. num ..  ',' .. num .. '}'
      end


      ---@comment Sets a waypoint to the given map position (::pos{}, vec3 or table with 3 or 5 pos data)

      Waypoint.set = function(self, newMapPos)
          if type(newMapPos) == "string" and strlen(newMapPos) < 16 then
              print("[E] Invalid position: "..newMapPos)
              return {}
          end

          if type(newMapPos) == "string" then
              local s, p, x, y, z = strmatch(newMapPos, self.getPosPattern())
              if s then
                  self.mapPos.systemId = tonum(s)
                  self.mapPos.id = tonum(p)
                  self.mapPos.latitude = tonum(x)
                  self.mapPos.longitude = tonum(y)
                  self.mapPos.altitude = tonum(z)
              else
                  print(newMapPos.." - Invalid string format. Use '::pos{s, p, x, y, z}'.")
              end
          elseif type(newMapPos) == "table" and #newMapPos == 3 then
              self.mapPos.latitude = tonum(newMapPos[1])
              self.mapPos.longitude = tonum(newMapPos[2])
              self.mapPos.altitude = tonum(newMapPos[3])
          elseif type(newMapPos) == "table" and #newMapPos == 5 then
              self.mapPos.systemId = tonum(newMapPos[1])
              self.mapPos.id = tonum(newMapPos[2])
              self.mapPos.latitude = tonum(newMapPos[3])
              self.mapPos.longitude = tonum(newMapPos[4])
              self.mapPos.altitude = tonum(newMapPos[5])
          elseif type(newMapPos) == "table" and newMapPos.x and newMapPos.y and newMapPos.z then
              self.mapPos.systemId = 0
              self.mapPos.id = 0
              self.mapPos.latitude = tonum(newMapPos.x)
              self.mapPos.longitude = tonum(newMapPos.y)
              self.mapPos.altitude = tonum(newMapPos.z)
          else
              print("Invalid input. Provide a ::pos{} string, vec3() or {s,p,x,y,z} table.")
          end
          return self
      end


      ---@comment Set the name for the waypoint. Can be empty.

      ---@param self table

      Waypoint.setName = function(self, newName)
          if newName == nil then self.name = "" return end
          if type(newName) == "string" and newName:gmatch("^%a[%w_- ]*$") then
              self.name = newName
          else
              print(tostring(newName).."\n[E] WP: Invalid name format. Should only contain printable characters.")
          end
          return self
      end


      ---@comment Returns the name for the waypoint. Can be empty.

      Waypoint.getName = function(self)
          return self.name
      end


      ---@comment Returns just the altitude value (number).

      Waypoint.getAltitude = function(self)
          return self.mapPos.altitude
      end


      ---@comments Returns ::pos{} string of the waypoint

      ---@return string

      Waypoint.AsString = function(self)
          return string.format("::pos{%d, %d, %.4f, %.4f, %.4f}",
                               self.mapPos.systemId, self.mapPos.id,
                               self.mapPos.latitude, self.mapPos.longitude, self.mapPos.altitude)
      end


      Waypoint.__Waypoint = function(self) return true end

      end)

      package.preload['YFS-Tools:../util/wpointmgr.lua']=(function()

      local tonum, strlen, strmatch = tonumber, string.len, string.match



      ---@class WaypointMgr

      WaypointMgr = { name = "", waypoints = {} }


      --- comment Add a waypoint object to the list at position 'index'

      --- @param self table

      --- @param waypoint any

      --- @param index any

      --- @return nil

      WaypointMgr.add = function(self, waypoint, index)
          if waypoint.__Waypoint and waypoint.__Waypoint() then
              -- If the waypoint has no name, skip duplicate check
              if waypoint.name and waypoint.name ~= "" then
                  -- Check if a waypoint with the same name already exists
                  for _,v in ipairs(self.waypoints) do
                      if v.name == waypoint.name then
                          return nil
                      end
                  end
              end
              local wplus1 = 1 + #self.waypoints
              if index then
                  -- Check if the specified index is within the valid range
                  if index < 1 or index > wplus1 then
                      print("[E] Invalid index. Must be in the range 1 to " .. wplus1)
                      return nil
                  end
                  waypoint.parent = self
                  table.insert(self.waypoints, index, waypoint)
              else
                  waypoint.parent = self
                  table.insert(self.waypoints, wplus1, waypoint)
              end
              return waypoint
          else
              print("[E] Invalid waypoint parameter!")
              return nil
          end
      end


      ---@comment List of waypoints' data as table.

      ---@return table (systemId, planetId, latitude, longitude, altitude)

      WaypointMgr.getWaypointsData = function(self)
          local res = {}
          for k,v in ipairs(self.waypoints) do
              table.insert(res, k, v:get())
          end
          return res
      end


      ---@comment List of all waypoints as Waypoint objects.

      ---@return table Array of all Waypoint instances

      WaypointMgr.getWaypointsInst = function(self)
          return self.waypoints
      end


      ---@comment Returns the count of all waypoints

      ---@return integer Count of all waypoints

      WaypointMgr.getCount = function(self)
          return #self.waypoints
      end


      ---@comment Returns array of all waypoint instances sorted by their name

      ---@return table Array

      WaypointMgr.getSorted = function(self)
          local sortedPoints = {}

          -- Copy waypoints to a new table for sorting
          for _,v in pairs(self.waypoints) do
              table.insert(sortedPoints, v)
          end

          -- Sort the copied table by waypoint names
          table.sort(sortedPoints, function(a, b)
              return a.name < b.name
          end)
          return sortedPoints
      end


      ---@comment Moves waypoint at given index up by one, but 1 as minimum

      WaypointMgr.moveUp = function(self, index)
          local waypointsCount = #self.waypoints

          if index and index > 1 and index <= waypointsCount then
              self.waypoints[index], self.waypoints[index - 1] = self.waypoints[index - 1], self.waypoints[index]
          end
      end


      ---@comment Moves waypoint at given index down by one, but to end index as maximum

      WaypointMgr.moveDown = function(self, index)
          local waypointsCount = #self.waypoints

          if index and index >= 1 and index < waypointsCount then
              self.waypoints[index], self.waypoints[index + 1] = self.waypoints[index + 1], self.waypoints[index]
          end
      end


      ---@comment Removes only the first waypoint with the given name and returns that waypoint instance, otherwise nil

      ---@return any Either removed waypoint instance or nil if not found

      WaypointMgr.removeByName = function(self, waypointName)
          for i, waypoint in ipairs(self.waypoints) do
              if waypoint.name == waypointName then
                  local removedWaypoint = table.remove(self.waypoints, i)
                  return removedWaypoint  -- Return the removed waypoint
              end
          end
          return nil  -- Return nil if not found
      end


      ---@comment Returns true if at least one waypoint exist, else false

      ---@return boolean

      WaypointMgr.hasPoints = function(self, param)
          return #self.waypoints > 0
      end


      ---@comment Checks if a waypoint exists in 3 different ways: name, waypoint instance or same data

      ---@return any If not found, returns nil, otherwise the found waypoint instance

      WaypointMgr.exists = function(self, param)
          for _, v in ipairs(self.waypoints) do
              if type(param) == "string" and v.name == param then
                  return v
              elseif param and param.__Waypoint and Waypoint.__Waypoint() then
                  if v == param then
                      return v
                  end
              elseif type(param) == "table" and #param == 5 then
                  -- Check if a waypoint with the same nums exists
                  if v.mapPos.systemId  == tonum(param[1]) and
                     v.mapPos.id        == tonum(param[2]) and
                     v.mapPos.latitude  == tonum(param[3]) and
                     v.mapPos.longitude == tonum(param[4]) and
                     v.mapPos.altitude  == tonum(param[5]) then
                      return v
                  end
              end
          end
          return nil
      end


      WaypointMgr.getName = function(self)
          return self.name
      end


      WaypointMgr.new = function(name)
          local obj = setmetatable(
              { waypoints = {}, name = name or "" },
              { __index = WaypointMgr }
          )
          return obj
      end


      return WaypointMgr


      end)

      package.preload['YFS-Tools:../util/stl.lua']=(function()

      --[[ Wolfe Labs Smart Template Library (STL)

      https://github.com/wolfe-labs/SmartTemplateLibrary

      (C) 2022 - Wolfe Labs ]]


      --- Helper function that generates a clean print statement of a certain string

      ---@param str string The string we need to show

      ---@return string

      local function mkPrint(str)

      return 'print(\'' .. str:gsub('\'', '\\\''):gsub('\n', '\\n') .. '\')'

      end


      --- Helper function that merges tables

      ---@vararg table

      ---@return table

      local function tMerge(...)

      local tables = {...}

      local result = {}

      for _, t in pairs(tables) do
          for k, v in pairs(t) do
          result[k] = v
          end
      end

      return result

      end


      --- Retrieves a certain line from a string

      ---@param str string The source string

      ---@param ln number The line number

      ---@return string|nil

      local function getLine(str, ln)

      local _ = 0

      for s in str:gmatch("([^\n]*)\n?") do
          _ = _ + 1
          if _ == ln then
          return s
          end
      end

      return nil

      end


      --- Trims a string

      ---@param str string The string being trimmed

      ---@return string

      local function trim(str)

      return str:gsub("^%s*(.-)%s*$", "%1")

      end


      ---@class Template

      local Template = {

      --- Globals available for every template by default

      globals = {
          math = math,
          table = table,
          string = string,
          ipairs = ipairs,
          pairs = pairs,
      }

      }


      -- Makes our template directly callable

      function Template.__call(self, ...)

      return Template.render(self, ({...})[1])

      end


      --- Renders our template

      ---@param vars table The variables to be used when rendering the template

      ---@return string

      function Template:render(vars)

      -- Safety check, vars MUST be a table or nil

      if type(vars or {}) ~= 'table' then
          error('Template parameters must be a table, got ' .. type(vars))
      end


      --- This is our return buffer

      local _ = {}


      -- Creates our environment

      local env = tMerge(Template.globals, self.globals or {}, vars or {}, {
          print = function (str) table.insert(_, tostring(str or '')) end,
      })


      -- Invokes our template

      self.callable(env)


      -- General trimming

      local result = table.concat(_, ''):gsub('%s+', ' ')


      -- Trims result

      result = result:sub(result:find('[^%s]') or 1):gsub('%s*$', '')


      -- Done

      return result

      end


      --- Creates a new template

      ---@param source string The code for your template

      ---@param globals table|nil Global variables to be used on on the template

      ---@param buildErrorHandler function|nil A function to handle build errors, if none is found throws an error

      ---@return Template

      function Template.new(source, globals, buildErrorHandler)

      -- Creates our instance

      local self = {
          source = source,
          globals = globals,
      }


      -- Yield function (mostly for games who limit executions per frame)

      local yield = (coroutine and coroutine.isyieldable() and coroutine.yield) or function () end


      -- Parses direct printing of variables, we'll convert a {{var}} into {% print(var) %}

      source = source:gsub('{{(.-)}}', '{%% print(%1) %%}')


      -- Ensures {% if %} ... {% else %} ... {% end %} stays on same line

      source = source:gsub('\n%s*{%%', '{%%')

      source = source:gsub('%%}\n', '%%}')


      --- This variable stores all our Lua "pieces"

      local tPieces = {}


      -- Parses actual Lua inside {% lua %} tags

      while #source > 0 do
          --- The start index of Lua tag
          local iLuaStart = source:find('{%%')

          --- The end index of Lua tag
          local iLuaEnd = source:find('%%}')

          -- Checks if we have a match
          if iLuaStart then
          -- Errors when not closing a tag
          if not iLuaEnd then
              error('Template error, missing Lua closing tag near: ' .. source:sub(0, 16))
          end

          --- The current text before Lua tag
          local currentText = source:sub(1, iLuaStart - 1)
          if #currentText then
              table.insert(tPieces, mkPrint(currentText))
          end

          --- Our Lua tag content
          local luaTagContent = source:sub(iLuaStart, iLuaEnd + 1):match('{%%(.-)%%}') or ''
          table.insert(tPieces, luaTagContent)

          -- Removes parsed content
          source = source:sub(iLuaEnd + 2)
          else
          -- Adds remaining Lua as a single print statement
          table.insert(tPieces, mkPrint(source))

          -- Marks content as parsed
          source = ''
          end

          -- Yields loading
          yield()
      end


      -- Builds the Lua function

      self.code = table.concat(tPieces, '\n')


      -- Builds our function and caches it, this is our template now

      local lua = string.format('return function (_) _ENV = _; _ = _ENV[_]\n%s\nend', self.code)

      local _, err = load(lua, nil, 't', {})

      if _ and not err then
          _ = _()
      end


      -- Checks for any errors

      if err then
          local _, ln, msg = err:match('^(.-):(%d+):(.+)')
          local nearSrc = getLine(self.source, ln - 1)
          local nearLua = getLine(self.code, ln - 1)

          local ex = {
          raw = err,
          line = ln - 1,
          near = trim(nearSrc or 'N/A'),
          nearLua = trim(nearLua or 'N/A'),
          message = trim(msg),
          }

          if buildErrorHandler then
          buildErrorHandler(self, ex)
          else
          error(('Failed compiling template!\nError: %s\nLine: %d\nNear: %s\nCode: %s'):format(ex.message, ex.line, ex.near, ex.nearLua))
          end

          -- Retuns an invalid instance
          return nil
      else
          -- If everything passed, assigns our callable to our compiled function
          self.callable = _
      end


      -- Initializes our instance

      return setmetatable(self, Template)

      end


      -- By default, returns the constructor of our class

      return Template.new

      end)

      package.preload['YFS-Tools:../util/wolfeCentralpoint.lua']=(function()

      -- Requires vec3

      -- Author: Matt / Wolfe Labs (@wolf_br), commissioned by tobitege (@tobitege)


      local msqrt = math.sqrt


      ---@comment Gets the central point for an ARRAY(!) of waypoints; nil if invalid params or empty array.

      ---@param waypoints table with array of waypoints

      ---@param useCentroid boolean|nil optional; default: nil (or false)

      ---@return vec3|nil The vec3 of the center location (or nil)

      function GetCentralPoint(waypoints, useCentroid)
          if type(waypoints) ~= "table" or #waypoints == 0 then return nil end
          if #waypoints == 1 then
            -- If we only have a single point, return it
              return waypoints[1]
          elseif #waypoints == 2 then
              -- For two points, we only need an average, no problem either
              return (vec3(waypoints[1]) + vec3(waypoints[2])) / 2
          end

          -- Base weight for averaging
          local base_weight = 1 / #waypoints

          -- Calculates the centroid position
          local centroid = vec3(0, 0, 0)
          for _, waypoint in pairs(waypoints) do
              centroid = centroid + vec3(waypoint) * base_weight
          end

          -- Use the centroid as the center, unless the option says otherwise
          local center = centroid

          -- Note to self: in the lines below math.sqrt(2) has been used to improve the center location.
          -- This number seems to have worked best as an exponent for the distances, but I'm not sure why.
          -- This is probably worth investigating at some point.

          -- If we aren't using the centroid, we'll use it along with the distance of all other points to estimate a new center
          if not useCentroid then
              -- Calculates the average distances for the centroid
              local avg_distance = 0
              for _, waypoint in pairs(waypoints) do
                  avg_distance = avg_distance + base_weight * (vec3(waypoint) - center):len() ^ msqrt(2)
              end

              -- Now we try to get closer to center
              local center_accumulator = vec3(0, 0, 0)
              for _, waypoint in pairs(waypoints) do
                  local point = vec3(waypoint)
                  local distance = (point - center):len() ^ msqrt(2)
                  local weight = distance / avg_distance
                  center_accumulator = center_accumulator + point * base_weight * weight
              end

              -- Sets new value for the center
              center = center_accumulator
          end

          return center
      end

      end)

      package.preload['YFS-Tools:libmain.lua']=(function()

      -- require used classes and instantiate important ones

      SU = require('YFS-Tools:../util/SU.lua') -- string utils

      Out = require('YFS-Tools:../util/out.lua') -- output utils

      P = Out.PrintLines

      E = Out.Error


      require('YFS-Tools:../util/Dtbk.lua') -- databank


      require('YFS-Tools:libutils.lua') -- helper functions

      Cmd = require('YFS-Tools:commands.lua') -- all YFS Tools commands

      Help = require('YFS-Tools:help.lua') -- help utils


      require('YFS-Tools:warpcost.lua') -- warp calculator function


      require('YFS-Tools:../util/wpoint.lua') -- waypoint class

      WM = require('YFS-Tools:../util/wpointmgr.lua').new("MAIN") -- instantiate MAIN waypoint manager


      WaypointInfo = require('atlas')


      STL = require('YFS-Tools:../util/stl.lua') -- determine central point among array of waypoints

      require('YFS-Tools:../util/wolfeCentralpoint.lua') -- determine central point among array of waypoints

      -- if not INGAME then

      --     WolfeCenterPointRS = 'vec2 = vec2 or require(\'cpml.vec2\')\nvec3 = vec3 or require(\'cpml.vec3\')\n\n--------------------------------------\n-- Configuration\n--------------------------------------\n\n-- Pulls upstream config\nlocal config = data.config or {}\n\n-- How large each dot is\nlocal dot_size = 2\n\n-- How many meters from center to screen edge\nlocal screen_radius = config.screen_radius or 3000\n\n-- The grid circles\nlocal grid_size = config.grid_size or 500\n\n-- Colors to be used\nlocal colors = {\n  background = { 0.1, 0.1, 0.1 },\n  overlay = { 0, 0, 0, 0.5 },\n  guides = {\n    main = { 0, 0.5, 1.5, 0.2 },\n    secondary = { 0, 0.5, 1.5, 0.15 },\n  },\n  center = { 0, 2, 1 },\n  points = { 0, 2, 2 },\n  messages = { 0.6, 0.6, 0.6 },\n}\n\n-- Spacing\nlocal spacing = { 8, 8 }\n\n-- Font to be used\nlocal fonts = {\n  title = loadFont(\'Oxanium\', 30),\n  main = loadFont(\'Oxanium\', 24),\n  sub = loadFont(\'Oxanium\', 15),\n}\n\n--------------------------------------\n-- Helpers\n--------------------------------------\n\nlocal screen_width, screen_height = getResolution()\nlocal cursor = vec2(getCursor())\n\n-- How close to detect hover\nlocal proximity_distance = 0.02 * screen_height\n\n-- Helper function to convert color tables\nlocal function rgba(color)\n  return color[1], color[2], color[3], color[4] or 1\nend\n\n-- Draws a small dot\nlocal function draw_dot(layer, x, y, color, hover_handler, click_handler)\n  setNextFillColor(layer, rgba(color))\n  addCircle(layer, x, y, dot_size)\n\n  local is_hovering = (vec2(x, y) - cursor):len() <= proximity_distance\n\n  if hover_handler and is_hovering then\n    hover_handler()\n  end\n\n  if click_handler and is_hovering and getCursorReleased() then\n    click_handler()\n  end\nend\n\n-- Draws a circle\nlocal function draw_circle(layer, x, y, radius, color)\n  setNextStrokeWidth(layer, 1)\n  setNextStrokeColor(layer, rgba(color))\n  setNextFillColor(layer, rgba({ 0, 0, 0, 0 }))\n  addCircle(layer, x, y, radius)\nend\n\n-- Draws line\nlocal function draw_line(layer, x1, y1, x2, y2, color)\n  setNextStrokeColor(layer, rgba(color))\n  addLine(layer, x1, y1, x2, y2)\nend\n\n-- Draws an overlay\nlocal function draw_overlay(layer)\n  setNextFillColor(layer, rgba(colors.overlay))\n  addBox(layer, 0, 0, screen_width, screen_height)\nend\n\n-- Draws info box\nlocal function draw_info_box(layer, x, y, title, rows, color)\n  draw_line(layer, x, y, x + 150, y, color)\n\n  if title then\n    setNextFillColor(layer, rgba(color))\n    setNextTextAlign(layer, AlignH_Left, AlignV_Bottom)\n    addText(layer, fonts.sub, tostring(title), x + spacing[1], y - spacing[1])\n  end\n\n  local next_x = x + spacing[1]\n  local next_y = y + spacing[2]\n  for _, row in pairs(rows) do\n    local text = row\n    local font = fonts.main\n    if \'table\' == type(row) then\n      font = fonts[row[1]]\n      text = row[2]\n    end\n    local font_size = getFontSize(font)\n\n    setNextFillColor(layer, rgba(color))\n    setNextTextAlign(layer, AlignH_Left, AlignV_Top)\n    addText(layer, font, tostring(text), next_x, next_y)\n    next_y = next_y + font_size\n  end\nend\n\n-- Draws cursor\nlocal function draw_cursor(layer)\n  local cursor_size = 16\n  local x, y = cursor:unpack()\n\n  if x and y and x + y > 0 then\n    setNextShadow(layer, 0.25 * cursor_size, 0, 0, 0, 1)\n    setNextFillColor(layer, 1, 1, 1, 1)\n    addQuad(\n      layer,\n      x, y,\n      x + cursor_size, y + 0.5 * cursor_size,\n      x + 0.5 * cursor_size, y + 0.5 * cursor_size,\n      x + 0.5 * cursor_size, y + cursor_size\n    )\n  end\nend\n\n--------------------------------------\n-- Main render logic\n--------------------------------------\n\nsetBackgroundColor(rgba(colors.background))\n\n-- Pre-calculate center of screen\nlocal screen_center_x, screen_center_y = 0.5 * screen_width, 0.5 * screen_height\n\n-- Check if we have data\nif not data.is_activated then\n  -- Offline mode\n  local layer = createLayer()\n\n  setNextTextAlign(layer, AlignH_Center, AlignV_Bottom)\n  setNextFillColor(layer, rgba(colors.messages))\n  addText(layer, fonts.title, \'SCRIPT OFFLINE\', screen_center_x, screen_center_y - 0.5 * spacing[2])\n\n  setNextTextAlign(layer, AlignH_Center, AlignV_Top)\n  setNextFillColor(layer, rgba(colors.messages))\n  addText(layer, fonts.sub, \'activate programming board to start\', screen_center_x, screen_center_y + 0.5 * spacing[2])\nelseif not data.waypoints then\n  -- Waiting on input\n  local layer = createLayer()\n\n  setNextTextAlign(layer, AlignH_Center, AlignV_Bottom)\n  setNextFillColor(layer, rgba(colors.messages))\n  addText(layer, fonts.title, \'AWAITING INPUT\', screen_center_x, screen_center_y - 0.5 * spacing[2])\n\n  setNextTextAlign(layer, AlignH_Center, AlignV_Top)\n  setNextFillColor(layer, rgba(colors.messages))\n  addText(layer, fonts.sub, \'input your first coordinate in the Lua chat to start\', screen_center_x, screen_center_y + 0.5 * spacing[2])\nelse\n  -- Normal operation\n  local center_body, center_world = data.center.body, vec3(data.center.world)\n\n  -- Intializes render script\n  local layer_background, layer_data, layer_overlay, layer_info, layer_cursor = createLayer(), createLayer(), createLayer(), createLayer(), createLayer()\n\n  -- Cursor\n  draw_cursor(layer_cursor)\n\n  -- Half screen size\n  local screen_radius_pixels = screen_center_y\n\n  -- Renders guides\n  for radius = grid_size, screen_radius, grid_size do\n    local pixel_radius = screen_radius_pixels * radius / screen_radius\n    local color = colors.guides.secondary\n    if radius % 1000 == 0 then\n      color = colors.guides.main\n    end\n\n    draw_circle(layer_background, screen_center_x, screen_center_y, pixel_radius, color)\n\n    setNextFillColor(layer_background, rgba(color))\n    setNextTextAlign(layer_background, AlignH_Center, AlignV_Top)\n    addText(layer_background, fonts.sub, radius .. \'m\', screen_center_x, screen_center_y + pixel_radius + 0.5 * spacing[2])\n  end\n\n  -- Renders center dot\n  draw_dot(layer_data, screen_center_x, screen_center_y, colors.center, function()\n    draw_circle(layer_info, screen_center_x, screen_center_y, proximity_distance, colors.center)\n    draw_overlay(layer_overlay)\n    draw_info_box(layer_info, screen_center_x + proximity_distance, screen_center_y, nil, {\n      \'center point\',\n      { \'sub\', \'click to set waypoint\' },\n    }, colors.center)\n  end, function()\n    -- Sets waypoint on click\n    setOutput((\'{%s,%s,%s}\'):format(center_world:unpack()))\n  end)\n\n  -- Renders waypoints\n  for _, waypoint in pairs(data.waypoints or {}) do\n    local lat, lng = waypoint.body.lat - center_body.lat, waypoint.body.lng - center_body.lng\n\n    local offset = vec2(lng, lat * -1)\n    local distance = (vec3(waypoint.world) - center_world):len()\n\n    -- Don\'t render anything outside screen\n    if distance <= screen_radius then\n      -- Calculates pixel position\n      local pixel = vec2(0.5 * screen_width, 0.5 * screen_height) + offset:normalize() * screen_radius_pixels * distance / screen_radius\n\n      -- Draws point on "map"\n      draw_dot(layer_data, pixel.x, pixel.y, colors.points, function()\n        -- Draws extra info on hover\n        draw_circle(layer_info, pixel.x, pixel.y, proximity_distance, colors.points)\n        draw_overlay(layer_overlay)\n        draw_info_box(layer_info, pixel.x + proximity_distance, pixel.y, waypoint.label, {\n          (\'%.2fm\'):format(distance),\n          { \'sub\', \'click to set waypoint\' },\n        }, colors.points)\n      end, function()\n        -- Sets waypoint on click\n        setOutput((\'{%s,%s,%s}\'):format(vec3(waypoint.world):unpack()))\n      end)\n    end\n  end\n\n  requestAnimationFrame(1)\nend'

      -- end


      WolfAR = nil -- customized Wolf Labs' AR waypointing

      end)

      package.preload['YFS-Tools:../util/pos.lua']=(function()

      --- Class related to positions/coordinates like local/world conversion etc.

      --- requires global WaypointInfo table (= atlas), vec3 library; classes SU, Out

      local max, min, mcos, macos, mdeg, msin, mabs, mrad, matan, ceil, floor, mpi = math.max, math.min, math.cos, math.acos, math.deg, math.sin, math.abs, math.rad, math.atan, math.ceil, math.floor, math.pi

      local tonum, strlen, strmatch, sformat = tonumber, string.len, string.match, string.format

      local uclamp, vec3 = utils.clamp, vec3


      local o = {}

      o.__index = o

      function o.New(pCore, pConstruct, pWM)
          -- Private attribute
          local s = {
              core = pCore,
              construct = pConstruct,
              Alioth1G = 9.891,
              waypointNames = {},
              waypointCount = 0,
              planetNames = {},
              p = {}, -- Planet object
              pIdx = 0, -- Atlas planet index
              wm = pWM -- Waypoint Manager instance
          }

          local function float_eq(a, b) -- float equation
              if a == 0 then
                  return mabs(b) < 1e-09
              elseif b == 0 then
                  return mabs(a) < 1e-09
              else
                  return mabs(a - b) < math.max(mabs(a), mabs(b)) * epsilon
              end
          end

          ---@return boolean
          local function constructPresent()
              return s.construct ~= nil
          end

          ---@return boolean
          local function corePresent()
              return s.core ~= nil
          end

          -- Public functions

          ---@return number amount of warp cells
          function o.ComputeCells(distance, tons)
              return ceil(max(floor(tons*floor(((distance/1000)/200))*0.00024), 1))
          end

          ---@return string
          function o.GetPosPattern()
              local num = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'
              return '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' .. num ..  ',' .. num .. '}'
          end

          ---@return number # of entries in WaypointInfo/Atlas
          function o.GetWaypointCount()
              return s.wm:getCount()
          end

          ---@param posStr string ::pos{} string
          ---@return table|nil returns a MapPos table of the coords or nil if invalid string
          function o.SplitPos(posStr)
              -- min. length is 16: "::pos{0,1,2,3,4}"
              if type(posStr) ~= "string" then
                  P("[E] Invalid position: "..type(posStr))
                  return nil
              end
              if strlen(posStr) < 16 or not strmatch(posStr, "^::pos{") then
                  P("[E] Invalid position: "..posStr)
                  return nil
              end
              local sysId, pId, lat, lng, alt = strmatch(posStr, o.GetPosPattern())
              return { systemId  = tonum(sysId),
                       id        = tonum(pId),
                       latitude  = tonum(lat),
                       longitude = tonum(lng),
                       altitude  = tonum(alt) }
          end

          ---@param posString string The ::pos{} string in local coords!
          ---@return number Altitude in meters (if a local pos -> relative to sea level)
          function o.GetAltitudeFromPos(posString)
              local p = o.SplitPos(posStr)
              if p and p.altitude then return p.altitude end
              return 0
          end

          ---@param posStr string The ::pos{} string
          ---@return integer Id of planet in Atlas, e.g. 2 for Alioth; 0 for Space!
          function o.GetPlanetFromPos(posStr)
              local p = o.SplitPos(posStr)
              if p and p.id and p.id > 0 then return p.id end
              return 0
          end

          function o.GetAtlasPlanet(pid)
              if not pid or not WaypointInfo[0] or not WaypointInfo[0][tonum(pid)] then
                  return nil
              end
              return WaypointInfo[0][tonum(pid)]
          end

          function o.GetClosestPlanetId(worldPosVec)
              local pIdx, dist = 0, 0
              local planetDistance = math.huge
              for i,v in pairs(WaypointInfo[0]) do
                  dist = (worldPosVec - vec3(v.center)):len()
                  if dist < planetDistance then
                      planetDistance = dist
                      pIdx = i
                  end
              end
              return pIdx
          end

          function o.GetClosestPlanet(worldPosVec)
              local pid = o.GetClosestPlanetId(worldPosVec)
              return o.GetAtlasPlanet(pid)
          end

          function o.GetCurrentPosString()
              local v = o.WorldPosVec3()
              return o.MapPos2String(o.WorldToMapPos(v))
          end

          ---@comment Formats a MapPos table to a ::pos{} string
          ---@return string
          function o.MapPos2String(mapPos)
              if type(mapPos) ~= "table" then return "" end
              return '::pos{' .. (mapPos.systemId or 0).. ',' .. (mapPos.id or 0) .. ',' ..
                     sformat("%.4f", (mapPos.latitude or 0)) .. ',' ..
                     sformat("%.4f", (mapPos.longitude or 0)) ..  ',' ..
                     sformat("%.4f", (mapPos.altitude or 0)) .. '}'
          end

          ---@comment Formats a vec3 world-pos table to a ::pos{} string (planet id 0!)
          ---@return string
          function o.Vec3ToPosString(v3)
              if type(v3) ~= "table" then return "" end
              return '::pos{0,0,' ..
                     sformat("%.4f", (v3.x or 0)) .. ',' ..
                     sformat("%.4f", (v3.y or 0)) ..  ',' ..
                     sformat("%.4f", (v3.z or 0)) .. '}'
          end

          ---@comment Formats a vec3 world-pos table to a ::pos{} string (planet id 0!)
          ---@return string
          function o.Vec3String(v3)
              if type(v3) ~= "table" then return "" end
              v3 = vec3(v3)
              return sformat("%.4f", (v3.x or 0)) .. ', ' ..
                     sformat("%.4f", (v3.y or 0)) .. ', ' ..
                     sformat("%.4f", (v3.z or 0))
          end

          ---@param posStr string ::pos{} string for change
          ---@param newAltitude number? new altitude value
          ---@return string
          function o.ReplaceAltitudeInPos(posStr, newAltitude)
              --TODO: move this to Waypoint class; allow class as param
              local p = o.SplitPos(posStr)
              if not p or not p.altitude or not newAltitude then
                  return posStr
              end
              p.altitude = tonum(newAltitude)
              return o.MapPos2String(p)
          end

          ---@comment Returns current planet id if in game, otherwise 2
          ---@return number
          function o.PlanetId()
              if not corePresent() then return 0 end
              if not INGAME then
                  return 2 -- Alioth
              end
              return s.core.getCurrentPlanetId()
          end

          ---@comment If code is run outside of game, a fixed vec3 will be returned for testing!
          ---@return any Vec3 position of construct (or nil)
          function o.WorldPosVec3()
              if not INGAME then
                  return { x = -25140.37011013, y = 100812.26194182, z = -52412.710373821}
              end
              if constructPresent() then
                  ---@diagnostic disable-next-line: missing-parameter
                  return vec3(construct.getWorldPosition())
              end
              if corePresent() then
                  ---@diagnostic disable-next-line: missing-parameter
                  return vec3(core.getWorldPosition())
              end
              return nil
          end

          ---@comment If close to planet, returns the current altitude
          ---@return number Altitude in meters; 0 if not close to a planet!
          function o.Altitude()
              local p = o.GetAtlasPlanet(o.PlanetId())
              if not p or not p.center then return 0 end
              return (o.WorldPosVec3() - vec3(p.center)):len() - (p.radius or 0)
          end

          ---@comment Returns distance between
          --- a) current construct position and the one passed in
          ---   posStr (distTo not specified) in ::pos{0,x,...} format!
          --- OR
          --- b) both params specified, each separate coords.
          ---@param posStr string ::pos() string to measure FROM
          ---@param distTo nil optional ::pos() to measure TO; if empty -> current position
          ---@return number
          function o.GetDistance(posStr, distToStr)
              local curPos = o.WorldPosVec3()
              if type(distToStr) == "string" then
                  curPos = o.MapPosToWorldVec3(distToStr)
              elseif type(distToStr) == "table" then
                  curPos = vec3(distToStr)
              end
              local wPos = o.MapPosToWorldVec3(posStr)
              local dist = vec3(wPos - curPos):len()
              return dist
          end

          ---@comment experimental/unused; credit to Jeronimo
          ---@return number,number,number with x,y,z
          function o.World2local(x,y,z)
              --if not o.construct then return 0,0,0 end
              local cWOUP = s.construct.getWorldOrientationUp()
              local cWOF = s.construct.getWorldOrientationForward()
              local cWOR = s.construct.getWorldOrientationRight()
              local cWOUPx, cWOUPy, cWOUPz = cWOUP[1], cWOUP[2], cWOUP[3]
              local cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]
              local cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]

              local v = library.systemResolution3(
                  {cWORx,  cWORy, cWORz},
                  {cWOFx,  cWOFy, cWOFz},
                  {cWOUPx, cWOUPy, cWOUPz},
                  {x, y, z})
              return v[1],v[2],v[3]
          end

          ---@comment Converts a latitude, longitude, altitude pair into a world X, Y, Z
          --- Source: https://gis.stackexchange.com/a/4148
          ---@param celestial_body table
          ---@param latitude number
          ---@param longitude number
          ---@param altitude number
          ---@return vec3|nil
          function o.WorldPosFromBody(celestial_body, latitude, longitude, altitude)
              if type(celestial_body) ~= "table" then return nil end
              local radius = altitude + (celestial_body.radius or 0)
              local phi, theta = mrad(latitude), mrad(longitude)
              local pcos = mcos(phi)
              local offset = vec3(pcos * mcos(theta), pcos * msin(theta), msin(phi))
              -- Adds planet center and offset
              return vec3(celestial_body.center) + offset * radius
          end

          ---@comment Gets a mappos from a world position
          ---@param celestial_body table
          ---@param position vec3
          ---@return table
          function o.BodyPosFromWorldPos(body, position)
              -- We need to extract the "local" coordinate (offset from planet center) here and then normalize it to do math with it
              local offset = position - vec3(body.center)
              local offset_normalized = offset:normalize()

              return {
                  systemId  = body.systemId,
                  id        = body.id,
                  latitude  = 90 - (macos(offset_normalized.z) * 180 / mpi),
                  longitude = matan(offset_normalized.y, offset_normalized.x) / mpi * 180,
                  altitude  = offset:len() - body.radius
              }
          end

          ---@param v table the vec3() position to convert
          ---@return any MapPos table or nil
          function o.WorldToMapPos(v)
              local body = o.GetClosestPlanet(v)
              if not body or not body.center or not body.radius then
                  return { systemId = 0, id = 0, latitude = v.x, longitude = v.y, altitude = v.z }
              end
              return o.BodyPosFromWorldPos(body, v)
          end

          function o.PlanetByName(name)
              if type(name) ~= "string" or name == "" then return nil end
              name = name:lower()
              if s.planetNames[name] then
                  local pid = tonum(s.planetNames[name])
                  return WaypointInfo[0][pid]
              end
              return nil
          end

          ---comment Converts ::pos{} string into a vec3
          ---@param posStr string ::pos{} string
          ---@return vec3|nil
          function o.MapPosToWorldVec3(posStr)
              local p = o.SplitPos(posStr)
              if not p or not p.systemId then return nil end
              if (p.systemId == 0 and p.id == 0) then -- already WorldPos
                  return vec3(p.latitude, p.longitude, p.altitude)
              end
              if not WaypointInfo[p.systemId] then return nil end
              local planet = WaypointInfo[p.systemId][p.id]
              --credits to Saga for lat/lon calc
              -- constants.deg2rad
              local lat = 0.0174532925199 * max(min(p.latitude, 90), -90)
              local lon = 0.0174532925199 * (p.longitude % 360)
              local xproj = mcos(lat)
              local planetxyz = vec3(xproj*mcos(lon), xproj*msin(lon), msin(lat))
              return vec3(planet.center) + (planet.radius + p.altitude) * planetxyz
          end

          function o.PlanetInfo(id)
              local pid = nil
              if type(id) == "string" and id:len() == 0 then
                  id = o.GetClosestPlanetId(o.WorldPosVec3())
              end
              if type(id) == "string" and s.planetNames[id:lower()] then -- id as planet name
                  pid = tonum(s.planetNames[id:lower()])
              elseif type(id) == "string" and tonum(id) > 0 then -- id as planet id
                  pid = tonum(id)
              end
              if pid == nil then
                  return E("[E] No valid planet name or id specified!")
              end
              local p = o.GetAtlasPlanet(pid)
              if not p or type(p.name) ~= "table" then
                  return E("[E] No planet found!")
              end
              P"~~~~~~~~ PLANET INFO ~~~~~~~~"
              if id == '' then
                P("Hint: '/planetInfo 2' for Alioth")
              end
              P("Name: "..p.name[1].." (Id: ".. p.id ..")")
              P("Center: "..p.center[1].." / "..p.center[2].." / "..p.center[3])
              P("Radius: "..(p.radius or 0).."m")
              local tmp = ""
              if p.gravity and p.gravity > 0 then
                  tmp = " ("..sformat("%.1f", (p.gravity / s.Alioth1G)) .." g)"
              end
              P("Gravity: "..(p.gravity or 0)..tmp)
              if p.satellites and #p.satellites > 0 then
                P("Has Moons: "..#p.satellites)
              end
              P("Surface Min Alt.: "..(p.surfaceMinAltitude or 0).."m")
              P("Surface Max Alt.: "..(p.surfaceMaxAltitude or 0).."m")
              P("Max Static Alt.: "..(p.maxStaticAltitude or "").."m")
              P("Has atmosphere: "..BoolStr(p.hasAtmosphere))
              if p.hasAtmosphere then
                P("Atmo Thickness: "..(p.atmosphereThickness or 0).."m")
                P("Atmo altitude: "..(p.atmoAltitude or 0).."m")
                P("Atmo 10%: "..(p.atmo10 or 0).."m")
              end
              P("Is in Safe Zone: "..BoolStr(p.isInSafeZone))
              P"~~~~~~~~~~~~~~~~~~~~~~~~~~~"
          end

          ---@comment Adds a named waypoint to the internal list.
          --- Source position string can be local or world position.
          --- World position will be converted to local and ::pos{}
          --- changed accordingly - IF a closest body was in range.
          ---@param posString string Local or world ::pos{} string
          ---@param wpName string Name of the newly named waypoint
          ---@return boolean true if added else false
          function o.CreateWaypoint(posString, wpName)
              if not s.wm or not wpName or wpName == '' or s.waypointNames[wpName] then
                  return false
              end

              -- convert between local and world pos if needed
              local p = o.SplitPos(posString)
              if not p or not p.systemId then return false end

              -- if world pos, try to determine planet
              if p.id == 0 then
                  local w = o.WorldToMapPos(vec3{ p.latitude, p.longitude, p.altitude })
                  if w and w.id and w.id > 0 then
                      -- update pos with converted values
                      p.latitude  = w.latitude
                      p.longitude = w.longitude
                      p.altitude  = w.altitude
                      p.id        = w.id
                      p.systemId  = w.systemId
                      posString = o.MapPos2String(p)
                  end
              end

              -- add waypoint to waypoint manager
              local wp = Waypoint:new(s.wm):setName(wpName):set(posString)
              if not wp or wp == {} then return false end
              if s.wm:exists(wp) then return false end
              return s.wm:add(wp)
          end

          ---@comment Simple test for coord conversion
          function o.ConversionTest()
              local p1 = "::pos{0,2,35.5118,104.0375,285.3076}"
              local w1 = o.MapPosToWorldVec3(p1)
              P("HQ local to world:\n"..p1.." =")
              P(o.Vec3ToPosString(w1))
              local w2 = o.WorldToMapPos(w1)
              Out.DeepPrint(w2)
              P("World to local (should show same as above):")
              P(o.MapPos2String(w2))

              local wp = "::pos{0,0,-24955.2183,99771.5731,-52908.1353}"
              if o.CreateWaypoint(wp, "WorldPos") then
                P("Added 'WorldPos' waypoint")
              else
                P("Failed to add test waypoint!")
              end
          end

          local function init()
              s.pIdx = 0
              s.p = o.GetAtlasPlanet(o.PlanetId())
              if s.p then s.pIdx = s.p.id end
              if not WaypointInfo[0] then return end
              s.planetNames = {}
              for i, v in pairs(WaypointInfo[0]) do
                  s.planetNames[v.name[1]:lower()] = i
                  -- remove junk
                  WaypointInfo[0][i].biosphere = nil
                  WaypointInfo[0][i].classification = nil
                  WaypointInfo[0][i].description = nil
                  WaypointInfo[0][i].habitability = nil
                  WaypointInfo[0][i].ores = nil
                  -- new props
                  WaypointInfo[0][i].centerV3 = vec3(WaypointInfo[0][i].center)
                  if v.hasAtmosphere then
                      local res = v.atmosphereRadius - v.radius
                      WaypointInfo[0][i].atmoAltitude = res
                      WaypointInfo[0][i].atmo10 = res * 0.9
                  end
                  WaypointInfo[0][i].isAsteroid = WaypointInfo[0][i].type[1] == "Asteroid"
                  WaypointInfo[0][i].isMoon = WaypointInfo[0][i].type[1] == "Moon"
                  WaypointInfo[0][i].isPlanet = WaypointInfo[0][i].type[1] == "Planet"
              end

              if s.wm then
                  P("[I] WaypointMgr assigned: "..s.wm:getName())
              else
                  P("[E] NO WaypointMgr assigned!")
              end
          end

          init()
          return setmetatable(s, o)
      end -- .New


      return o

      end)

      package.preload['YFS-Tools:startup.lua']=(function()

      local uclamp = utils.clamp


      local onlyForRoute=""--export: Load waypoints only for this route (enclosed in double quotes!); default "".

      local onlySelectableWP=true--export: Check to only display custom route waypoints that are marked as selectable

      local loadWaypoints=true--export: Enable to load custom waypoints from databank

      local outputFont="FiraMono"--export: Name of font used for screen output. Default: "FiraMono"

      --local centerMaxDistance=5000--export: The furthest distance a point should be displayed on-screen in meters (1000..10000; default: 5000)

      --local centerHelperCirclesEvery=1000--export: Show grid circles every X meters (100..2000; default: 1000)


      onlyForRoute = onlyForRoute or ""

      OutputFont = outputFont or "FiraMono" -- used in libutils.lua


      -- for new centerpoint mod

      --CenterMaxDistance = centerMaxDistance or 5000

      --CenterMaxDistance = uclamp(centerMaxDistance, 1000, 10000)

      --CenterHelperCirclesEvery = centerHelperCirclesEvery or 1000

      --CenterHelperCirclesEvery = uclamp(centerHelperCirclesEvery, 100, 2000)


      P("=========================================")

      P("YFS-Tools 1.7.6 (unofficial)")

      P("created by tobitege (c) 2023")

      P("Thanks to Yoarii (SVEA) for YFS and LUA help!")

      P("YFS 1.4+ databank link required (Routes).")

      P("=========================================")

      P("* WARNING: do not run commands that change")

      P("* waypoints/routes while YFS is running!")

      P("=========================================")

      P("LUA parameter(s):")

      P("Load waypoints from databank: " .. BoolStr(loadWaypoints))

      P("Only waypoints for route: " .. onlyForRoute)

      P("Only selectable waypoints: " .. BoolStr(onlySelectableWP))

      P("Screen output font name: " .. OutputFont)

      P("=========================================")


      local status, err = false, nil

      if INGAME then
          status, err, _ = xpcall(function()
              Config.core = library.getCoreUnit()
              Config.databanks = library.getLinksByClass('DataBank', true) -- true is important!
              Config.screens = library.getLinksByClass('Screen', true)
          end, Traceback)
          if not status then
              P("Error in Link Detection:\n" .. err)
              unit.exit()
              return
          end
      else
          -- this requires du-mocks!
          Config.core = unit.core
          Config.databanks =  { unit.databank }
          Config.screens =  { unit.screen }
      end


      if Config.core == nil then
          P("[E] No Core connected! Ending script.")
          unit.exit()
          return
      end


      PM = require('YFS-Tools:../util/pos.lua').New(Config.core, construct, WM) -- Positions and waypoint management


      if #Config.databanks > 0 then
          local plural = ""
          if #Config.databanks > 1 then plural = "s" else plural = " '"..Config.databanks[1].getName().."'" end
          P(#Config.databanks .. " databank" .. plural .. " connected.")
      else
          P("[E] DataBank not found.")
      end


      if #Config.screens > 0 then
          local plural = ""
          if #Config.screens > 1 then plural = "s" end
          P(#Config.screens .. " screen" .. plural .. " connected.")
      end


      -- optionally load waypoints from databank (ArchHUD or YFS)

      if loadWaypoints ~= true or #Config.databanks == 0 then
          P("[I] Waypoints loading is off.")
          return
      end


      -- for local debugging, see mockaround file for demo data!

      if not INGAME then
          onlyForRoute = "Garni"
      end


      local prevCount = 0

      for ix=1, #Config.databanks, 1 do
          ---@diagnostic disable-next-line: assign-type-mismatch
          local db = Config.databanks[ix] ---@type table DataBank
          P("===== Checking db '"..db.getName().."' =====")
          if db.hasKey(ARCH_SAVED_LOCATIONS) then
              P('ArchHud databank detected.')
              DetectedArch = ix
              local names = db.getStringValue(ARCH_SAVED_LOCATIONS)
              if names ~= "" then
                  P('Searching stored locations...')
                  local locations = json.decode(names)
                  if IsTable(locations) then
                      Cmd.GetStoredLocations(locations)
                  end
              end
          end
          if db.hasKey(YFS_ROUTES) or db.hasKey(YFS_NAMED_POINTS) then
              P('YFS databank detected.')
              YFSDB = Dtbk.new(db)
              DetectedYFS = true
              if not onlySelectableWP then
                  Cmd.YFSLoadNamedWaypoints()
              end
              Cmd.YFSLoadRoutepoints(onlySelectableWP, onlyForRoute)
          end
          local count = PM.GetWaypointCount()
          if count == prevCount then
              P("[I] No waypoints loaded from db "..ix)
          else
              P("[I] "..(count - prevCount).." waypoints loaded from db "..ix)
          end
          prevCount = PM.GetWaypointCount()
      end

      P("=======================")

      if PM.GetWaypointCount() > 0 then
          P("[I] Total "..PM.GetWaypointCount().." waypoints loaded.")
      else
          P("[I] No waypoints loaded.")
      end

      P("=======================")

      end)

      package.preload['YFS-Tools:sys_onInputText.lua']=(function()

      -- requires utils, global instances Cmd, SU


      local inputTextFunc = {}


      function inputTextFunc.Run(t)
          t = SU.Trim(t)
          if not SU.StartsWith(t, "/") then return end
          if not Cmd then
              return E("[FATAL ERROR] Commands processor not assigned!")
          end
          local cmdList = {}
          cmdList['arch-save-named'] = 1
          cmdList['conversionTest'] = 1
          cmdList['findCenter'] = 1
          cmdList['posData'] = 1
          cmdList['help'] = 'Help'
          cmdList['planetInfo'] = 1
          cmdList['printAltitude'] = 1
          cmdList['printPos'] = 1
          cmdList['printWorldPos'] = 1
          cmdList['warpCost'] = 1
          cmdList['wp-altitude-ceiling'] = 1
          cmdList['wp-export'] = 1
          cmdList['yfs-add-altitude-wp'] = 1
          cmdList['yfs-build-route-from-wp'] = 1
          cmdList['yfs-save-named'] = 1
          cmdList['yfs-save-route'] = 1
          cmdList['yfs-replace-wp'] = 1
          cmdList['yfs-route-altitude'] = 1
          cmdList['yfs-route-nearest'] = 1
          cmdList['yfs-options-reset'] = 1
          cmdList['yfs-route-to-named'] = 1
          cmdList['yfs-wp-altitude'] = 1
          cmdList['DumpRoutes'] = 1
          cmdList['DumpPoints'] = 1
          cmdList['routes'] = 1
          if DEBUG then
              cmdList['YfsTestData'] = 1
              cmdList['x'] = 1
          end

          for k, func in pairs(cmdList) do
              if SU.StartsWith(t, "/"..k) then
                  local params = t:sub(k:len()+2) or ""
                  params = SU.Trim(params)
                  if k == 'help' then -- special case
                      k = "PrintHelp"
                  end
                  -- map command to function name, which must end with "Cmd"!
                  local fn = SU.SplitAndCapitalize(k,'-').."Cmd"
                  -- default use global Cmd class, unless a value is specified other than 1
                  local cmdName = SU.If(type(func) == "string", func, "Cmd")
                  P("Executing /"..k..SU.If(params ~= "", " with: "..params))
                  if not _G[cmdName] then
                      return E("[FATAL ERROR] "..cmdName.." not found!")
                  end
                  if _G[cmdName][fn] then
                      return _G[cmdName][fn](params)
                  end
              end
          end
          P("~~~~~~~~~~~~~~~~~~~~~")
          P("[E] Unknown command: "..t)
          P("[I] Supported commands:")
          for _,fn in ipairs(GetSortedAssocKeys(cmdList)) do
             P("/"..fn)
          end
      end


      return inputTextFunc

      end)
  - key: 4
    filter:
      slotKey: -5
      signature: onStart()
      args: []
    code: |-
      library.addEventHandlers(library)
      library.addEventHandlers(system)
      library.addEventHandlers(player)
      library.addEventHandlers(construct)
      library.addEventHandlers(unit)
  - key: 5
    filter:
      slotKey: -4
      signature: onActionStart(action)
      args:
        - variable: "*"
    code: system:triggerEvent('onActionStart',action)
  - key: 6
    filter:
      slotKey: -4
      signature: onActionLoop(action)
      args:
        - variable: "*"
    code: system:triggerEvent('onActionLoop',action)
  - key: 7
    filter:
      slotKey: -4
      signature: onActionStop(action)
      args:
        - variable: "*"
    code: system:triggerEvent('onActionStop',action)
  - key: 8
    filter:
      slotKey: -4
      signature: onUpdate()
      args: []
    code: system:triggerEvent('onUpdate')
  - key: 9
    filter:
      slotKey: -4
      signature: onFlush()
      args: []
    code: system:triggerEvent('onFlush')
  - key: 10
    filter:
      slotKey: -4
      signature: onInputText(text)
      args:
        - variable: "*"
    code: system:triggerEvent('onInputText',text)
  - key: 11
    filter:
      slotKey: -4
      signature: onCameraChanged(mode)
      args:
        - variable: "*"
    code: system:triggerEvent('onCameraChanged',mode)
  - key: 12
    filter:
      slotKey: -3
      signature: onParentChanged(oldId,newId)
      args:
        - variable: "*"
        - variable: "*"
    code: player:triggerEvent('onParentChanged',oldId,newId)
  - key: 13
    filter:
      slotKey: -2
      signature: onDocked(id)
      args:
        - variable: "*"
    code: construct:triggerEvent('onDocked',id)
  - key: 14
    filter:
      slotKey: -2
      signature: onUndocked(id)
      args:
        - variable: "*"
    code: construct:triggerEvent('onUndocked',id)
  - key: 15
    filter:
      slotKey: -2
      signature: onPlayerBoarded(id)
      args:
        - variable: "*"
    code: construct:triggerEvent('onPlayerBoarded',id)
  - key: 16
    filter:
      slotKey: -2
      signature: onVRStationEntered(id)
      args:
        - variable: "*"
    code: construct:triggerEvent('onVRStationEntered',id)
  - key: 17
    filter:
      slotKey: -2
      signature: onConstructDocked(id)
      args:
        - variable: "*"
    code: construct:triggerEvent('onConstructDocked',id)
  - key: 18
    filter:
      slotKey: -2
      signature: onPvPTimer(active)
      args:
        - variable: "*"
    code: construct:triggerEvent('onPvPTimer',active)
  - key: 19
    filter:
      slotKey: -1
      signature: onStop()
      args: []
    code: unit:triggerEvent('onStop')
  - key: 20
    filter:
      slotKey: -1
      signature: onTimer(timerId)
      args:
        - variable: "*"
    code: unit:triggerEvent('onTimer',timerId)
  - key: 21
    filter:
      slotKey: -1
      signature: onStart()
      args: []
    code: >-
      

      -- Important for local debugging:

      package.path = "lua/?.lua;util/wpointer/?.lua;"..package.path

      require('YFS-Tools:globals.lua')


      -- DU-LuaC checks for true are last, so that local debugging sees true!

      --WP_EG_ENABLED = true


      WP_WOLF_ENABLED = true


      DEBUG = false

      require('YFS-Tools:libmain.lua')


      if INGAME then
          local Traceback = traceback
      else
          function Traceback(o)
              if o then P(tostring(o)) end
          end
          require 'mockaround'
      end


      local status, err, _ = xpcall(function() require('YFS-Tools:startup.lua') end, Traceback)

      if not status then
          P("[E] Error in startup!")
          if err then P(err) end
          unit.exit()
          return
      end


      local inp = require('YFS-Tools:sys_onInputText.lua')

      if inp ~= nil then
          system:onEvent('onInputText', function (self, text) inp.Run(text) end)
      end






      if not WP_EG_ENABLED and not WP_WOLF_ENABLED then
          P('[I] Waypointer module disabled.')
      else
          P('[I] Waypointer module enabled.')

          unit.setTimer("update", 1/120) -- The timer to update the screen
          system.showScreen(1)
      end


      if INGAME then
          if DEBUGx then
              status, err, _ = xpcall(function() PM.ConversionTest() end, Traceback)
              if not status then
                  if err then P("[E] Error in test call:\n" .. err) end
                  unit.exit()
                  return
              end
          else
              unit.hideWidget()
          end
          P("Type /help for available commands.")

      end
events: []
methods: []
