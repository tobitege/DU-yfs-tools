{"slots":{"-5":{"name":"library","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}}},"handlers":[{"key":1,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":";(function()\nlocal a={}local b=0;function library.addEventHandlers(c)if not c or c.onEvent and c.triggerEvent then return false end;b=b+1;a[b]=c;local d,e,f='table','function','thread'if d~=type(c)then error('You can only add event handlers to table objects!')end;local g={}local function h(c)local i=type(c)return e==i or d==i and h(getmetatable(c).__call)or f==i end;c.onEvent=function(self,j,k,l)if not h(k)then error('Event handler must be a function, a callable object or a thread!')end;l=l or self;if d~=type(l)then error('The value of self must be a table!')end;if not g[j]then g[j]={_=0}end;local m=f==type(k)and function(...)coroutine.resume(k,...)end or k;local k=g[j]local n=k._+1;k[n]={m,l}k._=n;return n end;c.clearEvent=function(self,j,o)if g[j]and g[j][o]then g[j][o]=nil end end;c.clearAllEvents=function(self)g={}end;c.triggerEvent=function(self,j,...)local p=g[j]if p then for q=1,p._ do local k=p[q]if k then k[1](k[2],...)end end end end;return true end;function library.clearAllEventHandlers()for q=1,b do local c=a[q]if c and c.clearAllEvents then c:clearAllEvents()end end end\nend)()"},{"key":2,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":";(function()\nlocal a=DULibrary or{}function a.getLinks(b,c)local d={}if not b then b={}end;for e,f in pairs(unit.getOutPlugs())do local g=unit[f.name]if'table'==type(g)and'function'==type(g.getClass)then local h=true;for i,j in pairs(b)do if not('function'==type(g[i])and j==g[i]():sub(1,#j))then h=false;break end end;if h then if c then table.insert(d,g)else d[f.name]=g end end end end;return d end;function a.getLinksByClass(k,c)return a.getLinks({getClass=k},c)end;function a.getLinkByClass(k)return a.getLinksByClass(k,true)[1]end;function a.getCoreUnit()return a.getLinkByClass('CoreUnit')end;function a.getLinkByName(l)local m=a.getCoreUnit()if not m then error('getLinkByName requires a linked CoreUnit to work')end;local d=a.getLinks()for n,o in pairs(d)do if l==m.getElementNameById(o.getLocalId())then return o end end end\nend)()"},{"key":3,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":"package.preload['YFS-Tools:globals.lua']=(function()\n---@diagnostic disable: lowercase-global\n-- Initialize globals and constants\nConfig = { core = nil, databanks = {}, screens = {} }\nDetectedArch = 0\nDetectedYFS = false\nYFSDB = nil\nYFS_NAMED_POINTS = \"NamedPoints\"\nYFS_ROUTES = \"NamedRoutes\"\nARCH_SAVED_LOCATIONS = \"SavedLocations\"\nDEBUG = false\nWAYPOINTER_ENABLED = true\nScriptStartTime = 0\nINGAME = system ~= nil\n\nif not INGAME then\n\nelse\n    ScriptStartTime = system.getArkTime()\n    print = system.print\nend\n\nprojector = nil\nclicked = false -- for waypointer\n\nWaypointInfo = require('atlas')\n\nCNID = construct.getId()\nend)\npackage.preload['YFS-Tools:../util/SU.lua']=(function()\nlocal SU = {}\n\nlocal strmatch, strlen, tonum = string.match, string.len, tonumber\n\n---@comment Returns s being trimmed of any whitespace from both start and end.\n---@param s string\n---@return string\nfunction SU.Trim(s)\n    if strlen(s) == 0 then return \"\" end\n    return SU.Ltrim(SU.Rtrim(s))\nend\n\n---@comment Returns s being trimmed of any whitespace from the start.\n---@param s string\n---@return string\nfunction SU.Ltrim(s)\n    local res, _ = string.gsub(s, \"^%s+\", \"\")\n    return res\nend\n\n---@comment Returns s being trimmed of any whitespace from the end.\n---@param s string\n---@return string\nfunction SU.Rtrim(s)\n    local res, _ = string.gsub(s, \"%s+$\", \"\")\n    return res\nend\n\nfunction SU.Pad(s, padChar, length)\n    if not s or not length or not padChar or tonum(length) < 1 then return s end\n    return string.rep(padChar, length - s:len()) .. s\nend\n\n---@param s string\n---@param prefix string\n---@return boolean\nfunction SU.StartsWith(s, prefix)\n    if not s or not prefix then return false end\n    return string.sub(s, 1, #prefix) == prefix\nend\n\n---@param s string\n---@param suffix string\n---@return boolean\nfunction SU.EndsWith(s, suffix)\n    if not s or not suffix then return false end\n    return string.sub(s, -#suffix) == suffix\nend\n\n---@param s string\n---@param suffix string\n---@return string\nfunction SU.RtrimChar(s,char)\n    if not s or not char then return s end\n    while #s > 0 and SU.EndsWith(s, char) do\n        s = string.sub(s,1,#s - #char)\n    end\n    return s\nend\n\n---Splits the string into parts, honoring \" and ' as quote chars to make multi-word arguments\n-- SplitQuoted() credits to Yoarii (SVEA)\n---@param s string\n---@return string[]\nfunction SU.SplitQuoted(s)\n    local function isQuote(c) return c == '\"' or c == \"'\" end\n    local function isSpace(c) return c == \" \" end\n\n    local function add(target, v)\n        v = SU.Trim(v)\n        if v:len() > 0 then\n            table.insert(target, #target + 1, v)\n        end\n    end\n\n    local inQuote = false\n    local parts = {} ---@type string[]\n    if type(s) ~= \"string\" or s == \"\" then\n        return parts\n    end\n\n    local current = \"\"\n    for c in string.gmatch(s, \".\") do\n        if isSpace(c) and not inQuote then\n            -- End of non-quoted part\n            add(parts, current)\n            current = \"\"\n        elseif isQuote(c) then\n            if inQuote then -- End of quote\n                add(parts, current)\n                current = \"\"\n                inQuote = false\n            else -- End current, start quoted\n                add(parts, current)\n                current = \"\"\n                inQuote = true\n            end\n        else\n            current = current .. c\n        end\n    end\n\n    -- Add whatever is at the end of the string.\n    add(parts, current)\n\n    return parts\nend\n\n---@comment Returns trueValue if cond is true, otherwise falseValue. nil's will be checked and returned as empty strings.\n---@param cond boolean cond should evaluate to true or false\n---@param trueValue any\n---@param falseValue any\n---@return string\nfunction SU.If(cond, trueValue, falseValue)\n    if cond then\n        return tostring(trueValue or \"\")\n    end\n    return tostring(falseValue or \"\")\nend\n\n---@comment Returns true if char is a printable character\n---@param char string single character\n---@return boolean\nfunction SU.isPrintable(char)\n    return strmatch(char, \"[%g%s]\") ~= nil\nend\n\n---@comment Returns true if char is a printable character\n---@return any Returns the ready string. In case of invalid separator, the original string is returned.\nfunction SU.SplitAndCapitalize(inputString, delimiter)\n    if not inputString or not SU.isPrintable(delimiter) then\n        return inputString\n    end\n    local parts = {}\n    for part in inputString:gmatch(\"[^\" .. delimiter .. \"]+\") do\n        table.insert(parts, part)\n    end\n    for i = 1, #parts do\n        parts[i] = parts[i]:sub(1, 1):upper() .. parts[i]:sub(2)\n    end\n    return table.concat(parts)\nend\n\nreturn SU\nend)\npackage.preload['YFS-Tools:../util/out.lua']=(function()\n--- functions with chat output\nlocal o = {}\n\nfunction o.PrettyDistance(dist)\n    if dist < 10000 then\n        return Round(dist,2)..\" m\"\n    end\n    if dist < 200000 then\n        return Round(dist/1000,2)..\" km\"\n    end\n    return Round(dist/200000,2)..\" SU\"\nend\n\n---@param mass number mass in kg\n---@return string prettyfied mass for display\nfunction o.PrettyMass(mass)\n    if mass > 1000000 then\n        return Round(mass / 1000000,2)..\" KT\"\n    end\n    if mass > 1000 then\n        return Round(mass / 1000,2)..\" tons\"\n    end\n    return Round(mass,2)..\" kg\"\nend\n\n---@param s string|any\nfunction o.PrintLines(s)\n    if not s then return end\n    if type(s) ~= \"string\" then s = tostring(s) end\n    for str in s:gmatch(\"([^\\n]+)\") do\n         print(str)\n    end\nend\n\nfunction o.Error(err)\n    o.PrintLines(err)\n    return false\nend\n\nfunction o.DeepPrint(e, maxItems)\n    if IsTable(e) then\n        local cnt = 0\n        maxItems = maxItems or 0\n        for k,v in pairs(e) do\n            if IsTable(v) then\n                P(\"-> \"..k)\n                o.DeepPrint(v, maxItems)\n            elseif type(v) == \"boolean\" then\n                P(k..\": \"..BoolStr(v))\n            elseif type(v) == \"function\" then\n                P(k..\"()\")\n            elseif v == nil then\n                P(k..\" (\"..type(v)..\")\")\n            else\n                P(k..\": \"..tostring(v))\n            end\n            cnt = cnt + 1\n            if maxItems > 0 and cnt >= maxItems then\n               P(\"^:^:^:^: cutoff reached :^:^:^:^\")\n                return\n            end\n        end\n    elseif type(e) == \"boolean\" then\n       P(BoolStr(e))\n    else\n       P(e)\n    end\nend\n\nfunction o.DumpVar(data)\n    -- cache of tables already printed, to avoid infinite recursive loops\n    local tablecache = {}\n    local buffer = \"\"\n    local padder = \"    \"\n    local function _dumpvar(d, depth)\n        local t = type(d)\n        local str = tostring(d)\n        if (t == \"table\") then\n            if (tablecache[str]) then\n                -- table already dumped before, so we dont\n                -- dump it again, just mention it\n                buffer = buffer..\"<\"..str..\">\\n\"\n            else\n                tablecache[str] = (tablecache[str] or 0) + 1\n                buffer = buffer..\"(\"..str..\") {\\n\"\n                for k, v in pairs(d) do\n                    buffer = buffer..string.rep(padder, depth+1)..\"[\"..k..\"] => \"\n                    _dumpvar(v, depth+1)\n                end\n                buffer = buffer..string.rep(padder, depth)..\"}\\n\"\n            end\n        elseif (t == \"boolean\") then\n            buffer = buffer..\"(\"..BoolStr(t)..\")\\n\"\n        elseif (t == \"number\") then\n            buffer = buffer..\"(\"..t..\") \"..str..\"\\n\"\n        else\n            buffer = buffer..\"(\"..t..\") \\\"\"..str..\"\\\"\\n\"\n        end\n    end\n    _dumpvar(data, 0)\n    return buffer\nend\n\nreturn o\nend)\npackage.preload['YFS-Tools:../util/Dtbk.lua']=(function()\n-- Dtbk by Jeronimo\nDtbk = {}\nDtbk.__index = Dtbk;\nfunction Dtbk.new(bank)\n    local self = setmetatable({}, Dtbk)\n    self.DB = bank\n    self.concat = table.concat\n    return self\nend\nfunction Dtbk.hasKey(self,tag)\n    return self.DB.hasKey(tag)\nend\nfunction Dtbk.getString(self,tag)\n    return self.DB.getStringValue(tag)\nend\nfunction Dtbk.setString(self,tag,value)\n    self.DB.setStringValue(tag,value)\nend\nfunction Dtbk.setData(self,tag,value)\n    local str = json.encode(value)\n    self.DB.setStringValue(tag,str)\nend\nfunction Dtbk.getData(self,tag)\n    local tmp = self.DB.getStringValue(tag)\n    if tmp == nil then return nil end\n    local str = json.decode(tmp)\n    return str\nend\nfunction Dtbk.remove(self,key)\n    self.DB.clearValue(key)\nend\nfunction Dtbk.ResetAll(self)\n    self.DB.clear()\nend\n\nend)\npackage.preload['YFS-Tools:libutils.lua']=(function()\nlocal tonum, strmatch = tonumber, string.match\n\nfunction IsTable(obj)\n    return obj ~= nil and type(obj) == \"table\"\nend\n\nfunction GetSortedAssocKeys(source)\n    local L = {}\n    if not IsTable(source) then E(\"[E] Invalid object for GetSortedKeys()!\") return L end\n    for k,_ in pairs(source) do\n        table.insert(L, k)\n    end\n    table.sort(L)\n    return L\nend\n\nfunction Round(num, decimals)\n    local mult = 10^(decimals or 0)\n    return ((num*mult) + (2^52 + 2^51) - (2^52 + 2^51))/mult\nend\n\nfunction TableLen(source)\n    if not IsTable(source) then return 0 end\n    local cnt = 0\n    for _ in pairs(source) do\n      cnt = cnt + 1\n    end\n    return cnt\nend\n\nfunction GetIndex(source, value)\n    if not IsTable(source) then return -1 end\n    for k, v in pairs(source) do\n      if value == v then return k end\n    end\n    return -1\nend\n\n---@param srcTable any\n---@param paramName string\n---@param reqType string|nil\n---@param reqMsg boolean|nil\n---@return any\nfunction GetParamValue(srcTable, paramName, reqType, reqMsg)\n    local err = \"[E] Parameter value missing for \"..paramName\n    if srcTable == nil or not IsTable(srcTable) then\n        if reqMsg == true then P(err) end\n        return nil\n    end\n    for k, v in ipairs(srcTable) do\n        if v == paramName then\n            local idx = k + 1\n            if #srcTable < idx then\n                if reqMsg == true then P(err) end\n                return nil\n            end\n            local val = srcTable[idx]\n            if not reqType or reqType == \"string\" or reqType == \"s\" then\n                if val == '\"\"' or val == \"''\" then return nil end\n                return val\n            elseif ((reqType == \"int\" or reqType == \"i\") and not strmatch(val, \"%D\")) then\n                return tonum(val)\n            elseif reqType == \"number\" or reqType == \"n\" then\n                return tonum(val)\n            elseif reqType == \"bool\" or reqType == \"b\" then\n                if val then return true else return false end\n            end\n            return nil\n        end\n    end\n    if reqMsg == true then E(err) end\n    return nil\nend\n\nfunction PairsByKeys(t, f)\n    local a = {}\n    for n in pairs(t) do table.insert(a, n) end\n    table.sort(a, f)\n    local i = 0 -- iterator variable\n    local iter = function () -- iterator function\n        i = i + 1\n        if a[i] == nil then\n            return nil\n        else\n            return a[i], t[a[i]]\n        end\n    end\n    return iter\nend\n\nfunction BoolState(bool)\n    if bool then\n        return \"enabled\"\n    else\n        return \"disabled\"\n    end\nend\n\nfunction BoolStr(b)\n    if b == true then\n        return \"true\"\n    else\n        return \"false\"\n    end\nend\n\nfunction ScreenOutput(output, chatFooter)\n    local chat = \"Point at screen, CTRL+L, then copy text!\"\n    if #Config.screens >  0 then\n        -- local pre = \"local rslib = require('rslib')\\n\"..\n        -- \"local text = [[\"..output..\"]]\\n\"..\n        -- \"local config = { fontSize = 20 }\\n\"..\n        -- \"rslib.drawQuickText(text, config)\\n\"\n        local font = OutputFont or \"FiraMono\"\n        local pre = \"local text = [[\\n\"..output..\"\\n]]\\n\"..\n[[\nlocal rslib = require('rslib')\nlocal layer = createLayer()\nlocal rx, ry = getResolution()\nlocal fontSize = 15\nlocal font = loadFont(\"]]..font..[[\", fontSize)\nlocal line = 1\nfor str in text:gmatch(\"([^\\n]+)\") do\n    addText(layer, font, str, 20, line*(fontSize+4))\n    line = line + 1\nend ]]\n--setNextFillColor(layer, 1, 0, 0, 1)\n--addBox(layer, rx/4, ry/4, rx/2, ry/2)\n--addText(layer, font, text, rx/1, ry/1)\n        --Config.screens[1].setHTML(pre)\n        Config.screens[1].setRenderScript(pre)\n        if chatFooter and chatFooter:len() then\n            chat = chatFooter..\"\\n\"..chat\n        end\n    else\n        chat = \"Hint: link a screen to PB to easily copy text from it!\"\n    end\n    P(chat)\n    return true\nend\nend)\npackage.preload['YFS-Tools:commands.lua']=(function()\n--TODO: refactor commands to use WM instead of databank data\nlocal cmd = {}\n\n-- requires libutils, globals PM, SU, YFSDB etc.\n-- WaypointInfo only used for WarpCostCmd()\n\nlocal strmatch, sformat, strlen = string.match, string.format, string.len\nlocal tonum, uclamp, mabs, max, floor, ceil = tonumber, utils.clamp, math.abs, math.max, math.floor, math.ceil\n\n-- Local functions\n\n---@comment Adds for each existing waypoint listed in \"wpnames\" an extra \"Flight\" waypoint\n--- at the given altitude with the given name suffix.\n--- Already existing waypoints with the suffix'ed name will have their altitude changed!\n--- Returns a list of \"connected\" waypoints, e.g.\n--- 1 landed -> 1 flight -> 2 flight -> 2 landed -> 2 flight -> 3 flight -> 3 landed  etc.\n--- as 2nd result; 1st result is the updated full waypoints list.\n---@param wpdata table\n---@param wpnames table\n---@param altitude number\n---@param suffix string\nlocal function yfsAddAltitudeWaypoints(wpdata, wpnames, altitude, suffix)\n    local cnt = 0\n    local names = {}\n    local wpCnt = #wpnames\n    for _,k in ipairs(wpnames) do\n        local wp = wpdata.v[k]\n        if wp ~= nil then\n            cnt = cnt + 1\n            local wpN = k .. suffix\n            if cnt > 1 then table.insert(names, wpN) end\n            table.insert(names, k)\n            if cnt < wpCnt then table.insert(names, wpN) end\n            local newPos = PM.ReplaceAltitudeInPos(wp.pos, altitude)\n            if wpdata.v[wpN] ~= nil then\n                wpdata.v[wpN].pos = newPos\n            else\n                wpdata.v[wpN] = { pos = newPos }\n                P(wpN ..\"  \" .. newPos)\n            end\n        end\n    end\n    if cnt == 0 then\n        P(\"[E] No waypoints processed!\")\n        return nil,nil\n    end\n    P(\"[I] \"..cnt..\" waypoints at \"..altitude..\"m added (or changed)!\")\n    return wpdata, names\nend\n\nlocal function storeYFSData(keyName, data)\n    if not DetectedYFS or not keyName then return false end\n    YFSDB:setData(keyName, data)\n    return true\nend\n\nlocal function getYFSData(keyName)\n    if not DetectedYFS or not keyName then return false end\n    local data = YFSDB:getData(keyName)\n    if data == nil or not IsTable(data.v) then\n        return false\n    end\n    return data\nend\n\nlocal function storeYFSNamedWaypoints(data)\n    storeYFSData(YFS_NAMED_POINTS, data)\nend\n\nlocal function storeYFSRoutes(data)\n    storeYFSData(YFS_ROUTES, data)\nend\n\n-- Class functions\n\nfunction cmd.GetYFSNamedWaypoints(muteMsg)\n    if not DetectedYFS then\n        return E(\"[E] Linked YFS databank required!\")\n    end\n    local namedWP = getYFSData(YFS_NAMED_POINTS)\n    if not namedWP and not muteMsg then\n        P(\"[I] No named waypoints\")\n    end\n    return namedWP\nend\n\nfunction cmd.GetYFSRoutes()\n    if not DetectedYFS then\n        return E(\"[E] Linked YFS databank required!\")\n    end\n    local data = getYFSData(YFS_ROUTES)\n    if not data then\n        return E('[I] No YFS routes found.')\n    end\n    return data\nend\n\nfunction cmd.PlanetInfoCmd(text)\n    PM.PlanetInfo(text)\nend\n\nfunction cmd.PrintAltitudeCmd(text)\n    P(Out.PrettyDistance(PM.Altitude()))\nend\n\nfunction cmd.PrintPosCmd(text)\n    P(PM.GetCurrentPosString())\nend\n\nfunction cmd.PrintWorldPosCmd(text)\n    P(PM.Vec3ToPosString(PM.WorldPosVec3()))\nend\n\nfunction cmd.WarpCostCmd(text)\n    CalcWarpCost(text)\nend\n\n---@comment with WM: create commands to recreate waypoints in either YFS or ArchHud format\nfunction cmd.WpSaveNamedCmd(text, isYfs)\n    if not WM or not WM:hasPoints() then\n        return E(\"[E] No waypoints to export.\")\n    end\n    local output = \"\"\n    for _,wp in ipairs(WM:getSorted()) do\n        local pos = wp:AsString()\n        if isYfs then\n            pos = \"pos-save-as '\" .. wp:getName() .. \"' -pos \" .. pos\n        else\n            pos = \"/addlocation \" .. wp:getName() .. \" \" .. pos\n        end\n        output = output .. pos .. \"\\n\"\n        P(pos)\n    end\n    ScreenOutput(output)\nend\n\nfunction cmd.ArchSaveNamedCmd(text)\n    cmd.WpSaveNamedCmd(text, false)\nend\n\n---@comment with WM: output name and position for all waypoints\nfunction cmd.WpExportCmd(text)\n    if not WM or not WM:hasPoints() then\n        return E(\"[E] No waypoints to export.\")\n    end\n    local output = \"\"\n    local wplist = WM:getSorted()\n    for _,wp in ipairs(wplist) do\n        local s = wp:getName() .. \"\\n\" .. wp:AsString() .. \"\\n\"\n        output = output .. s\n    end\n    P(output)\n    ScreenOutput(output)\nend\n\nfunction cmd.WpAltitudeCeilingCmd(text)\n    local wpnames = cmd.GetYFSNamedWaypoints()\n    if not wpnames then return end\n\n    -- 0 parse params to find a) name and b) new altitude value\n    local parts = SU.SplitQuoted(text)\n    if #parts ~= 2 then\n        P(\"[E] Parameter(s) missing: 'name 1' 'name 2'\")\n        return E(\"Example: /wp-altitude-ceiling 'Base 1' 'Base 2'\")\n    end\n    local wpName1 = parts[1]\n    local wpName2 = parts[2]\n\n    -- 2 find named waypoint as per params\n    local wp1found, wp2found = true, true\n    if wpnames.v[wpName1] == nil or wpnames.v[wpName1] == \"\" then\n        P(\"[E] Waypoint '\".. wpName1 ..\"' not found.\")\n        wp1found = false\n    end\n    if wpnames.v[wpName2] == nil or wpnames.v[wpName2] == \"\" then\n        P(\"[E] Waypoint '\".. wpName2 ..\"' not found.\")\n        wp2found = false\n    end\n    if not wp1found or not wp2found then return end\n    if wpnames.v[wpName1] == wpnames.v[wpName2] then\n        return E(\"[E] Parameters invalid (same names).\")\n    end\n\n    -- 3 get waypoint's altitudes and update the lower one\n    local alt1 = PM.GetAltitudeFromPos(wpnames.v[wpName1].pos)\n    local alt2 = PM.GetAltitudeFromPos(wpnames.v[wpName2].pos)\n    if alt1 == alt2 then\n        P(\"[I] Waypoints had same altitude, no changes applied.\")\n        return\n    end\n    local target, targetAlt = \"\", 0\n    if alt1 > alt2 then\n        target = wpName2\n        targetAlt = alt1\n    else\n        target = wpName1\n        targetAlt = alt2\n    end\n    local newPos = PM.ReplaceAltitudeInPos(wpnames.v[target].pos, targetAlt)\n    wpnames.v[target].pos = newPos\n    P(\"[I] Waypoint '\"..target..\"' changed to:\")\n    P(newPos)\n\n    -- 4 json.encode data and write back to DB\n    storeYFSNamedWaypoints(wpnames)\n    return true\nend\n\nfunction cmd.GetStoredLocations(points) -- for ArchHud only\n    if not points or not IsTable(points) then return end\n    for _,p in ipairs(points) do\n        if p.name and p.position and p.position.x and p.position.y and p.position.z then\n            P(\"[I] Location '\".. p.name ..\"' found.\")\n            local pos = '::pos{0,0,'.. p.position.x .. ',' .. p.position.y .. ',' .. p.position.z ..'}'\n            PM.CreateWaypoint(pos, p.name)\n        end\n    end\nend\n\nfunction cmd.YfsAddAltitudeWpCmd(text)\n    local wpdata = cmd.GetYFSNamedWaypoints()\n    if not wpdata or not IsTable(wpdata.v) or TableLen(wpdata.v) == 0 then\n        return E(\"[E] No waypoints.\")\n    end\n\n    local example = \"\\nExample: /yfs-add-altitude-wp -altitude 450 -suffix 'F'\"\n    local args = SU.SplitQuoted(text)\n    local pStart = GetParamValue(args, \"-wpStartsWith\", \"s\")\n    if #args < 1 then\n        return E(\"[E] Parameter missing: -altitude\"..example)\n    end\n    local pAlt = GetParamValue(args, \"-altitude\", \"n\", true)\n    local pSuf = GetParamValue(args, \"-suffix\", \"s\")\n    if not pSuf or pSuf == \"\" then pSuf = \"F\" end\n    if pAlt < -100 or pAlt > 20000 then\n        return E(\"[E] -altitude value out of range (-100 .. 20000)\"..example)\n    end\n\n    -- need a sorted list of names, can't use wpdata as that is being modified\n    local wplist = {}\n    for k in PairsByKeys(wpdata.v) do\n        if not pStart or k:find(pStart) > 0 then\n            table.insert(wplist, k)\n        end\n    end\n    local newData, names = yfsAddAltitudeWaypoints(wpdata, wplist, pAlt, pSuf)\n    if newData ~= nil and names ~= nil then\n        storeYFSNamedWaypoints(newData)\n    end\n    return true\nend\n\nfunction cmd.YfsBuildRouteFromWpCmd(text)\n    local wpdata = cmd.GetYFSNamedWaypoints()\n    if not wpdata or not IsTable(wpdata.v) or TableLen(wpdata.v) == 0 then\n        return E(\"[E] No waypoints.\")\n    end\n\n    local rdata = cmd.GetYFSRoutes()\n    if not rdata or not IsTable(rdata.v) or TableLen(rdata.v) == 0 then\n        -- Initializing routes\n        rdata = { v = {}, t = \"table\" }\n    else\n    end\n\n    local example = \"\\nExample: /yfs-build-route-from-wp -name 'Route' -altitude 450 -wpStartsWith 'Chr' -suffix 'F'\\n-suffix is optional, default F (Flight)\"\n    local args = SU.SplitQuoted(text)\n    if #args < 1 then\n        return E(\"[E] Parameters missing!\"..example)\n    end\n\n    local pName  = GetParamValue(args, \"-name\", \"s\", true)\n    if not pName then return end\n    local pStart = GetParamValue(args, \"-wpStartsWith\", \"s\")\n    local pAlt   = GetParamValue(args, \"-altitude\", \"n\", true)\n    if not pAlt then return end\n    local pSuf   = GetParamValue(args, \"-prefix\", \"s\")\n    local pMarginL = GetParamValue(args, \"-marginL\", \"n\")\n    local pMarginF = GetParamValue(args, \"-marginF\", \"n\")\n    local pMaxSpeed = GetParamValue(args, \"-maxSpeed\", \"n\")\n    local pFinalSpeedF = GetParamValue(args, \"-finalSpeedF\", \"n\")\n    -- some sanity checks, review later\n    pMarginL = uclamp(pMarginL or 0.1, 0.1, 100) -- landed position margin\n    pMarginF = uclamp(pMarginF or 0.1, 0.1, 100) -- flight position margin\n    pMaxSpeed = uclamp(pMaxSpeed or 0, 0, 1200) -- max speed at flight\n    pFinalSpeedF = uclamp(pFinalSpeedF or 0, 0, 1200) -- speed reaching the wp\n    if rdata.v[pName] ~= nil then\n        return E(\"[E] Route \"..pName..\"already exists, aborting!\")\n    end\n    if not type(pSuf) == \"string\" or pSuf == \"\" then pSuf = \"F\" end\n    if strlen(pSuf) > 3 then\n        return E(\"[E] -suffix accepts max. 3 characters\"..example)\n    end\n    if pAlt < -100 or pAlt > 20000 then\n        return E(\"[E] -altitude value out of range (-100 .. 20000)\"..example)\n    end\n\n    -- need a sorted list of names, can't use wpdata as that is being modified *live*\n    -- names could be filtered by pStart\n    local wplist = {}\n    for k in PairsByKeys(wpdata.v) do\n        if not pStart or k:find(pStart) > 0 then\n            table.insert(wplist, k)\n        end\n    end\n\n    -- lets add new \"flight\" waypoints and get updated tables back\n    local wpdata, wplistNew = yfsAddAltitudeWaypoints(wpdata, wplist, pAlt, pSuf)\n    if wpdata == nil or wplistNew == nil then\n        return E(\"[I] No waypoints processed: no changes made.\")\n    end\n\n    -- add new route\n    rdata.v[pName] = { points = {} }\n\n    -- assume that wplistNew now contains all required wp names in order\n    -- so these can be added to the route\n    local cnt = 0\n    for _,k in ipairs(wplistNew) do\n        local wp = wpdata.v[k]\n        if wp ~= nil then\n            -- add wp to route\n            cnt = cnt + 1\n            local rOpt = { margin = 0.1, maxSpeed = 0 }\n            local rp = { opt = rOpt, pos = wp.pos, waypointRef = k }\n            -- for \"flight\" waypoints:\n            if GetIndex(wplist, k) < 1 then\n                -- set final approaching speed for landing waypoints if specified\n                if pFinalSpeedF and pFinalSpeedF > 0 and GetIndex(wplist, k) < 1 then\n                    rp.opt.finalSpeed = pFinalSpeedF\n                end\n                -- set max speed for flight waypoints if specified\n                if pMaxSpeed and pMaxSpeed > 0 then\n                    rp.opt.maxSpeed = pMaxSpeed\n                end\n                -- set margin for flight waypoints if specified\n                if pMarginF and pMarginF > 0.1 then\n                    rp.opt.margin = pMarginF\n                end\n                rp.opt.selectable = false\n                rp.opt.skippable = false\n            else -- for Landed waypoints:\n                -- set margin for landed waypoints if specified\n                if pMarginL and pMarginL > 0.1 then\n                    rp.opt.margin = pMarginL\n                end\n                rp.opt.selectable = true\n                rp.opt.skippable = true\n            end\n            table.insert(rdata.v[pName].points, rp)\n        end\n    end\n    P(\"[I] \"..cnt..\" positions added to route '\"..pName..\"'\")\n    storeYFSNamedWaypoints(wpdata)\n    storeYFSRoutes(rdata)\nend\n\nfunction cmd.YfsSaveRouteCmd(text)\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n\n    local parts = SU.SplitQuoted(text)\n    if #parts < 1 then\n        return E(\"[E] Parameter(s) missing: routename\\nExample: /yfs-save-route 'Cryo' -onlySelectable -withOptions -prefix 'Cryo'\")\n    end\n    local wpPrefix = GetParamValue(parts, \"-prefix\", \"s\")\n    if not wpPrefix then wpPrefix = \"WP\" end\n    local onlySelectable = GetIndex(parts, \"-onlySelectable\") > 0\n    local withOptions = GetIndex(parts, \"-withOptions\") > 0\n    local routename = parts[1]\n    local route = routes.v[routename]\n    if not route or not IsTable(route.points) or #route.points == 0 then\n        return E(\"[E] Route '\"..routename..\"' not found or empty\")\n    end\n    local output1, output2 = \"create-route '\"..routename..\"'\\r\\n\", \"\"\n\n    local wpdata = cmd.GetYFSNamedWaypoints()\n\n    -- iterate points, build one commands output for wp creation and one for\n    -- adding each with options (optionally) to the route\n    local wpIdx = 1\n    local wpNames = {} -- to avoid duplicates\n    for _,v in ipairs(route.points) do\n        local wppos = \"\"\n        local wpName = wpPrefix..\" \"..sformat(\"%03d\", wpIdx)\n        if v.waypointRef and wpdata then\n            wpName = v.waypointRef\n            wppos = wpdata.v[wpName].pos\n        else\n            wppos = v.pos or \"<unknown>\"\n        end\n\n        if GetIndex(wpNames, wpName) < 0 then\n            wpNames[#wpNames + 1] = wpName\n            local tmp = \"pos-save-as '\"..wpName..\"' -pos \"..wppos\n            output1 = output1 .. tmp .. \"\\n\"\n        end\n        if (not onlySelectable) or (v.opt[\"selectable\"] ~= false) then\n            local tmp = \"route-add-named-pos '\"..wpName..\"'\"\n            if withOptions then\n                -- named-waypoint level options\n                -- Note: \"lockdir\" option is presently not transferrable!\n                if v.opt[\"maxSpeed\"] and v.opt[\"maxSpeed\"] ~= 0 then\n                    tmp = tmp..\" -maxspeed \"..v.opt[\"maxSpeed\"]\n                end\n                if v.opt[\"margin\"] and v.opt[\"margin\"] ~= 0.1 then\n                    tmp = tmp..\" -margin \"..v.opt[\"margin\"]\n                end\n                -- route-level options require a 2nd command\n                local routeLvlOptions = false\n                local routeOptStr = \"\"\n                if v.opt[\"skippable\"] == true then\n                    routeLvlOptions = true\n                    routeOptStr = routeOptStr .. \" -toggleSkippable\"\n                end\n                if v.opt[\"selectable\"] == false then\n                    routeLvlOptions = true\n                    routeOptStr = routeOptStr .. \" -toggleSelectable\"\n                end\n                if v.opt[\"finalSpeed\"] and v.opt[\"finalSpeed\"] ~= 0 then\n                    routeLvlOptions = true\n                    routeOptStr = routeOptStr..\" -finalSpeed \"..v.opt[\"finalSpeed\"]\n                end\n                if routeLvlOptions then\n                    tmp = tmp .. \"\\nroute-set-pos-option -ix \"..wpIdx..routeOptStr\n                end\n            end\n            output2 = output2 .. tmp .. \"\\n\"\n            wpIdx = wpIdx + 1\n        end\n    end\n    output2 = output2..\"route-save\\r\\n\"\n    P(output1..output2)\n    ScreenOutput(output1..output2)\nend\n\n---@comment Replaces a given YFS waypoint (by -name) with current pos (default) or -pos ::pos{...}\nfunction cmd.YfsReplaceWpCmd(text)\n    local wpnames = cmd.GetYFSNamedWaypoints()\n    if not wpnames then return end\n\n    local ex = \"\\r\\nExample: /yfs-replace-wp 'base 1'\"\n    local params = SU.SplitQuoted(text)\n    if #params < 1 then\n        return E(\"[E] Parameter(s) missing: -name 'point'\"..ex)\n    end\n\n    local wpName = GetParamValue(params, \"-name\", \"s\", true)\n    if not wpName then return end\n    if not wpnames.v[wpName] or wpnames.v[wpName] == \"\" then\n        return E(\"[E] Waypoint '\".. wpName ..\"' not found.\"..ex)\n    end\n\n    local newPos = PM.GetCurrentPosString()\n    local pPos = GetParamValue(params, \"-pos\", \"s\")\n    if pPos then\n        ---@diagnostic disable-next-line: cast-local-type\n        local tmp = PM.SplitPos(pPos)\n        if not tmp then\n            return E(\"[E] Invalid ::pos{} specified!\")\n        end\n        newPos = pPos\n    end\n\n    wpnames.v[wpName].pos = newPos\n    P(\"[I] Waypoint '\"..wpName..\"' changed to:\")\n    P(newPos)\n\n    storeYFSNamedWaypoints(wpnames)\n    return true\nend\n\nfunction cmd.YfsRouteAltitudeCmd(text)\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n\n    local namedWP = cmd.GetYFSNamedWaypoints()\n    if not namedWP then return end\n\n    -- 1 check parameters\n    local example = \"\\nExample:\\n/yfs-route-altitude -route 'name' -ix 2 -endIx 3 -alt 330\\nThe -endIx is optional.\"\n    local parts  = SU.SplitQuoted(text)\n    local pName  = GetParamValue(parts, \"-route\", \"s\", true)\n    if not pName then return end\n    if not routes.v[pName] then\n        return E(\"[E] Route '\"..pName..\"' not found.\"..example)\n    end\n    if not routes.v[pName].points or #routes.v[pName].points == 0 then\n        return E(\"[E] Route '\"..pName..\"' empty.\")\n    end\n\n    local pStart = GetParamValue(parts, \"-ix\", \"i\", true)\n    local pEnd   = GetParamValue(parts, \"-endIx\", \"i\")\n    local pAlt   = GetParamValue(parts, \"-alt\", \"n\", true)\n    local isError = not pName or not pStart or not pAlt or (pStart < 1) or (pEnd and pEnd < pStart) or (pAlt < -100) or (pAlt > 10000)\n    if isError then\n        return E(\"[E] Wrong number of parameters / invalid values!\"..example)\n    end\n    if not pEnd or pEnd < pStart then pEnd = pStart end\n\n    -- 2 process route waypoints and collect named waypoint names\n    -- /yfs-route-altitude -route 'Cryo' -ix 2 -endIx 3 -alt 330.1243\n    P(\"[I] Processing route '\"..pName..\"'\")\n    local changed = 0\n    local wpnames = {}\n    for i,v in ipairs(routes.v[pName].points) do\n        if i >= pStart and i <= pEnd then\n            local wpName = v.waypointRef\n            local wp = namedWP.v[wpName]\n            if wp ~= nil then\n                if GetIndex(wpnames, wpName) < 1 then\n                    table.insert(wpnames, wpName)\n                end\n                local newPos = PM.ReplaceAltitudeInPos(wp.pos, pAlt)\n                routes.v[pName].points[i].pos = newPos\n                P(\"[I] Route Waypoint '\"..wpName..\"' changed to:\\n\"..newPos)\n            end\n        end\n    end\n    if #wpnames == 0 then\n        return E(\"[I] No waypoints in route changed.\\n[*] Make sure that start (and end-index) are valid.\")\n    end\n    -- 3 store routes back to db\n    storeYFSRoutes(routes)\n    P(\"[I] Routes saved.\")\n\n    -- 4 process named waypoints list\n    changed = 0\n    for _,entry in ipairs(wpnames) do\n        if namedWP.v[entry] then\n            changed = changed + 1\n            local newPos = PM.ReplaceAltitudeInPos(namedWP.v[entry].pos, altitude)\n            namedWP.v[entry].pos = newPos\n            P(\"[I] Named Waypoint '\"..entry..\"' changed to:\")\n            P(newPos)\n        else\n            P(\"[E] '\"..entry..\"' not found!\")\n        end\n    end\n    -- 5 write back to DB\n    if changed > 0 then\n        storeYFSNamedWaypoints(namedWP)\n        P(\"[I] Named waypoints saved.\")\n    end\nend\n\nfunction cmd.YfsWpAltitudeCmd(text)\n    -- 1 read named waypoints from DB\n    local wpnames = cmd.GetYFSNamedWaypoints()\n    if not wpnames then return E(\"[E] No named waypoints.\") end\n\n    -- 2 parse params to find a) name and b) new altitude value\n    local parts = SU.SplitQuoted(text)\n    if #parts ~= 2 then\n        return E(\"[E] Wrong number of parameters!\\nExample: /yfs-wp-altitude 'Base 1' 324.12\")\n    end\n    local pName = parts[1] or \"\"\n\n    -- 3 find named waypoint\n    if not pName or not parts[2] or not wpnames.v[pName] or wpnames.v[pName] == \"\" then\n         return E(\"[E] Waypoint '\".. pName ..\"' not found\")\n    end\n\n    -- 4 alter waypoint's altitude\n    local pAlt = tonum(parts[2] or 0)\n    local newPos = PM.ReplaceAltitudeInPos(wpnames.v[pName].pos, pAlt)\n    wpnames.v[pName].pos = newPos\n    P(\"[I] Waypoint '\"..pName..\"' changed to:\")\n    P(newPos)\n    P(\"[I] Note: routes' waypoints are updated on route activation, i.e. exporting route data before activation may still show old value!\")\n\n    -- 4 write back to DB\n    storeYFSNamedWaypoints(wpnames)\n    return true\nend\n\nfunction cmd.YfsRouteNearestCmd(text)\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n    -- 1 process params\n    local params = SU.SplitQuoted(text)\n    if #params == 0 or #params > 2 then\n        P(\"[E] Wrong parameter count\\n[I] Example: /yfs-route-nearest 'Route 1'\")\n        P(\"\\nOptional parameter:\\n\")\n        P(\"-onlySelectable -> only show closest, selectable waypoints in route\")\n        return false\n    end\n    -- 2 find the route\n    local routeName = params[1]\n    local route = routes.v[routeName]\n    if not route or not IsTable(route.points) then\n        return E(\"[E] Route '\" .. routeName ..\"' not found or empty\")\n    end\n    P(\"[I] Route '\"..routeName..\"' found.\")\n    -- 3 check optional parameters\n    local onlySelectable = GetIndex(params, \"-onlySelectable\") > 0\n\n    -- 4 process route waypoints\n    local wplist = cmd.GetYFSNamedWaypoints(true)\n    local idx = 0\n    local closestDist = 999999999\n    local sDist, sNearest = \"\", \"\"\n    local res =  {}\n    for k,v in ipairs(route.points) do\n        idx = idx + 1\n        if (not onlySelectable) or (v.opt and v.opt.selectable ~= false) then\n            local wpname = SU.Trim(sformat(\"%02d\", idx) .. \": '\"..(v.waypointRef or \"\")..\"'\")\n            local pos = v.pos\n            if v.waypointRef and wplist then\n                pos = wplist.v[v.waypointRef].pos\n            end\n            local dist = PM.GetDistance(pos)\n            if dist > 0.1 then\n                route.points[k].distance = dist\n                sDist = wpname .. \" = \" .. sformat(\"%.4f\", dist)\n                if dist < closestDist then\n                    sNearest = sDist\n                    closestDist = dist\n                end\n                local tmpDist = tostring(math.modf(dist * 10000))\n                local key = ('0'):rep(12-#tmpDist)..tmpDist\n                res[key] = idx\n            end\n        end\n    end\n    if not idx then return E(\"[I] No selectable waypoints found.\") end\n    local output = \"Route-Idx / Name / Distance (m)\\n\"\n    for _,key in pairs(GetSortedAssocKeys(res)) do\n        local routeIdx = res[key]\n        local wpName = route.points[routeIdx].waypointRef\n        local wpDist = route.points[routeIdx].distance\n        output = output .. sformat(\"%02d\", routeIdx)..\" / '\"..wpName..\"' / \"\n        output = output .. Out.PrettyDistance(wpDist)..\"\\n\"\n    end\n    output = output .. \"\\n[I] Nearest waypoint: \"..sNearest\n\n    Out.PrintLines(output)\n    ScreenOutput(output)\nend\n\nfunction cmd.YfsRouteToNamedCmd(text)\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n    -- 1 process params\n    local params = SU.SplitQuoted(text)\n    if #params == 0 or #params > 6 then\n        P(\"[E] Wrong parameter count\\n[I] Example: /yfs-route-to-named 'Route 1'\\nOptional parameters:\\n\")\n        P(\"-onlySelectable -> only write waypoints marked as selectable in route\")\n        P(\"-prefix Myprefix -> if unspecified, 'WP' is default\")\n        P(\"-toScreen -> output JSON of list to optional screen if linked\")\n        P(\"-toDB -> only if this is given, the changed list will be written to DB to avoid miscalls\")\n        P(\"Important: command aborts if ANY waypoint's name starts with given prefix to avoid errors!\")\n        return false\n    end\n    -- 2 find the route\n    local routeName = params[1]\n    local route = routes.v[routeName]\n    if not route or not IsTable(route.points) then\n        return E(\"[E] Route '\" .. routeName ..\"' not found or empty\")\n    end\n    P(\"[I] Route '\"..routeName..\"' found.\")\n    -- 3 check optional parameters\n    local toDB = GetIndex(params, \"-toDB\") > 0\n    local toScreen = GetIndex(params, \"-toScreen\") > 0\n    local onlySelectable = GetIndex(params, \"-onlySelectable\") > 0\n    local wpPrefix = GetParamValue(params, \"-prefix\", \"s\")\n    if not wpPrefix then wpPrefix = \"WP\" end\n    -- local margin = nil\n    -- local pMargin = GetParamValue(params, \"-margin\", \"number\")\n    -- if pMargin and pMargin ~= 0.1 then margin = pMargin end\n\n    -- 4 process route waypoints\n    local wplist = cmd.GetYFSNamedWaypoints(true)\n    if not wplist or not wplist.v then\n        wplist = { v = { } }\n    else\n        -- if any WP with same prefix already exists, abort!\n        for k,_ in pairs(wplist.v) do\n            if string.find(k, wpPrefix) == 1 then\n                return E(\"[!] Waypoints with same prefix already exist!\\n[!] Command aborted.\")\n            end\n        end\n    end\n    local idx = 0\n    for _,v in ipairs(route.points) do\n        if (not onlySelectable) or (v.opt and v.opt.selectable ~= false) then\n            idx = idx + 1\n            local wpname = wpPrefix .. \" \" .. sformat(\"%02d\", idx)\n            local wp = { pos = v.pos, opt = v.opt}\n            --if margin then wp.opt.margin = margin end\n            wplist.v[wpname] = wp\n            P(wpname ..\"  \" .. v.pos)\n        end\n    end\n    if not idx then return E(\"[I] No changes to waypoints done\") end\n\n    -- 5 write waypoints back to DB, if at least 1 point was added\n    if toDB then\n        storeYFSNamedWaypoints(wplist)\n        P(\"[I] Waypoint changes saved to databank!\")\n    else\n        P(\"[I] -toDB not present, no changes saved to databank!\")\n    end\n    if toScreen then\n        ScreenOutput(json.encode(wplist.v))\n    end\nend\n\nfunction cmd.YFSLoadNamedWaypoints()\n    local wpnames = cmd.GetYFSNamedWaypoints()\n    if not wpnames then return end\n    for k,v in pairs(wpnames.v) do\n        PM.CreateWaypoint(v.pos, k)\n    end\nend\n\nfunction cmd.YFSLoadRoutepoints(onlySelectableWP, onlyWpForRoute)\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return false end\n    P('[I] Processing routes...')\n    for k,v in pairs(routes.v) do\n        if (onlyWpForRoute == \"\" or onlyWpForRoute == k) and IsTable(v) then\n            for k2,v2 in ipairs(v.points) do\n                if (not onlySelectableWP) or (v2.opt[\"selectable\"] ~= false) then\n                    local wpName = k .. \" \" .. k2\n                    if v2.waypointRef then\n                        wpName = v2.waypointRef\n                    end\n                    PM.CreateWaypoint(v2[\"pos\"], wpName)\n                end\n            end\n            P(\"[I] Route '\"..k..\"' read.\")\n        end\n    end\n    return true\nend\n\nfunction cmd.YfsSaveNamedCmd(text)\n    cmd.WpSaveNamedCmd(text, true)\nend\n\nfunction cmd.PosDataCmd()\n    --P(\"GetCameraCmd() called\")\n    P(\"getCameraHorizontalFov: \"..system.getCameraHorizontalFov())\n    P(\"getCameraVerticalFov: \"..system.getCameraVerticalFov())\n\n    P(\"getCameraPos: \"..PM.Vec3String(system.getCameraPos()))\n    P(\"getCameraForward: \"..PM.Vec3String(system.getCameraForward()))\n    P(\"getCameraRight: \"..PM.Vec3String(system.getCameraRight()))\n    P(\"getCameraUp: \"..PM.Vec3String(system.getCameraUp()))\n\n    P(\"getCameraWorldPos: \"..PM.Vec3String(system.getCameraWorldPos()))\n    P(\"getCameraWorldForward: \"..PM.Vec3String(system.getCameraWorldForward()))\n    P(\"getCameraWorldRight: \"..PM.Vec3String(system.getCameraWorldRight()))\n    P(\"getCameraWorldUp: \"..PM.Vec3String(system.getCameraWorldUp()))\n\n    P(\"construct.getWorldPosition: \"..PM.Vec3String(construct.getWorldPosition(CNID)))\n    P(\"construct.getOrientationForward: \"..PM.Vec3String(construct.getOrientationForward()))\n    P(\"construct.getOrientationRight: \"..PM.Vec3String(construct.getOrientationRight()))\n    P(\"construct.getOrientationUp: \"..PM.Vec3String(construct.getOrientationUp()))\nend\n\nfunction cmd.DumpPointsCmd()\n    if true then\n        P(\"~=~=~=~=~=~=~= DUMP START ~=~=~=~=~=~=\")\n        local tmp = Out.DumpVar(WM:getWaypointsInst())\n        P(tmp)\n        return ScreenOutput((tmp or \"[I] No waypoints.\"),\"\\n~=~=~=~=~=~=~= DUMP END ~=~=~=~=~=~=~=\")\n    end\n\nend\n\nfunction cmd.DumpRoutesCmd()\n    if not DetectedYFS then return E(\"[I] No YFS databank.\") end\n    P(\"~=~=~=~=~=~=~= ROUTES DUMP START ~=~=~=~=~=~=\")\n    local tmp = YFSDB:getString(YFS_ROUTES)\n    P(tmp)\n    ScreenOutput((tmp or \"[I] No routes.\"),\"\\n~=~=~=~=~=~=~= ROUTES DUMP END ~=~=~=~=~=~=~=\")\nend\n\nfunction cmd.RoutesCmd()\n    local routes = cmd.GetYFSRoutes()\n    if not routes then return end\n    P(\"[I] Available routes:\")\n    for k,_ in pairs(routes.v) do\n        P(k)\n    end\nend\n\n-- *** Dev/Testing functions ***\n\nfunction cmd.YfsTestDataCmd(param)\n    if not (param == \"TESTING\") then return end\n    P(\"[*] Creating YFS test data...\")\n\n    YFSDB:remove(YFS_NAMED_POINTS)\n    local data = { }\n    data[\"Chr 01\"] = { pos = \"::pos{0,7,-20.7784,-153.7402,360.5184}\", opt = {} }\n    data[\"Chr 02\"] = { pos = \"::pos{0,7,-21.3610,-152.3447,345.8787}\", opt = {} }\n    data[\"Chr 03\"] = { pos = \"::pos{0,7,-23.0540,-152.8934,360.6677}\", opt = {} }\n    data[\"Chr 04\"] = { pos = \"::pos{0,7,-22.4445,-154.3119,320.1029}\", opt = {} }\n    data[\"Chr 05\"] = { pos = \"::pos{0,7,-20.5370,-154.7507,308.0151}\", opt = {} }\n    data[\"Chr 06\"] = { pos = \"::pos{0,7,-21.6295,-155.1465,292.7660}\", opt = {} }\n    data[\"Chr Hub\"] = { pos = \"::pos{0,7,-21.9903,-153.1008,391.4632}\", opt = {} }\n    local tmp = { v = data, t = type(data) }\n    storeYFSNamedWaypoints(tmp)\n\n    YFSDB:remove(YFS_ROUTES)\n    local r = { }\n    -- r[\"Test\"] = { points = { } }\n    -- r[\"Test\"].points[1] = { pos = \"::pos{0,7,-20.8094,-153.7308,366.1022}\", waypointRef = \"Chr 01\" }\n    storeYFSRoutes({ v = r, t = type(r) })\n\n    P(\"[*] YFS test data saved!\")\n    cmd.DumpPointsCmd()\n    cmd.DumpRoutesCmd()\nend\n\nfunction cmd.ConversionTestCmd(param)\n    PM.ConversionTest()\nend\n\nfunction cmd.XCmd()\n    -- local s = \"-name C -altitude 440 -marginL 0.5 -marginF 1 -finalSpeedF 10 -suffix 'F'\"\n    -- P(\"X params: \"..params)\n    -- cmd.YfsBuildRouteFromWpCmd(s)\nend\n\nreturn cmd\nend)\npackage.preload['YFS-Tools:help.lua']=(function()\nlocal help = {}\n\nfunction help.PrintHelpCmd()\n    local hlp = \"~~~~~~~~~~~~~~~~~~~~\\nYFS-Tools Commands:\\n~~~~~~~~~~~~~~~~~~~~\\n\"..\n    \"/arch-save-named\\n-> Builds list of chat commands for ArchHud to add locations for all named waypoints.\\n\"..\n    \"/planetInfo (id or name)\\n-> Info about current planet or for passed planet id or name, e.g. 2 for Alioth).\\n\"..\n    \"/printAltitude /printPos /printWorldPos\\n-> Prints info data.\\n\"..\n    \"/warpCost -from name/::pos{}/planets -to name/::pos{}/planets -mass tons -moons\\n-> Flexible warp cell calculator.\\n\"..\n    \"/wp-altitude-ceiling\\n-> Changes a waypoint to have the higher altitude of both.\\n\"..\n    \"/wp-export\\n-> Outputs list of plain waypoints to chat and an optional screen. Source can include ArchHud locations, too, if databank linked.\\n\"..\n    \"/yfs-add-altitude-wp\\n-> Adds waypoints for each existing WP at a specified altitude and name suffix.\\n\"..\n    \"/yfs-build-route-from-wp\\n-> Powerful route-building command based on existing named waypoints.\\n\"..\n    \"/yfs-route-altitude\\n-> Changes altitude for a range of waypoints of a specific YFS route.\\n\"..\n    \"/yfs-route-nearest\\n-> Show list of route waypoints by distance from current location.\\n\"..\n    \"/yfs-route-to-named\\n-> Converts a route's *unnamed* waypoints to named waypoints for YFS.\\n\"..\n    \"/yfs-save-named\\n-> Builds list of YFS commands to recreate all named waypoints.\\n\"..\n    \"/yfs-save-route\\n-> Builds list of YFS commands to recreate full route incl. named waypoints and their options.\\n\"..\n    \"/yfs-wp-altitude\\n-> Changes altitude of a named waypoint to specified altitude.\\n\"..\n    \"----------------------------------\\n\"..\n    \"Important: Enclose names (as parameters) in single quotes if they contain blanks!\\n\"..\n    \"*** DO NOT USE COMMANDS THAT CHANGE POINTS ***\\n*** OR ROUTES WHILE YFS IS RUNNING! ***\\n\"\n    ScreenOutput(hlp)\n    P(hlp)\nend\n\nreturn help\nend)\npackage.preload['YFS-Tools:warpcost.lua']=(function()\n-- requires SU, PM\nlocal strmatch, sformat, strlen = string.match, string.format, string.len\nlocal tonum, uclamp, mabs, max, floor, ceil = tonumber, utils.clamp, math.abs, math.max, math.floor, math.ceil\n\n\n---@comment Calculates # of warp cells for distance and mass\n---@param text string List of space-separated params\nfunction CalcWarpCost(text)\n    local example = \"\\nExample 1:\\n/warpCost -from Madis -to Alioth -mass 534\"..\n        \"\\nExample 2:\\n/warpCost -from Alioth -to planets -moons\"..\n        \"\\nOptional '-from x' with x being either 'here', a planet name, ::pos{} or 'planets' (multi-result).\"..\n        \"\\nOptional '-to x' like -from, but for end location.\"..\n        \"\\nOptional '-mass x' with x the total mass in tons. If not given, the current constructs' total mass is used.\"..\n        \"\\nOptional '-cargo x' with x the cargo mass in tons. If specified, a cell count for a return trip is calculated, too.\"..\n        \"\\nOptional '-moons' only together with 'planets' to also include moons in the list.\"..\n        \"\\n- One of -from or -to can be left out, then the current construct's location (or planet) is used.\"..\n        \"\\n- If construct is landed on a planet or moon, the Atlas specified warp altitude is the starting point.\"..\n        \"\\n- Enclose names in single-quotes if they contain spaces!\"\n    local getCMass = construct.getMass\n    local pOn, onPlanet = {}, false\n    local s, s2 = \"~~~ WARP CELL CALCULATOR ~~~\", \"\"\n\n    local function checkParam(args, pName, isFrom)\n        local v, allPlanets, offs = {}, false, 0\n        local par = GetParamValue(args, pName, \"s\")\n        if not par or (par == \"\") or (par == \"here\") then\n            v = PM.WorldPosVec3() -- current position\n            if onPlanet and pOn then\n                offs = 2 * pOn.radius\n                par = pOn.name[1]\n                v = vec3(pOn.center)\n            else\n                offs = 12 -- min. 12 km warp distance\n                par = PM.Vec3ToPosString(v)\n            end\n        elseif par == \"planets\" then\n            allPlanets = true\n        elseif par > \"\" then\n            if SU.StartsWith(par, \"::pos{\") then\n                offs = 12 -- min. 12 km warp distance\n                v = PM.MapPosToWorldVec3(par)\n            else\n                local p = PM.PlanetByName(par)\n                if p then\n                    offs = 2 * p.radius\n                    v = vec3(p.center)\n                end\n            end\n        end\n        return { parm = par, v = v, isP = allPlanets, offset = offs }\n    end\n\n    local args = SU.SplitQuoted(text)\n    if #args < 1 then return E(\"[E] Parameter(s) missing!\"..example) end\n    local pMoons = GetIndex(args, \"-moons\") > 0\n\n    -- for current location, check if we are \"on\" a planet (within atmo-radius),\n    -- and set an offset of 2*radius from center as \"warp barrier\"\n    local offset = 0\n    pOn = PM.GetClosestPlanet(PM.WorldPosVec3())\n    if pOn then\n        offset = 2 * pOn.radius -- warp exclusion distance from center\n        onPlanet = PM.Altitude() < offset\n        if onPlanet then\n            s2 = \"Current\"\n        else\n            s2 = \"Nearest\"\n        end\n        s = s..\"\\n\"..s2..\" planet: \"..pOn.name[1]\n    else\n        s = s..\"\\n[I] No planet nearby!\"\n    end\n\n    ---@diagnostic disable-next-line: missing-parameter\n    local maxMass = 50000\n    ---@diagnostic disable-next-line: missing-parameter\n    local tons = getCMass(CNID) / 1000 --in globals.lua!\n\n    -- check -cargo param and value\n    local pCargo, bCargo = 0, false\n    if GetIndex(args, \"-cargo\") > 0 then\n        local tmpCargo = GetParamValue(args, \"-cargo\", \"n\")\n        tmpCargo = tmpCargo or 0\n        if tmpCargo > 0 then\n            pCargo = uclamp(tmpCargo, 0, maxMass)\n            bCargo = pCargo > 0\n        else\n            return E(s..\"\\n[E] Invalid -cargo value, must be in range of 1-50000 tons!\")\n        end\n    end\n\n    local pMass = GetParamValue(args, \"-mass\", \"n\")\n    s2 = \"Mass: \"\n    if pMass then\n        tons = tonum(pMass)\n    else\n        s2 = \"Construct \"..s2\n    end\n    s = s..\"\\n\"..s2..Out.PrettyMass(tons*1000)\n    if bCargo then\n        s = s..\"  ~*~  Cargo: \"..Out.PrettyMass(pCargo*1000)\n    end\n    if tons < 100 then -- warp drive alone is 75 tons!\n        return E(s..\"\\n[E] Impossibly low mass for a warp ship! ;)\")\n    elseif tons > maxMass then\n        return E(s..\"\\n[E] I don't accept you're warping that heavy! ;)\")\n    end\n\n    local locFrom = checkParam(args, \"-from\", true)\n    if not locFrom.isP and not locFrom.v then\n        return E(s..\"\\n[E] Invalid starting location!\")\n    end\n    local locTo = checkParam(args, \"-to\", false)\n    if not locTo.isP and not locTo.v then\n        return E(s..\"\\n[E] Invalid end location!\")\n    end\n\n    if locFrom.isP and locTo.isP then\n        return E(s..\"\\n[E] Only one 'planets' option supported!\")\n    end\n    if (locFrom.parm == locTo.parm) or (locFrom.v == locTo.v) then\n        return E(s..\"\\n[E] Start and end locations must be different!\")\n    end\n\n    local function process(from, to, distance, massT, cargo)\n        local out = \"\"\n        if from > \"\" then out = out .. from end\n        if from > \"\" and to > \"\" then out = out .. \" to \" end\n        if to > \"\" then out = out .. to end\n        out = out.. \" (\"..Out.PrettyDistance(distance)..\")\"\n\n        -- min 1 SU, max 500 SU (1 SU = 200000 m)\n        if distance < 200000 then\n            return out..\" -> too short!\"\n        elseif distance > 100000000 then\n            return out..\" -> too far!\"\n        end\n        local cnt = PM.ComputeCells(distance, massT)\n        out = out..\" = \"..cnt..\" cell\" .. SU.If(cnt > 1, \"s\")\n        if bCargo then\n            local cnt2 = PM.ComputeCells(distance, massT - cargo)\n            out = out..\" / \"..cnt2..\" cell\" .. SU.If(cnt > 1, \"s\")..\" = \"..(cnt+cnt2)..\" total\"\n        end\n        return out\n    end\n\n    -- Single source and destination\n    if not locFrom.isP and not locTo.isP then\n        local distance = mabs(vec3(locFrom.v - locTo.v):len()) - locFrom.offset - locTo.offset\n        local res = process(locFrom.parm, locTo.parm, distance, tons, pCargo)\n        if type(res) == \"string\" then\n            s = s .. \"\\n\" .. res\n            P(s)\n            ScreenOutput(s)\n        else\n            E(\"[E] Sorry, something went wrong :(\")\n        end\n        return\n    end\n\n    -- Planets processing\n    local v1, v2 = nil, nil\n    s2 = \" (Distance) / Cells\"..SU.If(bCargo, \" / Return w/o cargo\")\n    if locFrom.isP then\n        s = s..\"\\nTo: \"..locTo.parm..\"\\nFrom\"..s2\n    else\n        s = s..\"\\nFrom: \"..locFrom.parm..\"\\nTo\"..s2\n    end\n    for _,v in pairs(WaypointInfo[0]) do\n        if not v.isAsteroid and (pMoons or not v.isMoon) then\n            offset = 2 * v.radius\n            if locFrom.isP then\n                locFrom.parm = v.name[1]\n                locFrom.v = vec3(v.center)\n                offset = offset + locTo.offset\n            else\n                locTo.parm = v.name[1]\n                locTo.v = vec3(v.center)\n                offset = offset + locFrom.offset\n            end\n            local distance = mabs(vec3(locFrom.v - locTo.v):len()) - offset\n            if distance > 100000 then\n                s = s .. \"\\n\" ..\n                    process(SU.If(locFrom.isP, locFrom.parm),\n                            SU.If(locTo.isP, locTo.parm),\n                            distance, tons, pCargo)\n            end\n        end\n    end\n    P(s)\n    ScreenOutput(s)\nend\n\nend)\npackage.preload['YFS-Tools:../util/wpoint.lua']=(function()\nlocal tonum, strlen, strmatch = tonumber, string.len, string.match\n\n---@comment Simple Waypoint class to store a name with a location.\n--- No location conversions or changes are done in this class!\n--- The set method is flexible, though, in what it accepts as source for a location.\n--- @class Waypoint\nWaypoint = { mapPos = {}, name = \"\", parent = nil }\n\n-- Waypoint methods\nWaypoint.new = function(parent)\n    local obj = setmetatable(\n        { parent = parent, name = \"\",\n          mapPos = { systemId = 0, id = 0, latitude = 0.0, longitude = 0.0, altitude = 0.0 } },\n        { __index = Waypoint }\n    )\n    return obj\nend\n\n---@comment Returns the waypoint as { systemId, id, latitude, longitude, altitude }\n---@return table\nWaypoint.get = function(self)\n    return self.mapPos\nend\n\nWaypoint.getPosPattern = function()\n    local num = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\n    return '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' .. num ..  ',' .. num .. '}'\nend\n\n---@comment Sets a waypoint to the given map position (::pos{}, vec3 or table with 3 or 5 pos data)\nWaypoint.set = function(self, newMapPos)\n    if type(newMapPos) == \"string\" and strlen(newMapPos) < 16 then\n        print(\"[E] Invalid position: \"..newMapPos)\n        return {}\n    end\n\n    if type(newMapPos) == \"string\" then\n        local s, p, x, y, z = strmatch(newMapPos, self.getPosPattern())\n        if s then\n            self.mapPos.systemId = tonum(s)\n            self.mapPos.id = tonum(p)\n            self.mapPos.latitude = tonum(x)\n            self.mapPos.longitude = tonum(y)\n            self.mapPos.altitude = tonum(z)\n        else\n            print(newMapPos..\" - Invalid string format. Use '::pos{s, p, x, y, z}'.\")\n        end\n    elseif type(newMapPos) == \"table\" and #newMapPos == 3 then\n        self.mapPos.latitude = tonum(newMapPos[1])\n        self.mapPos.longitude = tonum(newMapPos[2])\n        self.mapPos.altitude = tonum(newMapPos[3])\n    elseif type(newMapPos) == \"table\" and #newMapPos == 5 then\n        self.mapPos.systemId = tonum(newMapPos[1])\n        self.mapPos.id = tonum(newMapPos[2])\n        self.mapPos.latitude = tonum(newMapPos[3])\n        self.mapPos.longitude = tonum(newMapPos[4])\n        self.mapPos.altitude = tonum(newMapPos[5])\n    elseif type(newMapPos) == \"table\" and newMapPos.x and newMapPos.y and newMapPos.z then\n        self.mapPos.systemId = 0\n        self.mapPos.id = 0\n        self.mapPos.latitude = tonum(newMapPos.x)\n        self.mapPos.longitude = tonum(newMapPos.y)\n        self.mapPos.altitude = tonum(newMapPos.z)\n    else\n        print(\"Invalid input. Provide a ::pos{} string, vec3() or {s,p,x,y,z} table.\")\n    end\n    return self\nend\n\n---@comment Set the name for the waypoint. Can be empty.\n---@param self table\nWaypoint.setName = function(self, newName)\n    if newName == nil then self.name = \"\" return end\n    if type(newName) == \"string\" and newName:gmatch(\"^%a[%w_- ]*$\") then\n        self.name = newName\n    else\n        print(tostring(newName)..\"\\n[E] WP: Invalid name format. Should only contain printable characters.\")\n    end\n    return self\nend\n\n---@comment Returns the name for the waypoint. Can be empty.\nWaypoint.getName = function(self)\n    return self.name\nend\n\n---@comment Returns just the altitude value (number).\nWaypoint.getAltitude = function(self)\n    return self.mapPos.altitude\nend\n\n---@comments Returns ::pos{} string of the waypoint\n---@return string\nWaypoint.AsString = function(self)\n    return string.format(\"::pos{%d, %d, %.4f, %.4f, %.4f}\",\n                         self.mapPos.systemId, self.mapPos.id,\n                         self.mapPos.latitude, self.mapPos.longitude, self.mapPos.altitude)\nend\n\nWaypoint.__Waypoint = function(self) return true end\nend)\npackage.preload['YFS-Tools:../util/wpointmgr.lua']=(function()\nlocal tonum, strlen, strmatch = tonumber, string.len, string.match\n\n\n---@class WaypointMgr\nWaypointMgr = { name = \"\", waypoints = {} }\n\n--- comment Add a waypoint object to the list at position 'index'\n--- @param self table\n--- @param waypoint any\n--- @param index any\n--- @return nil\nWaypointMgr.add = function(self, waypoint, index)\n    if waypoint.__Waypoint and waypoint.__Waypoint() then\n        -- If the waypoint has no name, skip duplicate check\n        if waypoint.name and waypoint.name ~= \"\" then\n            -- Check if a waypoint with the same name already exists\n            for _,v in ipairs(self.waypoints) do\n                if v.name == waypoint.name then\n                    return nil\n                end\n            end\n        end\n        local wplus1 = 1 + #self.waypoints\n        if index then\n            -- Check if the specified index is within the valid range\n            if index < 1 or index > wplus1 then\n                print(\"[E] Invalid index. Must be in the range 1 to \" .. wplus1)\n                return nil\n            end\n            waypoint.parent = self\n            table.insert(self.waypoints, index, waypoint)\n        else\n            waypoint.parent = self\n            table.insert(self.waypoints, wplus1, waypoint)\n        end\n        return waypoint\n    else\n        print(\"[E] Invalid waypoint parameter!\")\n        return nil\n    end\nend\n\n---@comment List of waypoints' data as table.\n---@return table (systemId, planetId, latitude, longitude, altitude)\nWaypointMgr.getWaypointsData = function(self)\n    local res = {}\n    for k,v in ipairs(self.waypoints) do\n        table.insert(res, k, v:get())\n    end\n    return res\nend\n\n---@comment List of all waypoints as Waypoint objects.\n---@return table Array of all Waypoint instances\nWaypointMgr.getWaypointsInst = function(self)\n    return self.waypoints\nend\n\n---@comment Returns the count of all waypoints\n---@return integer Count of all waypoints\nWaypointMgr.getCount = function(self)\n    return #self.waypoints\nend\n\n---@comment Returns array of all waypoint instances sorted by their name\n---@return table Array\nWaypointMgr.getSorted = function(self)\n    local sortedPoints = {}\n\n    -- Copy waypoints to a new table for sorting\n    for _,v in pairs(self.waypoints) do\n        table.insert(sortedPoints, v)\n    end\n\n    -- Sort the copied table by waypoint names\n    table.sort(sortedPoints, function(a, b)\n        return a.name < b.name\n    end)\n    return sortedPoints\nend\n\n---@comment Moves waypoint at given index up by one, but 1 as minimum\nWaypointMgr.moveUp = function(self, index)\n    local waypointsCount = #self.waypoints\n\n    if index and index > 1 and index <= waypointsCount then\n        self.waypoints[index], self.waypoints[index - 1] = self.waypoints[index - 1], self.waypoints[index]\n    end\nend\n\n---@comment Moves waypoint at given index down by one, but to end index as maximum\nWaypointMgr.moveDown = function(self, index)\n    local waypointsCount = #self.waypoints\n\n    if index and index >= 1 and index < waypointsCount then\n        self.waypoints[index], self.waypoints[index + 1] = self.waypoints[index + 1], self.waypoints[index]\n    end\nend\n\n---@comment Removes only the first waypoint with the given name and returns that waypoint instance, otherwise nil\n---@return any Either removed waypoint instance or nil if not found\nWaypointMgr.removeByName = function(self, waypointName)\n    for i, waypoint in ipairs(self.waypoints) do\n        if waypoint.name == waypointName then\n            local removedWaypoint = table.remove(self.waypoints, i)\n            return removedWaypoint  -- Return the removed waypoint\n        end\n    end\n    return nil  -- Return nil if not found\nend\n\n---@comment Returns true if at least one waypoint exist, else false\n---@return boolean\nWaypointMgr.hasPoints = function(self, param)\n    return #self.waypoints > 0\nend\n\n---@comment Checks if a waypoint exists in 3 different ways: name, waypoint instance or same data\n---@return any If not found, returns nil, otherwise the found waypoint instance\nWaypointMgr.exists = function(self, param)\n    for _, v in ipairs(self.waypoints) do\n        if type(param) == \"string\" and v.name == param then\n            return v\n        elseif param and param.__Waypoint and Waypoint.__Waypoint() then\n            if v == param then\n                return v\n            end\n        elseif type(param) == \"table\" and #param == 5 then\n            -- Check if a waypoint with the same nums exists\n            if v.mapPos.systemId  == tonum(param[1]) and\n               v.mapPos.id        == tonum(param[2]) and\n               v.mapPos.latitude  == tonum(param[3]) and\n               v.mapPos.longitude == tonum(param[4]) and\n               v.mapPos.altitude  == tonum(param[5]) then\n                return v\n            end\n        end\n    end\n    return nil\nend\n\nWaypointMgr.getName = function(self)\n    return self.name\nend\n\nWaypointMgr.new = function(name)\n    local obj = setmetatable(\n        { waypoints = {}, name = name or \"\" },\n        { __index = WaypointMgr }\n    )\n    return obj\nend\n\nreturn WaypointMgr\n\nend)\npackage.preload['YFS-Tools:libmain.lua']=(function()\n-- require used classes and instantiate important ones\nSU = require('YFS-Tools:../util/SU.lua') -- string utils\nOut = require('YFS-Tools:../util/out.lua') -- output utils\nP = Out.PrintLines\nE = Out.Error\n\nrequire('YFS-Tools:../util/Dtbk.lua') -- databank\n\nrequire('YFS-Tools:libutils.lua') -- helper functions\nCmd = require('YFS-Tools:commands.lua') -- all YFS Tools commands\nHelp = require('YFS-Tools:help.lua') -- help utils\n\nrequire('YFS-Tools:warpcost.lua') -- warp calculator function\n\nrequire('YFS-Tools:../util/wpoint.lua') -- waypoint class\nWM = require('YFS-Tools:../util/wpointmgr.lua').new(\"MAIN\") -- instantiate MAIN waypoint manager\n\nend)\npackage.preload['YFS-Tools:../util/pos.lua']=(function()\n--- Class related to positions/coordinates like local/world conversion etc.\n--- requires global WaypointInfo table (= atlas), vec3 library; classes SU, Out\nlocal max, cos, macos, mdeg, msin, mabs, atan, ceil, floor, mpi = math.max, math.cos, math.acos, math.deg, math.sin, math.abs, math.atan, math.ceil, math.floor, math.pi\nlocal tonum, strlen, strmatch, sformat = tonumber, string.len, string.match, string.format\nlocal uclamp, vec3 = utils.clamp, vec3\n\nlocal o = {}\no.__index = o\nfunction o.New(pCore, pConstruct, pWM)\n    -- Private attribute\n    local s = {\n        core = pCore,\n        construct = pConstruct,\n        Alioth1G = 9.891,\n        waypointNames = {},\n        waypointCount = 0,\n        planetNames = {},\n        p = {}, -- Planet object\n        pIdx = 0, -- Atlas planet index\n        wm = pWM -- Waypoint Manager instance\n    }\n\n    local function float_eq(a, b) -- float equation\n        if a == 0 then\n            return mabs(b) < 1e-09\n        elseif b == 0 then\n            return mabs(a) < 1e-09\n        else\n            return mabs(a - b) < math.max(mabs(a), mabs(b)) * epsilon\n        end\n    end\n\n    ---@return boolean\n    local function constructPresent()\n        return s.construct ~= nil\n    end\n\n    ---@return boolean\n    local function corePresent()\n        return s.core ~= nil\n    end\n\n    -- Public functions\n\n    ---@return number amount of warp cells\n    function o.ComputeCells(distance, tons)\n        return ceil(max(floor(tons*floor(((distance/1000)/200))*0.00024), 1))\n    end\n\n    ---@return string\n    function o.GetPosPattern()\n        local num = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\n        return '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' .. num ..  ',' .. num .. '}'\n    end\n\n    ---@return number # of entries in WaypointInfo/Atlas\n    function o.GetWaypointCount()\n        return s.wm:getCount()\n    end\n\n    ---@param posStr string ::pos{} string\n    ---@return table|nil returns a MapPos table of the coords or nil if invalid string\n    function o.SplitPos(posStr)\n        -- min. length is 16: \"::pos{0,1,2,3,4}\"\n        if type(posStr) ~= \"string\" then\n            P(\"[E] Invalid position: \"..type(posStr))\n            return nil\n        end\n        if strlen(posStr) < 16 or not strmatch(posStr, \"^::pos{\") then\n            P(\"[E] Invalid position: \"..posStr)\n            return nil\n        end\n        local sysId, pId, lat, lng, alt = strmatch(posStr, o.GetPosPattern())\n        return { systemId  = tonum(sysId),\n                 id        = tonum(pId),\n                 latitude  = tonum(lat),\n                 longitude = tonum(lng),\n                 altitude  = tonum(alt) }\n    end\n\n    ---@param posString string The ::pos{} string in local coords!\n    ---@return number Altitude in meters (if a local pos -> relative to sea level)\n    function o.GetAltitudeFromPos(posString)\n        local p = o.SplitPos(posStr)\n        if p and p.altitude then return p.altitude end\n        return 0\n    end\n\n    ---@param posStr string The ::pos{} string\n    ---@return integer Id of planet in Atlas, e.g. 2 for Alioth; 0 for Space!\n    function o.GetPlanetFromPos(posStr)\n        local p = o.SplitPos(posStr)\n        if p and p.id and p.id > 0 then return p.id end\n        return 0\n    end\n\n    function o.GetAtlasPlanet(pid)\n        if not pid or not WaypointInfo[0] or not WaypointInfo[0][tonum(pid)] then\n            return nil\n        end\n        return WaypointInfo[0][tonum(pid)]\n    end\n\n    function o.GetClosestPlanetId(worldPosVec)\n        local pIdx, dist = 0, 0\n        local planetDistance = math.huge\n        for i,v in pairs(WaypointInfo[0]) do\n            dist = (worldPosVec - vec3(v.center)):len()\n            if dist < planetDistance then\n                planetDistance = dist\n                pIdx = i\n            end\n        end\n        return pIdx\n    end\n\n    function o.GetClosestPlanet(worldPosVec)\n        local pid = o.GetClosestPlanetId(worldPosVec)\n        return o.GetAtlasPlanet(pid)\n    end\n\n    function o.GetCurrentPosString()\n        local v = o.WorldPosVec3()\n        return o.MapPos2String(o.WorldToMapPos(v))\n    end\n\n    ---@comment Formats a MapPos table to a ::pos{} string\n    ---@return string\n    function o.MapPos2String(mapPos)\n        if type(mapPos) ~= \"table\" then return \"\" end\n        return '::pos{' .. (mapPos.systemId or 0).. ',' .. (mapPos.id or 0) .. ',' ..\n               sformat(\"%.4f\", (mapPos.latitude or 0)) .. ',' .. \n               sformat(\"%.4f\", (mapPos.longitude or 0)) ..  ',' ..\n               sformat(\"%.4f\", (mapPos.altitude or 0)) .. '}'\n    end\n\n    ---@comment Formats a vec3 world-pos table to a ::pos{} string (planet id 0!)\n    ---@return string\n    function o.Vec3ToPosString(v3)\n        if type(v3) ~= \"table\" then return \"\" end\n        return '::pos{0,0,' ..\n               sformat(\"%.4f\", (v3.x or 0)) .. ',' ..\n               sformat(\"%.4f\", (v3.y or 0)) ..  ',' ..\n               sformat(\"%.4f\", (v3.z or 0)) .. '}'\n    end\n\n    ---@comment Formats a vec3 world-pos table to a ::pos{} string (planet id 0!)\n    ---@return string\n    function o.Vec3String(v3)\n        if type(v3) ~= \"table\" then return \"\" end\n        v3 = vec3(v3)\n        return sformat(\"%.4f\", (v3.x or 0)) .. ', ' ..\n               sformat(\"%.4f\", (v3.y or 0)) .. ', ' ..\n               sformat(\"%.4f\", (v3.z or 0))\n    end\n\n    ---@param posStr string ::pos{} string for change\n    ---@param newAltitude number? new altitude value\n    ---@return string\n    function o.ReplaceAltitudeInPos(posStr, newAltitude)\n        --TODO: move this to Waypoint class; allow class as param\n        local p = o.SplitPos(posStr)\n        if not p or not p.altitude or not newAltitude then\n            return posStr\n        end\n        p.altitude = tonum(newAltitude)\n        return o.MapPos2String(p)\n    end\n\n    ---@comment Returns current planet id if in game, otherwise 2\n    ---@return number\n    function o.PlanetId()\n        if not corePresent() then return 0 end\n        if not INGAME then\n            return 2 -- Alioth\n        end\n        return s.core.getCurrentPlanetId()\n    end\n\n    ---@comment If code is run outside of game, a fixed vec3 will be returned for testing!\n    ---@return any Vec3 position of construct (or nil)\n    function o.WorldPosVec3()\n        if not INGAME then\n            return { x = -25140.37011013, y = 100812.26194182, z = -52412.710373821}\n        end\n        if constructPresent() then\n            ---@diagnostic disable-next-line: missing-parameter\n            return vec3(construct.getWorldPosition())\n        end\n        if corePresent() then\n            ---@diagnostic disable-next-line: missing-parameter\n            return vec3(core.getWorldPosition())\n        end\n        return nil\n    end\n\n    ---@comment If close to planet, returns the current altitude\n    ---@return number Altitude in meters; 0 if not close to a planet!\n    function o.Altitude()\n        local p = o.GetAtlasPlanet(o.PlanetId())\n        if not p or not p.center then return 0 end\n        return (o.WorldPosVec3() - vec3(p.center)):len() - (p.radius or 0)\n    end\n\n    ---@comment Returns distance between\n    --- a) current construct position and the one passed in\n    ---   posStr (distTo not specified) in ::pos{0,x,...} format!\n    --- OR\n    --- b) both params specified, each separate coords.\n    ---@param posStr string ::pos() string to measure FROM\n    ---@param distTo nil optional ::pos() to measure TO; if empty -> current position\n    ---@return number\n    function o.GetDistance(posStr, distToStr)\n        local curPos = o.WorldPosVec3()\n        if type(distToStr) == \"string\" then\n            curPos = o.MapPosToWorldVec3(distToStr)\n        elseif type(distToStr) == \"table\" then\n            curPos = vec3(distToStr)\n        end\n        local wPos = o.MapPosToWorldVec3(posStr)\n        local dist = vec3(wPos - curPos):len()\n        return dist\n    end\n\n    ---@comment experimental/unused; credit to Jeronimo\n    ---@return number,number,number with x,y,z\n    function o.World2local(x,y,z)\n        --if not o.construct then return 0,0,0 end\n        local cWOUP = s.construct.getWorldOrientationUp()\n        local cWOF = s.construct.getWorldOrientationForward()\n        local cWOR = s.construct.getWorldOrientationRight()\n        local cWOUPx, cWOUPy, cWOUPz = cWOUP[1], cWOUP[2], cWOUP[3]\n        local cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]\n        local cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]\n\n        local v = library.systemResolution3(\n            {cWORx,  cWORy, cWORz},\n            {cWOFx,  cWOFy, cWOFz},\n            {cWOUPx, cWOUPy, cWOUPz},\n            {x, y, z})\n        return v[1],v[2],v[3]\n    end\n\n    ---@param v table the vec3() position to convert\n    ---@return any MapPos table or nil\n    function o.WorldToMapPos(v)\n        local body = o.GetClosestPlanet(v)\n        if not body or not body.center or not body.radius then\n            return { systemId = 0, id = 0, latitude = v.x, longitude = v.y, altitude = v.z }\n        end\n        local coords = v - vec3(body.center)\n        local dist = coords:len()\n        local alt = dist - body.radius\n        local latitude = 0\n        local longitude = 0\n        if not float_eq(dist, 0) then\n            local phi = atan(coords.y, coords.x)\n            --phi >= 0 ???\n            longitude = phi or (2 * mpi + phi)\n            latitude = mpi / 2 - macos(coords.z / dist)\n        end\n        return {\n            latitude  = mdeg(latitude),\n            longitude = mdeg(longitude),\n            altitude  = alt,\n            id        = body.systemId,\n            systemId  = body.id }\n    end\n\n    function o.PlanetByName(name)\n        if type(name) ~= \"string\" or name == \"\" then return nil end\n        name = name:lower()\n        if s.planetNames[name] then\n            local pid = tonum(s.planetNames[name])\n            return WaypointInfo[0][pid]\n        end\n        return nil\n    end\n\n    ---comment Converts ::pos{} string into vec3\n    ---@param posStr string ::pos{} string\n    ---@return any vec3() or nil\n    function o.MapPosToWorldVec3(posStr)\n        local p = o.SplitPos(posStr)\n        if not p or not p.systemId then return nil end\n        if (p.systemId == 0 and p.id == 0) then -- already WorldPos\n            return vec3(p.latitude, p.longitude, p.altitude)\n        end\n        if not WaypointInfo[p.systemId] then return nil end\n        local planet = WaypointInfo[p.systemId][p.id]\n        --credits to Saga for lat/lon calc\n        local lat = constants.deg2rad * uclamp(p.latitude, -90, 90)\n        local lon = constants.deg2rad * (p.longitude % 360)\n        local xproj = cos(lat)\n        local planetxyz = vec3(xproj*cos(lon), xproj*msin(lon), msin(lat))\n        return vec3(planet.center) + (planet.radius + p.altitude) * planetxyz\n    end\n\n    function o.PlanetInfo(id)\n        local pid = nil\n        if type(id) == \"string\" and id:len() == 0 then\n            id = o.GetClosestPlanetId(o.WorldPosVec3())\n        end\n        if type(id) == \"string\" and s.planetNames[id:lower()] then -- id as planet name\n            pid = tonum(s.planetNames[id:lower()])\n        elseif type(id) == \"number\" and tonum(id) > 0 then -- id as planet id\n            pid = tonum(id)\n        end\n        if pid == nil then\n            return E(\"[E] No valid planet name or id specified!\")\n        end\n        local p = o.GetAtlasPlanet(pid)\n        if not p or type(p.name) ~= \"table\" then\n            return E(\"[E] No planet found!\")\n        end\n        P\"~~~~~~~~ PLANET INFO ~~~~~~~~\"\n        if id == '' then\n          P(\"Hint: '/planetInfo 2' for Alioth\")\n        end\n        P(\"Name: \"..p.name[1]..\" (Id: \".. p.id ..\")\")\n        P(\"Center: \"..p.center[1]..\" / \"..p.center[2]..\" / \"..p.center[3])\n        P(\"Radius: \"..(p.radius or 0)..\"m\")\n        local tmp = \"\"\n        if p.gravity and p.gravity > 0 then\n            tmp = \" (\"..sformat(\"%.1f\", (p.gravity / s.Alioth1G)) ..\" g)\"\n        end\n        P(\"Gravity: \"..(p.gravity or 0)..tmp)\n        if p.satellites and #p.satellites > 0 then\n          P(\"Has Moons: \"..#p.satellites)\n        end\n        P(\"Surface Min Alt.: \"..(p.surfaceMinAltitude or 0)..\"m\")\n        P(\"Surface Max Alt.: \"..(p.surfaceMaxAltitude or 0)..\"m\")\n        P(\"Max Static Alt.: \"..(p.maxStaticAltitude or \"\")..\"m\")\n        P(\"Has atmosphere: \"..BoolStr(p.hasAtmosphere))\n        if p.hasAtmosphere then\n          P(\"Atmo Thickness: \"..(p.atmosphereThickness or 0)..\"m\")\n          P(\"Atmo altitude: \"..(p.atmoAltitude or 0)..\"m\")\n          P(\"Atmo 10%: \"..(p.atmo10 or 0)..\"m\")\n        end\n        P(\"Is in Safe Zone: \"..BoolStr(p.isInSafeZone))\n        P\"~~~~~~~~~~~~~~~~~~~~~~~~~~~\"\n    end\n\n    ---@comment Adds a named waypoint to the internal list.\n    --- Source position string can be local or world position.\n    --- World position will be converted to local and ::pos{}\n    --- changed accordingly - IF a closest body was in range.\n    ---@param posString string Local or world ::pos{} string\n    ---@param wpName string Name of the newly named waypoint\n    ---@return boolean true if added else false\n    function o.CreateWaypoint(posString, wpName)\n        if not s.wm or not wpName or wpName == '' or s.waypointNames[wpName] then\n            return false\n        end\n\n        -- convert between local and world pos if needed\n        local p = o.SplitPos(posString)\n        if not p or not p.systemId then return false end\n\n        local pcenter = { p.latitude, p.longitude, p.altitude }\n        -- if world pos, try to determine planet\n        if p.id == 0 then\n            local w = o.WorldToMapPos(vec3(pcenter))\n            if w and w.id and w.id > 0 then\n                -- update pos with converted values\n                p.latitude  = w.latitude\n                p.longitude = w.longitude\n                p.altitude  = w.altitude\n                p.id        = w.id\n                p.systemId  = w.systemId\n                posString = o.MapPos2String(p)\n            end\n        else\n            local v = o.MapPosToWorldVec3(posString)\n            pcenter = { v.x, v.y, v.z }\n        end\n\n        -- add waypoint to waypoint manager\n        local wp = Waypoint:new(s.wm):setName(wpName):set(posString)\n        if not wp or wp == {} then return false end\n        if s.wm:exists(wp) then return false end\n        return s.wm:add(wp)\n    end\n\n    ---@comment Simple test for coord conversion\n    function o.ConversionTest()\n        local p1 = \"::pos{0,2,35.5118,104.0375,285.3076}\"\n        local w1 = o.MapPosToWorldVec3(p1)\n        P(\"HQ local to world:\\n\"..p1..\" =\")\n        P(o.Vec3ToPosString(w1))\n        local w2 = o.WorldToMapPos(w1)\n        Out.DeepPrint(w2)\n        P(\"World to local (should show same as above):\")\n        P(o.MapPos2String(w2))\n\n        local wp = \"::pos{0,0,-24955.2183,99771.5731,-52908.1353}\"\n        if o.CreateWaypoint(wp, \"WorldPos\") then\n          P(\"Added 'WorldPos' waypoint\")\n        else\n          P(\"Failed to add test waypoint!\")\n        end\n    end\n\n    local function init()\n        s.pIdx = 0\n        s.p = o.GetAtlasPlanet(o.PlanetId())\n        if s.p then s.pIdx = s.p.id end\n        if not WaypointInfo[0] then return end\n        s.planetNames = {}\n        for i, v in pairs(WaypointInfo[0]) do\n            s.planetNames[v.name[1]:lower()] = i\n            -- remove junk\n            WaypointInfo[0][i].biosphere = nil\n            WaypointInfo[0][i].classification = nil\n            WaypointInfo[0][i].description = nil\n            WaypointInfo[0][i].habitability = nil\n            WaypointInfo[0][i].ores = nil\n            -- new props\n            if v.hasAtmosphere then\n                local res = v.atmosphereRadius - v.radius\n                WaypointInfo[0][i].atmoAltitude = res\n                WaypointInfo[0][i].atmo10 = res * 0.9\n            end\n            WaypointInfo[0][i].isAsteroid = WaypointInfo[0][i].type[1] == \"Asteroid\"\n            WaypointInfo[0][i].isMoon = WaypointInfo[0][i].type[1] == \"Moon\"\n            WaypointInfo[0][i].isPlanet = WaypointInfo[0][i].type[1] == \"Planet\"\n        end\n\n        --s.wm = WaypointMgr.new(\"MAIN\")\n        if s.wm then\n            P(\"[I] WaypointMgr assigned: \"..s.wm:getName())\n        else\n            P(\"[E] NO WaypointMgr assigned!\")\n        end\n    end\n\n    init()\n    return setmetatable(s, o)\nend -- .New\n\nreturn o\nend)\npackage.preload['YFS-Tools:startup.lua']=(function()\n---@diagnostic disable: undefined-field\nlocal onlyForRoute=\"\"--export: Load waypoints only for this route (enclosed in double quotes!)\nlocal onlySelectableWP=true--export: Check to only display custom route waypoints that are marked as selectable\nlocal loadWaypoints=true--export: Enable to load custom waypoints from databank\nlocal outputFont=\"FiraMono\"--export: Name of font used for screen output. Default: \"FiraMono\"\n\nonlyForRoute = onlyForRoute or \"\"\nOutputFont = outputFont or \"FiraMono\"\n\nP(\"=========================================\")\nP(\"YFS-Tools 1.5.1 (unofficial)\")\nP(\"created by tobitege (c) 2023\")\nP(\"Thanks to Yoarii (SVEA) for YFS and LUA help!\")\nP(\"YFS 1.4+ databank link required (Routes).\")\nP(\"=========================================\")\nP(\"* WARNING: do not run commands that change\")\nP(\"* waypoints/routes while YFS runs!\")\nP(\"=========================================\")\nP(\"LUA parameter(s):\")\nP(\"Load waypoints from databank: \" .. BoolStr(loadWaypoints))\nP(\"Only waypoints for route: \" .. onlyForRoute)\nP(\"Only selectable waypoints: \" .. BoolStr(onlySelectableWP))\nP(\"Screen output font name: \" .. OutputFont)\nP(\"=========================================\")\n\nlocal status, err = false, nil\nif INGAME then\n    status, err, _ = xpcall(function()\n        Config.core = library.getCoreUnit()\n        Config.databanks = library.getLinksByClass('DataBank', true) -- true is important!\n        Config.screens = library.getLinksByClass('Screen', true)\n    end, Traceback)\n    if not status then\n        P(\"Error in Link Detection:\\n\" .. err)\n        unit.exit()\n        return\n    end\nelse\n    -- this requires du-mocks\n    Config.core = unit.core\n    Config.databanks =  { unit.databank }\n    Config.screens =  { unit.screen }\nend\n\nif Config.core == nil then\n    P(\"[E] No Core connected! Ending script.\")\n    unit.exit()\n    return\nend\n\nPM = require('YFS-Tools:../util/pos.lua').New(Config.core, construct, WM) -- Positions and waypoint management\n\nif #Config.databanks > 0 then\n    local plural = \"\"\n    if #Config.databanks > 1 then plural = \"s\" else plural = \" '\"..Config.databanks[1].getName()..\"'\" end\n    P(#Config.databanks .. \" databank\" .. plural .. \" connected.\")\nelse\n    P(\"[E] DataBank not found.\")\nend\n\nif #Config.screens > 0 then\n    local plural = \"\"\n    if #Config.screens > 1 then plural = \"s\" end\n    P(#Config.screens .. \" screen\" .. plural .. \" connected.\")\nend\n\n-- for local debugging, see mockaround file for demo data!\nif not INGAME then\n    onlyForRoute = \"Hema\"\nend\n\n-- load waypoints from databank(s) (ArchHUD or YFS)?\nif loadWaypoints ~= true then\n    P(\"[I] Waypoints loading is off.\")\nelseif #Config.databanks > 0 then\n    local prevCount = 0\n    for ix=1, #Config.databanks, 1 do\n        ---@diagnostic disable-next-line: assign-type-mismatch\n        local db = Config.databanks[ix] ---@type table DataBank\n        P(\"===== Checking db '\"..db.getName()..\"' =====\")\n        if db.hasKey(ARCH_SAVED_LOCATIONS) then\n            P('ArchHud databank detected.')\n            DetectedArch = ix\n            local names = db.getStringValue(ARCH_SAVED_LOCATIONS)\n            if names ~= \"\" then\n                P('Searching stored locations...')\n                local locations = json.decode(names)\n                if IsTable(locations) then\n                    Cmd.GetStoredLocations(locations)\n                end\n            end\n        end\n        if db.hasKey(YFS_ROUTES) or db.hasKey(YFS_NAMED_POINTS) then\n            P('YFS databank detected.')\n            YFSDB = Dtbk.new(db)\n            DetectedYFS = true\n            if not onlySelectableWP then\n                Cmd.YFSLoadNamedWaypoints()\n            end\n            Cmd.YFSLoadRoutepoints(onlySelectableWP, onlyForRoute)\n        end\n        local count = PM.GetWaypointCount()\n        if count == prevCount then\n            P(\"[I] No waypoints loaded from db \"..ix)\n        else\n            P(\"[I] \"..(count - prevCount)..\" waypoints loaded from db \"..ix)\n        end\n        prevCount = PM.GetWaypointCount()\n    end\n    P(\"=======================\")\n    if PM.GetWaypointCount() > 0 then\n        P(\"[I] Total \"..PM.GetWaypointCount()..\" waypoints loaded.\")\n    else\n        P(\"[I] No waypoints loaded.\")\n    end\n    P(\"=======================\")\nend\nend)\npackage.preload['YFS-Tools:sys_onInputText.lua']=(function()\n-- requires utils, global instances Cmd, SU\n\nlocal inputTextFunc = {}\n\nfunction inputTextFunc.Run(t)\n    if not SU.StartsWith(t, \"/\") then return end\n    if not Cmd then\n        return E(\"[FATAL ERROR] Commands processor not assigned!\")\n    end\n    local cmdList = {}\n    cmdList['arch-save-named'] = 1\n    cmdList['conversionTest'] = 1\n    cmdList['posData'] = 1\n    cmdList['help'] = 'Help'\n    cmdList['planetInfo'] = 1\n    cmdList['printAltitude'] = 1\n    cmdList['printPos'] = 1\n    cmdList['printWorldPos'] = 1\n    cmdList['warpCost'] = 1\n    cmdList['wp-altitude-ceiling'] = 1\n    cmdList['wp-export'] = 1\n    cmdList['yfs-add-altitude-wp'] = 1\n    cmdList['yfs-build-route-from-wp'] = 1\n    cmdList['yfs-save-named'] = 1\n    cmdList['yfs-save-route'] = 1\n    cmdList['yfs-replace-wp'] = 1\n    cmdList['yfs-route-altitude'] = 1\n    cmdList['yfs-route-nearest'] = 1\n    cmdList['yfs-route-to-named'] = 1\n    cmdList['yfs-wp-altitude'] = 1\n    cmdList['DumpRoutes'] = 1\n    cmdList['DumpPoints'] = 1\n    cmdList['routes'] = 1\n    if DEBUG then\n        cmdList['YfsTestData'] = 1\n        cmdList['x'] = 1\n    end\n\n    for k, func in pairs(cmdList) do\n        if SU.StartsWith(t, \"/\"..k) then\n            local params = t:sub(k:len()+2) or \"\"\n            params = SU.Trim(params)\n            if k == 'help' then -- special case\n                k = \"PrintHelp\"\n            end\n            -- map command to function name, which must end with \"Cmd\"!\n            local fn = SU.SplitAndCapitalize(k,'-')..\"Cmd\"\n            -- default use global Cmd class, unless a value is specified other than 1\n            local cmdName = SU.If(type(func) == \"string\", func, \"Cmd\")\n            P(\"Executing /\"..k..SU.If(params ~= \"\", \" with: \"..params))\n            if not _G[cmdName] then\n                return E(\"[FATAL ERROR] \"..cmdName..\" not found!\")\n            end\n            if _G[cmdName][fn] then\n                return _G[cmdName][fn](params)\n            end\n        end\n    end\n    P(\"~~~~~~~~~~~~~~~~~~~~~\")\n    P(\"[E] Unknown command: \"..t)\n    P(\"[I] Supported commands:\")\n    for _,fn in ipairs(GetSortedAssocKeys(cmdList)) do\n       P(\"/\"..fn)\n    end\nend\n\nreturn inputTextFunc\nend)\npackage.preload['YFS-Tools:../util/wpointer/1-FunctionManager.lua']=(function()\nfunction LinkedList(name, prefix)\n    local functions = {}\n    local internalDataTable = {}\n    local internalTableSize = 0\n    local removeKey,addKey,indexKey,refKey = prefix .. 'Remove',prefix .. 'Add',prefix..'index',prefix..'ref'\n\n    functions[removeKey] = function (node)\n        local tblSize,internalDataTable = internalTableSize,internalDataTable\n        if tblSize > 1 then\n            if node[indexKey] == -1 then return end\n            local lastElement,replaceNodeIndex = internalDataTable[tblSize],node[indexKey]\n            internalDataTable[replaceNodeIndex] = lastElement\n            internalDataTable[tblSize] = nil\n            lastElement[indexKey] = replaceNodeIndex\n            internalTableSize = tblSize - 1\n            node[indexKey] = -1\n            node[refKey] = nil\n        elseif tblSize == 1 then\n            internalDataTable[1] = nil\n            internalTableSize = 0\n            node[indexKey] = -1\n            node[refKey] = nil\n        end\n    end\n\n    functions[addKey] = function (node, override)\n        local indexKey,refKey = indexKey,refKey\n        if node[indexKey] and node[indexKey] ~= -1 then\n            if not node[refKey] == functions or override then\n                node[refKey][removeKey](node)\n            else\n                return\n            end\n        end\n        local tblSize = internalTableSize + 1\n        internalDataTable[tblSize] = node\n        node[indexKey] = tblSize\n        node[refKey] = functions\n        internalTableSize = tblSize\n    end\n\n    functions[prefix .. 'GetData'] = function ()\n        return internalDataTable, internalTableSize\n    end\n\n    return functions\nend\n\nlocal math = math\nlocal sin, cos, rad = math.sin,math.cos,math.rad\n\nfunction RotMatrixToQuat(m1,m2,m3)\n    local m11,m22,m33 = m1[1],m2[2],m3[3]\n    local t=m11+m22+m33\n    if t>0 then\n        local s=0.5/(t+1)^(0.5)\n        return (m2[3]-m3[2])*s,(m3[1]-m1[3])*s,(m1[2]-m2[1])*s,0.25/s\n    elseif m11>m22 and m11>m33 then\n        local s = 1/(2*(1+m11-m22-m33)^(0.5))\n        return 0.25/s,(m2[1]+m1[2])*s,(m3[1]+m1[3])*s,(m2[3]-m3[2])*s\n    elseif m22>m33 then\n        local s=1/(2*(1+m22-m11-m33)^(0.5))\n        return (m2[1]+m1[2])*s,0.25/s,(m3[2]+m2[3])*s,(m3[1]-m1[3])*s\n    else\n        local s=1/(2*(1+m33-m11-m22)^(0.5))\n        return (m3[1]+m1[3])*s,(m3[2]+m2[3])*s,0.25/s,(m1[2]-m2[1])*s\n    end\nend\n\nfunction GetQuaternion(x,y,z,w)\n    if type(x) == 'number' then\n        if w == nil then\n            if x == x and y == y and z == z then\n                local rad,sin,cos = rad,sin,cos\n                x,y,z = -rad(x * 0.5),rad(y * 0.5),-rad(z * 0.5)\n                local sP,sH,sR=sin(x),sin(y),sin(z)\n                local cP,cH,cR=cos(x),cos(y),cos(z)\n                return (sP*cH*cR-cP*sH*sR),(cP*sH*cR+sP*cH*sR),(cP*cH*sR-sP*sH*cR),(cP*cH*cR+sP*sH*sR)\n            else\n                return 0,0,0,1\n            end\n        else\n            return x,y,z,w\n        end\n    elseif type(x) == 'table' then\n        if #x == 3 then\n            local x,y,z,w = RotMatrixToQuat(x, y, z)\n            return x,y,z,-w\n        elseif #x == 4 then\n            return x[1],x[2],x[3],x[4]\n        else\n            print('[E] Unsupported Rotation!')\n        end\n    end\nend\nfunction QuaternionMultiply(ax,ay,az,aw,bx,by,bz,bw)\n    return ax*bw+aw*bx+ay*bz-az*by,\n    ay*bw+aw*by+az*bx-ax*bz,\n    az*bw+aw*bz+ax*by-ay*bx,\n    aw*bw-ax*bx-ay*by-az*bz\nend\n\nfunction RotatePoint(ax,ay,az,aw,oX,oY,oZ,wX,wY,wZ)\n    local t1,t2,t3 = 2*(ax*oY - ay*oX),2*(ax*oZ - az*oX),2*(ay*oZ - az*oY)\n    return \n    oX + ay*t1 + az*t2 + aw*t3 + wX,\n    oY - ax*t1 - aw*t2 + az*t3 + wY,\n    oZ + aw*t1 - ax*t2 - ay*t3 + wZ\nend\nfunction getRotationManager(out_rotation, wXYZ, name)\n    --====================--\n    --Local Math Functions--\n    --====================--\n    local print,unpack,multiply,rotatePoint,getQuaternion = DUSystem.print,table.unpack,QuaternionMultiply,RotatePoint,GetQuaternion\n\n    local superManager,needsUpdate,notForwarded,needNormal = nil,false,true,false\n    local outBubble = nil\n    --=================--\n    --Positional Values--\n    --=================--\n    local pX,pY,pZ = wXYZ[1],wXYZ[2],wXYZ[3] -- These are original values, for relative to super rotation\n    local positionIsRelative = false\n    local doRotateOri,doRotatePos = true,true\n    local posY = math.random()*0.00001\n\n    --==================--\n    --Orientation Values--\n    --==================--\n    local tix,tiy,tiz,tiw = 0,0,0,1 -- temp intermediate rotation values\n\n    local ix,iy,iz,iw = 0,0,0,1 -- intermediate rotation values\n    local nx,ny,nz = 0,1,0\n\n    local subRotQueue = {}\n    local subRotations = LinkedList(name, 'sub')\n\n    --==============--\n    --Function Array--\n    --==============--\n    local out = {}\n\n    --=======--\n    --=Cache=--\n    --=======--\n    local cache = {0,0,0,1,0,0,0,0,0,0}\n    \n    --============================--\n    --Primary Processing Functions--\n    --============================--\n    local function process(wx,wy,wz,ww,lX,lY,lZ,lTX,lTY,lTZ)\n        if not wx then\n            wx,wy,wz,ww,lX,lY,lZ,lTX,lTY,lTZ = unpack(cache)\n        else\n            cache = {wx,wy,wz,ww,lX,lY,lZ,lTX,lTY,lTZ}\n        end\n        local dx,dy,dz = pX,pY,pZ\n        if not positionIsRelative then\n            dx,dy,dz = dx - lX, dy - lY, dz - lZ\n        end\n        if doRotatePos then\n            wXYZ[1],wXYZ[2],wXYZ[3] = rotatePoint(wx,wy,wz,-ww,dx,dy,dz,lTX,lTY,lTZ)\n        else\n            wXYZ[1],wXYZ[2],wXYZ[3] = dx+lTX,dy+lTY,dz+lTZ\n        end\n        if doRotateOri then\n            wx,wy,wz,ww = multiply(ix,iy,iz,iw,wx,wy,wz,ww)\n        else\n            wx,wy,wz,ww = ix,iy,iz,iw\n        end\n\n        out_rotation[1],out_rotation[2],out_rotation[3],out_rotation[4] = wx,wy,wz,ww\n        if needNormal then\n            nx,ny,nz = 2*(wx*wy+wz*ww),1-2*(wx*wx+wz*wz),2*(wy*wz-wx*ww)\n        end\n        local subRots,subRotsSize = subRotations.subGetData()\n\n        for i=1, subRotsSize do\n            subRots[i].update(wx,wy,wz,ww,pX,pY,pZ,wXYZ[1],wXYZ[2],wXYZ[3])\n        end\n        needsUpdate = false\n        notForwarded = true\n    end\n    out.update = process\n    local function validate()\n        if not superManager then\n            process()\n        else\n            superManager.bubble()\n        end\n    end\n    local function rotate()\n        local tx,ty,tz,tw = getQuaternion(tix,tiy,tiz,tiw)\n        if tx ~= ix or ty~= iy or tz ~= iz or tw ~= iw then\n            ix, iy, iz, iw = tx, ty, tz, tw\n            validate()\n            out.bubble()\n            return true\n        end\n        return false\n    end\n    function out.enableNormal()\n        needNormal = true\n    end\n    function out.disableNormal()\n        needNormal = false\n    end\n    function out.setSuperManager(rotManager)\n        superManager = rotManager\n        if not rotManager then\n            cache = {0,0,0,1,0,0,0,0,0,0}\n            needsUpdate = true\n        end\n    end\n    function out.addToQueue(func)\n        if not needsUpdate then\n            subRotQueue[#subRotQueue+1] = func\n        end\n    end\n\n    function out.addSubRotation(rotManager)\n        rotManager.setSuperManager(out)\n        subRotations.subAdd(rotManager, true)\n        out.bubble()\n    end\n    function out.remove()\n        if superManager then\n            superManager.removeSubRotation(out)\n            out.setSuperManager(false)\n            out.bubble()\n        end\n    end\n    function out.removeSubRotation(sub)\n        sub.setSuperManager(false)\n        subRotations.subRemove(sub)\n    end\n    function out.bubble()\n        if superManager and not needsUpdate then\n            subRotQueue = {}\n            needsUpdate = true\n            notForwarded = false\n            superManager.addToQueue(process)\n        else\n            needsUpdate = true\n        end\n    end\n\n    function out.checkUpdate()\n        local neededUpdate = needsUpdate\n        if neededUpdate and notForwarded then\n            process()\n            subRotQueue = {}\n        elseif notForwarded then\n            for i=1, #subRotQueue do\n                subRotQueue[i]()\n            end\n            subRotQueue = {}\n        else\n            superManager.checkUpdate()\n        end\n        return neededUpdate\n    end\n    local outBubble = out.bubble\n    local function assignFunctions(inFuncArr,specialCall)\n        inFuncArr.update = process\n        function inFuncArr.getPosition() return pX,pY,pZ end\n        function inFuncArr.getRotationManger() return out end\n        function inFuncArr.getSubRotationData() return subRotations.subGetData() end\n        inFuncArr.checkUpdate = out.checkUpdate\n        function inFuncArr.setPosition(tx,ty,tz)\n            if type(tx) == 'table' then\n                tx,ty,tz = tx[1],tx[2],tx[3]\n            end\n            if not (tx ~= tx or ty ~= ty or tz ~= tz)  then\n                local tmpY = ty+posY\n                if pX ~= tx or pY ~= tmpY or pZ ~= tz then\n                    pX,pY,pZ = tx,tmpY,tz\n                    outBubble()\n                    return true\n                end\n            end\n            return false\n        end\n        function inFuncArr.getNormal()\n            return nx,ny,nz\n        end\n        function inFuncArr.rotateXYZ(rotX,rotY,rotZ,rotW)\n            if rotX and rotY and rotZ then\n                tix,tiy,tiz,tiw = rotX,rotY,rotZ,rotW\n                rotate()\n                if specialCall then specialCall() end\n            else\n                if type(rotX) == 'table' then\n                    if #rotX == 3 then\n                        tix,tiy,tiz,tiw = rotX[1],rotX[2],rotX[3],nil\n                        local result = rotate()\n                        if specialCall then specialCall() end\n                        goto valid  \n                    end\n                end\n                print('Invalid format. Must be three angles, or right, forward and up vectors, or a quaternion. Use radians if angles.')\n                ::valid::\n                return false\n            end\n\n        end\n\n        function inFuncArr.rotateX(rotX) tix = rotX; tiw = nil; rotate(); if specialCall then specialCall() end end\n        function inFuncArr.rotateY(rotY) tiy = rotY; tiw = nil; rotate(); if specialCall then specialCall() end end\n        function inFuncArr.rotateZ(rotZ) tiz = rotZ; tiw = nil; rotate(); if specialCall then specialCall() end end\n\n        function inFuncArr.setDoRotateOri(rot) doRotateOri = rot; outBubble() end\n        function inFuncArr.setDoRotatePos(rot) doRotatePos = rot; outBubble() end\n        \n        function inFuncArr.setPositionIsRelative(isRelative) positionIsRelative = isRelative; outBubble() end\n        function inFuncArr.getRotation() return ix, iy, iz, iw end\n    end\n    out.assignFunctions = assignFunctions\n\n    return out\nend\nend)\npackage.preload['YFS-Tools:../util/wpointer/2-Object.lua']=(function()\npositionTypes = {\n    globalP=false,\n    localP=true\n}\norientationTypes = {\n    globalO=false,\n    localO=true\n}\nlocal print = DUSystem.print\nfunction ObjectGroup(objects, transX, transY)\n    local objects=objects or {}\n    local self={style='',gStyle='',class='default', objects=objects,transX=transX,transY=transY,enabled=true,glow=false,gRad=10,scale = false,isZSorting=true}\n    function self.addObject(object, id)\n        local id=id or #objects+1\n        objects[id]=object\n        return id\n    end\n    function self.removeObject(id) objects[id] = {} end\n\n    function self.hide() self.enabled = false end\n    function self.show() self.enabled = true end\n    function self.isEnabled() return self.enabled end\n    function self.setZSort(isZSorting) self.isZSorting = isZSorting end\n\n    function self.setClass(class) self.class = class end\n    function self.setStyle(style) self.style = style end\n    function self.setGlowStyle(gStyle) self.gStyle = gStyle end\n    function self.setGlow(enable,radius,scale) self.glow = enable; self.gRad = radius or self.gRad; self.scale = scale or false end\n    return self\nend\nConstructReferential = getRotationManager({0,0,0,1},{0,0,0}, 'Construct')\nConstructReferential.assignFunctions(ConstructReferential)\nConstructOriReferential = getRotationManager({0,0,0,1},{0,0,0}, 'ConstructOri')\nConstructOriReferential.assignFunctions(ConstructOriReferential)\nfunction Object(posType, oriType)\n\n    local multiGroup,singleGroup,uiGroups={},{},{}\n    local positionType=positionType\n    local orientationType=orientationType\n    local ori = {0,0,0,1}\n    local position = {0,0,0}\n    local objRotationHandler = getRotationManager(ori,position, 'Object Rotation Handler')\n\n    local self = {\n        true, -- 1\n        multiGroup, -- 2\n        singleGroup, -- 3\n        uiGroups, -- 4\n        ori, -- 5\n        position, -- 6\n        oriType, -- 7\n        posType -- 8\n    }\n    objRotationHandler.assignFunctions(self)\n    self.setPositionIsRelative(true)\n    self.setPositionIsRelative = nil\n    function self.hide() self[1] = false end\n    function self.show() self[1] = true end\n\n    local loadUIModule = LoadUIModule\n    if loadUIModule == nil then\n        --print('No UI Module installed.')\n        loadUIModule = function() end\n    end\n    local loadPureModule = LoadPureModule\n    if loadPureModule == nil then\n        --print('No Pure Module installed.')\n        loadPureModule = function() end\n    end\n\n    loadPureModule(self, multiGroup, singleGroup)\n    loadUIModule(self, uiGroups, objRotationHandler)\n    local function choose()\n        objRotationHandler.remove()\n        local oriType,posType = self[7],self[8]\n        if oriType and posType then\n            ConstructReferential.addSubRotation(objRotationHandler)\n        elseif oriType then\n            ConstructOriReferential.addSubRotation(objRotationHandler)\n        end\n        self.setDoRotateOri(oriType)\n        self.setDoRotatePos(posType)\n    end\n    choose()\n    function self.setOrientationType(orientationType)\n        self[7] = orientationType\n        choose()\n    end\n    function self.setPositionType(positionType)\n        self[8] = positionType\n        choose()\n    end\n    function self.getRotationManager()\n        return objRotationHandler\n    end\n    function self.addSubObject(object)\n        return objRotationHandler.addSubRotation(object.getRotationManager())\n    end\n    function self.removeSubObject(id)\n        objRotationHandler.removeSubRotation(id)\n    end\n\n    return self\nend\n\nfunction ObjectBuilderLinear()\n    local self = {}\n    function self.setPositionType(positionType)\n        local self = {}\n        local positionType = positionType\n        function self.setOrientationType(orientationType)\n            local self = {}\n            local orientationType = orientationType\n            function self.build()\n                return Object(positionType, orientationType)\n            end\n            return self\n        end\n        return self\n    end\n    return self\nend\nend)\npackage.preload['YFS-Tools:../util/wpointer/3-PureModule.lua']=(function()\nfunction LoadPureModule(self, singleGroup, multiGroup)\n\n    function self.getMultiPointBuilder(groupId)\n        local builder = {}\n        local multiplePoints = LinkedList('','')\n        multiGroup[#multiGroup+1] = multiplePoints\n        function builder.addMultiPointSVG()\n            local shown = false\n            local pointSetX,pointSetY,pointSetZ={},{},{}\n            local mp = {pointSetX,pointSetY,pointSetZ,false,false}\n            local self={}\n            local pC=1\n            function self.show()\n                if not shown then\n                    shown = true\n                    multiplePoints.Add(mp)\n                end\n            end\n            function self.hide()\n                if shown then \n                    shown = false\n                    multiplePoints.Remove(mp)\n                end\n            end\n            function self.addPoint(point)\n                pointSetX[pC]=point[1]\n                pointSetY[pC]=point[2]\n                pointSetZ[pC]=point[3]\n                pC=pC+1\n                return self\n            end\n            function self.setPoints(bulk)\n                for i=1,#bulk do\n                    local point = bulk[i]\n                    pointSetX[i]=point[1]\n                    pointSetY[i]=point[2]\n                    pointSetZ[i]=point[3]\n                end\n                pC=#bulk+1\n                return self\n            end\n            function self.setDrawFunction(draw)\n                mp[4] = draw\n                return self\n            end\n            function self.setData(dat)\n                mp[5] = dat\n                return self\n            end\n            function self.build()\n                if pC > 1 then\n                    multiplePoints.Add(mp)\n                    shown = true\n                else print(\"WARNING! Malformed multi-point build operation, no points specified. Ignoring.\")\n                end\n            end\n            return self\n        end\n        return builder\n    end\n\n    function self.getSinglePointBuilder(groupId)\n        local builder = {}\n        local points = LinkedList('','')\n        singleGroup[#singleGroup+1] = points\n        function builder.addSinglePointSVG()\n            local shown = false\n            local outArr = {false,false,false,false,false}\n\n            function self.setPosition(px,py,pz)\n                if type(px) == 'table' then\n                    outArr[1],outArr[2],outArr[3]=px[1],px[2],px[3]\n                else\n                    outArr[1],outArr[2],outArr[3]=px,py,pz\n                end\n                return self\n            end\n            function self.setDrawFunction(draw)\n                outArr[4] = draw\n                return self\n            end\n            function self.setData(dat)\n                outArr[5] = dat\n                return self\n            end\n            function self.show()\n                if not shown then\n                    shown = true\n                end\n            end\n            function self.hide()\n                if shown then\n                    points.Remove(outArr)\n                    shown = false\n                end\n            end\n            function self.build()\n                points.Add(outArr)\n                shown = true\n                return self\n            end\n            return self\n        end\n        return builder\n    end\nend\n\nfunction ProcessPureModule(zBC, singleGroup, multiGroup, zBuffer, zSorter,\n        mXX, mXY, mXZ,\n        mYX, mYY, mYZ,\n        mZX, mZY, mZZ,\n        mXW, mYW, mZW)\n    for cG = 1, #singleGroup do\n        local group = singleGroup[cG]\n        local singleGroups,singleSize = group.GetData()\n        for sGC = 1, singleSize do\n            local singleGroup = singleGroups[sGC]\n            local x,y,z = singleGroup[1], singleGroup[2], singleGroup[3]\n            local pz = mYX*x + mYY*y + mYZ*z + mYW\n            if pz < 0 then goto disabled end\n            zBC = zBC + 1\n            zSorter[zBC] = -pz\n            zBuffer[-pz] = singleGroup[4]((mXX*x + mXY*y + mXZ*z + mXW)/pz,(mZX*x + mZY*y + mZZ*z + mZW)/pz,pz,singleGroup[5])\n            ::disabled::\n        end\n    end\n    for cG = 1, #multiGroup do\n        local group = multiGroup[cG]\n        local multiGroups,groupSize = group.GetData()\n        for mGC = 1, groupSize do\n            local multiGroup = multiGroups[mGC]\n\n            local tPointsX,tPointsY,tPointsZ = {},{},{}\n            local pointsX,pointsY,pointsZ = multiGroup[1],multiGroup[2],multiGroup[3]\n            local size = #pointsX\n            local mGAvg = 0\n            for pC=1,size do\n                local x,y,z = pointsX[pC],pointsY[pC],pointsZ[pC]\n                local pz = mYX*x + mYY*y + mYZ*z + mYW\n                if pz < 0 then\n                    goto disabled\n                end\n\n                tPointsX[pC],tPointsY[pC] = (mXX*x + mXY*y + mXZ*z + mXW)/pz,(mZX*x + mZY*y + mZZ*z + mZW)/pz\n                mGAvg = mGAvg + pz\n            end\n            local depth = -mGAvg/size\n            zBC = zBC + 1\n            zSorter[zBC] = depth\n            zBuffer[depth] = multiGroup[4](tPointsX,tPointsY,depth,multiGroup[5])\n            ::disabled::\n        end\n    end\n    return zBC\nend\nend)\npackage.preload['YFS-Tools:../util/wpointer/4-ProjectionManager.lua']=(function()\nfunction Projector()\n    -- Localize frequently accessed data\n    local construct, system, math = DUConstruct, DUSystem, math\n\n    -- Internal Parameters\n    local frameBuffer,frameRender,isSmooth,lowLatency = {'',''},true,true,true\n\n    -- Localize frequently accessed functions\n    --- System-based function calls\n    local getWidth, getHeight, getTime, setScreen =\n    system.getScreenWidth,\n    system.getScreenHeight,\n    system.getArkTime,\n    system.setScreen\n\n    --- Camera-based function calls\n\n    local getCamWorldRight, getCamWorldFwd, getCamWorldUp, getCamWorldPos =\n    system.getCameraWorldRight,\n    system.getCameraWorldForward,\n    system.getCameraWorldUp,\n    system.getCameraWorldPos\n\n    local getConWorldRight, getConWorldFwd, getConWorldUp, getConWorldPos =\n    construct.getWorldRight,\n    construct.getWorldForward,\n    construct.getWorldUp,\n    construct.getWorldPosition\n\n    --- Manager-based function calls\n    ---- Quaternion operations\n    local rotMatrixToQuat,quatMulti = RotMatrixToQuat,QuaternionMultiply\n\n    -- Localize Math functions\n    local tan, atan, rad = math.tan, math.atan, math.rad\n\n    --- FOV Paramters\n    local horizontalFov = system.getCameraHorizontalFov\n    local fnearDivAspect = 0\n\n    local objectGroups = LinkedList('Group', '')\n\n    local self = {}\n\n    function self.getSize(size, zDepth, max, min)\n        local pSize = atan(size, zDepth) * fnearDivAspect\n        if max then\n            if pSize >= max then\n                return max\n            else\n                if min then\n                    if pSize < min then\n                        return min\n                    end\n                end\n                return pSize\n            end\n        end\n        return pSize\n    end\n\n    function self.refresh() frameRender = not frameRender end\n\n    function self.setLowLatency(low) lowLatency = low end\n\n    function self.setSmooth(iss) isSmooth = iss end\n\n    function self.addObjectGroup(objectGroup) objectGroups.Add(objectGroup) end\n\n    function self.removeObjectGroup(objectGroup) objectGroups.Remove(objectGroup) end\n\n    function self.getSVG()\n        local getTime, atan, sort, unpack, format, concat, quatMulti = getTime, atan, table.sort, table.unpack, string.format, table.concat, quatMulti\n        local startTime = getTime()\n        frameRender = not frameRender\n        local isClicked = false\n        if clicked then\n            clicked = false\n            isClicked = true\n        end\n        local isHolding = holding\n\n        local buffer = {}\n\n        local width,height = getWidth(), getHeight()\n        local aspect = width/height\n        local tanFov = tan(rad(horizontalFov() * 0.5))\n\n        --- Matrix Subprocessing\n        local nearDivAspect = (width*0.5) / tanFov\n        fnearDivAspect = nearDivAspect\n\n        -- Localize projection matrix values\n        local px1 = 1 / tanFov\n        local pz3 = px1 * aspect\n\n        local pxw,pzw = px1 * width * 0.5, -pz3 * height * 0.5\n\n        -- Localize screen info\n        local objectGroupsArray,objectGroupSize = objectGroups.GetData()\n        local svgBuffer,svgZBuffer,svgBufferCounter = {},{},0\n\n        local processPure = ProcessPureModule\n        local processUI = ProcessUIModule\n        local processRots = ProcessOrientations\n        local processEvents = ProcessActionEvents\n        if processPure == nil then\n            processPure = function(zBC) return zBC end\n        end\n        if processUI == nil then\n            processUI = function(zBC) return zBC end\n            processRots = function() end\n            processEvents = function() end\n        end\n        local predefinedRotations = {}\n        local camR,camF,camU,camP = getCamWorldRight(),getCamWorldFwd(),getCamWorldUp(),getCamWorldPos()\n\n        do\n            local cwr,cwf,cwu = getConWorldRight(),getConWorldFwd(),getConWorldUp()\n            ConstructReferential.rotateXYZ(cwr,cwf,cwu)\n            ConstructOriReferential.rotateXYZ(cwr,cwf,cwu)\n            ConstructReferential.setPosition(getConWorldPos())\n            ConstructReferential.checkUpdate()\n            ConstructOriReferential.checkUpdate()\n        end\n        local vx,vy,vz,vw = rotMatrixToQuat(camR,camF,camU)\n        local vxx,vxy,vxz,vyx,vyy,vyz,vzx,vzy,vzz = camR[1]*pxw,camR[2]*pxw,camR[3]*pxw,camF[1],camF[2],camF[3],camU[1]*pzw,camU[2]*pzw,camU[3]*pzw\n        local ex,ey,ez = camP[1],camP[2],camP[3]\n        local deltaPreProcessing = getTime() - startTime\n        local deltaDrawProcessing, deltaEvent, deltaZSort, deltaZBufferCopy, deltaPostProcessing = 0,0,0,0,0\n        for i = 1, objectGroupSize do\n            local objectGroup = objectGroupsArray[i]\n            if objectGroup.enabled == false then\n                goto not_enabled\n            end\n            local objects = objectGroup.objects\n\n            local avgZ, avgZC = 0, 0\n            local zBuffer, zSorter, zBC = {},{}, 0\n\n            local notIntersected = true\n            for m = 1, #objects do\n                local obj = objects[m]\n                if not obj[1] then\n                    goto is_nil\n                end\n\n                obj.checkUpdate()\n                local objOri, objPos, oriType, posType  = obj[5], obj[6], obj[7], obj[8]\n                local objX,objY,objZ = objPos[1]-ex,objPos[2]-ey,objPos[3]-ez\n                local mx,my,mz,mw = objOri[1], objOri[2], objOri[3], objOri[4]\n\n                local a,b,c,d = quatMulti(mx,my,mz,mw,vx,vy,vz,vw)\n                local aa, ab, ac, ad, bb, bc, bd, cc, cd = 2*a*a, 2*a*b, 2*a*c, 2*a*d, 2*b*b, 2*b*c, 2*b*d, 2*c*c, 2*c*d\n\n                local mXX, mXY, mXZ,\n                      mYX, mYY, mYZ,\n                      mZX, mZY, mZZ =\n                (1 - bb - cc)*pxw, (ab + cd)*pxw,  (ac - bd)*pxw,\n                (ab - cd),         (1 - aa - cc),  (bc + ad),\n                (ac + bd)*pzw,     (bc - ad)*pzw,  (1 - aa - bb)*pzw\n\n                local mWX,mWY,mWZ = ((vxx*objX+vxy*objY+vxz*objZ)),(vyx*objX+vyy*objY+vyz*objZ),((vzx*objX+vzy*objY+vzz*objZ))\n\n                local processRotations = processRots(predefinedRotations,vx,vy,vz,vw,pxw,pzw)\n                predefinedRotations[mx .. ',' .. my .. ',' .. mz .. ',' .. mw] = {mXX,mXZ,mYX,mYZ,mZX,mZZ}\n\n                avgZ = avgZ + mWY\n                local uiGroups = obj[4]\n\n                -- Process Actionables\n                local eventStartTime = getTime()\n                obj.previousUI = processEvents(uiGroups, obj.previousUI, isClicked, isHolding, vyx, vyy, vyz, processRotations, ex,ey,ez, sort)\n                local drawProcessingStartTime = getTime()\n                deltaEvent = deltaEvent + drawProcessingStartTime - eventStartTime\n\n                -- Progress Pure\n                zBC = processPure(zBC, obj[2], obj[3], zBuffer, zSorter,\n                    mXX, mXY, mXZ,\n                    mYX, mYY, mYZ,\n                    mZX, mZY, mZZ,\n                    mWX, mWY, mWZ\n                )\n                -- Process UI\n                zBC = processUI(zBC, uiGroups, zBuffer, zSorter,\n                            vxx, vxy, vxz,\n                            vyx, vyy, vyz,\n                            vzx, vzy, vzz,\n                            ex,ey,ez,\n                        processRotations,nearDivAspect)\n                deltaDrawProcessing = deltaDrawProcessing + getTime() - drawProcessingStartTime\n                ::is_nil::\n            end\n            local zSortingStartTime = getTime()\n            if objectGroup.isZSorting then\n                sort(zSorter)\n            end\n            local zBufferCopyStartTime = getTime()\n            deltaZSort = deltaZSort + zBufferCopyStartTime - zSortingStartTime\n            local drawStringData = {}\n            for zC = 1, zBC do\n                drawStringData[zC] = zBuffer[zSorter[zC]]\n            end\n            local postProcessingStartTime = getTime()\n            deltaZBufferCopy = deltaZBufferCopy + postProcessingStartTime - zBufferCopyStartTime\n            if zBC > 0 then\n                local dpth = avgZ / avgZC\n                local actualSVGCode = concat(drawStringData)\n                local beginning, ending = '', ''\n                if isSmooth then\n                    ending = '</div>'\n                    if frameRender then\n                        beginning = '<div class=\"second\" style=\"visibility: hidden\">'\n                    else\n                        beginning = '<style>.first{animation: f1 0.008s infinite linear;} .second{animation: f2 0.008s infinite linear;} @keyframes f1 {from {visibility: hidden;} to {visibility: hidden;}} @keyframes f2 {from {visibility: visible;} to { visibility: visible;}}</style><div class=\"first\">'\n                    end\n                end\n                local styleHeader = ('<style>svg{background:none;width:%gpx;height:%gpx;position:absolute;top:0px;left:0px;}'):format(width,height)\n                local svgHeader = ('<svg viewbox=\"-%g -%g %g %g\"'):format(width*0.5,height*0.5,width,height)\n\n                svgBufferCounter = svgBufferCounter + 1\n                svgZBuffer[svgBufferCounter] = dpth\n\n                if objectGroup.glow then\n                    local size\n                    if objectGroup.scale then\n                        size = atan(objectGroup.gRad, dpth) * nearDivAspect\n                    else\n                        size = objectGroup.gRad\n                    end\n                    svgBuffer[dpth] = concat({\n                                beginning,\n                                '<div class=\"', objectGroup.class ,'\">',\n                                styleHeader,\n                                objectGroup.style,\n                                '.blur {filter: blur(',size,'px) brightness(60%) saturate(3);',\n                                objectGroup.gStyle, '}</style>',\n                                svgHeader,\n                                ' class=\"blur\">',\n                                actualSVGCode,'</svg>',\n                                svgHeader, '>',\n                                actualSVGCode,\n                                '</svg></div>',\n                                ending\n                            })\n                else\n                    svgBuffer[dpth] = concat({\n                                beginning,\n                                '<div class=\"', objectGroup.class ,'\">',\n                                styleHeader,\n                                objectGroup.style, '</style>', --orig: '}</style>',\n                                svgHeader, '>',\n                                actualSVGCode,\n                                '</svg></div>',\n                                ending\n                            })\n                    P(svgBuffer[dpth])\n                end\n            end\n            deltaPostProcessing = deltaPostProcessing + getTime() - postProcessingStartTime\n            ::not_enabled::\n        end\n\n        sort(svgZBuffer)\n\n        for i = 1, svgBufferCounter do\n            buffer[i] = svgBuffer[svgZBuffer[i]]\n        end\n\n        if frameRender then\n            frameBuffer[2] = concat(buffer)\n            return concat(frameBuffer), deltaPreProcessing, deltaDrawProcessing, deltaEvent, deltaZSort, deltaZBufferCopy, deltaPostProcessing\n        else\n            if isSmooth then\n                frameBuffer[1] = concat(buffer)\n                if lowLatency then\n                    setScreen('<div>Refresh Required (ALT+2)!</div>') -- magical things happen when doing this for some reason, some really, really weird reason.\n                end\n            else\n                frameBuffer[1] = ''\n            end\n            return nil\n        end\n    end\n    return self\nend\nend)\npackage.preload['YFS-Tools:../util/wpointer/wpointer_custom.lua']=(function()\nfunction WPointer(x,y,z, radius, name, type, localeType, subId)\n    local sqrt,floor,max,round=math.sqrt,math.floor,math.max,Round\n    local getCWorldPos,getCMass = construct.getWorldPosition,construct.getMass\n\n    local keyframe = 0\n    local self = {\n        radius = radius,\n        x = x,\n        y = y,\n        z = z,\n        name = name,\n        type = type,\n        localeType = localeType,\n        subId = subId,\n        keyframe = keyframe\n    }\n\n    function self.getWaypointInfo()\n        ---@diagnostic disable-next-line: missing-parameter\n        local cid = CNID --in globals.lua!\n        local cPos = getCWorldPos(cid)\n        ---@diagnostic disable-next-line: need-check-nil\n        local px,py,pz = self.x-cPos[1], self.y-cPos[2], self.z-cPos[3]\n        local distance = sqrt(px*px + py*py + pz*pz)\n        local warpCost = 0\n        -- min 2 SU, max 500 SU (1 SU = 200000 m)\n        if distance > 400000 and distance <= 100000000 then\n            local tons = getCMass(cid) / 1000\n            warpCost = max(floor(tons*floor(((distance/1000)/200))*0.00024), 1)\n        end\n        local disR = round(distance, 2)\n        return {self.name, round((distance/1000)/200, 2), warpCost, round((distance/1000), 2), disR}\n    end\n\n    return self\nend\nend)\npackage.preload['YFS-Tools:waypointer_lib.lua']=(function()\nrequire('YFS-Tools:../util/wpointer/1-FunctionManager.lua')\nrequire('YFS-Tools:../util/wpointer/2-Object.lua')\nrequire('YFS-Tools:../util/wpointer/3-PureModule.lua')\nrequire('YFS-Tools:../util/wpointer/4-ProjectionManager.lua')\nrequire('YFS-Tools:../util/wpointer/wpointer_custom.lua')\nend)\npackage.preload['YFS-Tools:waypointer_start.lua']=(function()\n-- Original waypointer script (c) EasternGamer\n-- tobitege: customisation to read YFS route waypoints\n-- as well as ArchHud locations and add these for display\n\nlocal enableWaypointer=true--export: Enable waypoint AR display. Default: checked.\nlocal lowLatencyMode=true--export: Enables low latency for screen render, which can sometimes bug out if a frame gets skipped. A restart is required then.\nlocal highPerformanceMode=false--export: Disables glow effect which can in some cases improve FPS significantly\nlocal smooth=false--export: Caution: display can fault! Enables full FPS rendering, which increases the perceived performance for an actual performance impact\nlocal glowRadius=3--export: Sets the pixel size of the glow effect. Only in non-higPerformanceMode; 0=disabled.\nlocal displayWarpCells=false--export: Enable display of warp cells amount\nlocal displaySolarWP=false--export: Enable display of solar objects (planets, moons)\nlocal displayCustomWP=true--export: Enable display of custom waypoints (routes)\nlocal archHudWaypointSize=1--export: The size in meters of a custom waypoint (0.1 - 10)\nlocal archHudWPRender=3--export: The number of kilometers above which distance custom waypoints are not rendered\nlocal maxWaypointSize=200--export: The max size of a waypoint in pixels\nlocal minWaypointSize=20--export: The min size of a waypoint in pixels (max 300)\nlocal infoHighlight=300--export: The number of pixels within info is displayed\nlocal fontsize=30--export: Font size (default: 20)\nlocal colorWarp=\"#ADD8E6\"--export: RGB color of warpable waypoints. Default: \"#ADD8E6\"\nlocal nonWarp=\"#FFA500\"--export: RGB color of non-warpable waypoints. Default: \"#FFA500\"\nlocal colorWaypoint=\"#32CD32\"--export: RGB color of custom waypoints. Default: \"#32CD32\"\n\nlocal format, sqrt, len, max, print, uclamp = string.format, math.sqrt, string.len, math.max, system.print, utils.clamp\nlocal concat,unpack = table.concat,table.unpack\n\nlocal position = {0,0,0}\nlocal offsetPos = {0,0,0}\nlocal orientation = {0,0,0}\n---@diagnostic disable-next-line: missing-parameter\nlocal width = system.getScreenWidth() / 2\n---@diagnostic disable-next-line: missing-parameter\nlocal height = system.getScreenHeight() / 2\nlocal objectBuilder = ObjectBuilderLinear()\nfontsize = uclamp(fontsize, 10, 40)\nglowRadius = uclamp(glowRadius, 0, 10)\nminWaypointSize = uclamp(minWaypointSize, 5, 200)\nmaxWaypointSize = uclamp(maxWaypointSize, minWaypointSize+1, 400)\narchHudWaypointSize = uclamp((archHudWaypointSize or 0.5), 0.1, 10)\n\nif not enableWaypointer then\n    WAYPOINTER_ENABLED = false\nend\nWaypointOpt = false\n\nlocal localeIndex = {\n    ['en-US'] = 1,\n    ['fr-FR'] = 2,\n    ['de-De'] = 3\n}\n\n---@diagnostic disable-next-line: lowercase-global\nprojector = Projector()\nprojector.setSmooth(smooth)\n\nlocal waypointObjectGroup = ObjectGroup()\nprojector.addObjectGroup(waypointObjectGroup)\n\nlocal css = [[\nsvg {\n    stroke-width: 3;\n    vertical-align:middle;\n    text-anchor:start;\n    fill: white;\n    font-family: Refrigerator;\n    font-size: ]] .. fontsize .. [[;\n}]]\nwaypointObjectGroup.setStyle(css)\n\nif not highPerformanceMode and glowRadius > 0 then\n    waypointObjectGroup.setGlow(true, glowRadius, true)\nend\n\nprojector.setLowLatency(lowLatencyMode == true)\nlocal function drawText(content,x, y, text, opacity,uD,c,c2,stroke)\n    uD[c],uD[c+1],uD[c+2],uD[c+3],uD[c+4],uD[c+5] = x,y,opacity,opacity,stroke,text\n    content[c2] = '<text x=\"%g\" y=\"%g\" fill-opacity=\"%g\" stroke-opacity=\"%g\" stroke=\"%s\">%s</text>'\n    return c+6,c2+1\nend\n\nlocal function drawHorizontalLine(content,x, y, length, thickness,dU,c,c2,stroke)\n    dU[c],dU[c+1],dU[c+2],dU[c+3],dU[c+4]=thickness,stroke,x,y,length\n    content[c2] = '<path fill=\"none\" stroke-width=\"%g\" stroke=\"%s\" d=\"M%g %gh%g\"/>'\n    return c+5,c2+1\nend\n\nlocal maxD = sqrt(width*width + height*height)\nlocal function drawInfo(content,tx,ty,data,dU,c,c1,stroke,distanceToMouse,wpInfo)\n    local font = fontsize\n    local name,distance,warpCost,disKM,disM = unpack(wpInfo)\n    local keyframe = data.keyframe\n    c,c1 = drawHorizontalLine(content, tx, ty + 3, len(name)*(font*0.6), 2,dU,c,c1,stroke)\n    c,c1 = drawText(content, tx, ty, name, 1,dU,c,c1,stroke)\n    if distanceToMouse <= infoHighlight then\n        if keyframe < 6 then\n            data.keyframe = keyframe + 1\n        end\n    else\n        if keyframe ~= 0 then\n            data.keyframe = keyframe - 1\n        end\n    end\n    local opacity = keyframe/6\n    if WaypointOpt and distanceToMouse < 15 then\n        system.setWaypoint('::pos{0,0,' .. data.x ..',' .. data.y .. ',' .. data.z ..'}')\n        WaypointOpt = false\n    end\n    if keyframe > 0 then\n        disM = disM or 0\n        disKM = disKM or 0\n        distance = distance or 0\n        local disText = ''\n        if disM <= 2000 then\n            disText = disM .. ' m'\n        elseif disKM <= 200 then\n            disText = disKM .. ' km'\n        else\n            disText = distance .. ' SU'\n        end\n        local f5 = font + 5\n        local kf = keyframe * 10\n        local tx2 = tx + 80\n        c,c1 = drawText(content, tx2 - kf, ty+f5, disText, opacity,dU,c,c1,stroke)\n        if displayWarpCells and distance > 2 then\n            c,c1 = drawText(content, tx2 - kf, ty+f5*2, data.localeType, opacity,dU,c,c1,stroke)\n            c,c1 = drawText(content, tx2 - kf, ty+f5*3, warpCost .. ' Warp Cells', opacity,dU,c,c1,stroke)\n        elseif data.type == 'WP' then\n            c,c1 = drawText(content, tx2 - kf, ty+f5*2, 'Alt: '..data.subId, opacity,dU,c,c1,stroke)\n        else\n            c,c1 = drawText(content, tx2 - kf, ty+f5*2, data.localeType, opacity,dU,c,c1,stroke)\n        end\n    end\n    return c\nend\n\nlocal function draw(tx,ty,tz,data)\n    local dU, c = {},1\n    local content,c1 = {},1\n    local distanceToMouse = sqrt(tx*tx + ty*ty)\n    local r = data.radius\n    local off = (((tz/1000)/200))/100\n    local size = Round(max(projector.getSize(r, tz, 100000000, minWaypointSize) - off, 2),1)\n    local wpInfo = data.getWaypointInfo()\n    local distance,disM = wpInfo[2],wpInfo[5]\n    size = uclamp(size, minWaypointSize, maxWaypointSize)\n    if data.type == 'Planet' or data.type == 'WP' then\n        if (disM < 2) or (distanceToMouse > maxD) or --or (tz < 30) or (size >= maxWaypointSize)\n           (data.type == 'WP' and tz>archHudWPRender*1000) then -- Don't display\n          return ''\n        end\n    elseif data.type == 'Moon' then\n        if distance > 20 then return '' end\n    else\n        if distance > 10 then return '' end\n    end\n\n    local stroke = colorWarp\n    if data.type == 'WP' then\n        stroke = colorWaypoint\n    elseif distance > 500 then\n        stroke = nonWarp\n    end\n    content[c1] = '<circle cx=\"%g\" cy=\"%g\" r=\"%g\" fill=\"%s\" stroke=\"%s\"/>'\n    dU[c],dU[c+1] = tx,ty\n    c=c+2\n    if r==archHudWaypointSize*1.25 then\n        size = size /2\n        dU[c+1] = colorWarp\n    else\n        dU[c+1] = 'none'\n    end\n    dU[c] = size\n    dU[c+2] = stroke\n    c=c+3\n    c=drawInfo(content, tx + size + 5, ty - size + 5, data,dU,c,c1+1,stroke,distanceToMouse,wpInfo)\n    return concat(content):format(unpack(dU))\nend\n\nlocal solarWaypoints = objectBuilder\n\t\t.setPositionType(positionTypes.globalP)\n\t\t.setOrientationType(orientationTypes.globalO)\n\t\t.build()\n\nwaypointObjectGroup.addObject(solarWaypoints)\nlocal builder = solarWaypoints.getSinglePointBuilder()\nif displaySolarWP then\n    ---@diagnostic disable-next-line: missing-parameter\n    local localizationIndex = localeIndex[system.getLocale()]\n    for k,stellar in pairs(WaypointInfo[0]) do\n        local wCenter = stellar.center\n        local wName = stellar.name[localizationIndex]\n        local wRadius = stellar.radius\n        local wType = stellar.type[1]\n        if wType ~= \"Asteroid\" then\n            local wlType = stellar.type[localizationIndex]\n            local waypointObject = WPointer(wCenter[1],wCenter[2],wCenter[3],\n                    wRadius * 1.25, wName, wType, wlType, nil)\n            local customSVG = builder.addSinglePointSVG()\n            customSVG.setPosition(wCenter[1], wCenter[2], wCenter[3])\n                .setData(waypointObject)\n                .setDrawFunction(draw)\n                .build()\n            P(\"[WPointer] Added \"..wName)\n        end\n    end\nend\n\n-- tobitege: draw custom waypoints if enabled\nif displayCustomWP and WM then\n    for _,p in ipairs(WM:getSorted()) do\n        local subId = format(\"%.2f\", p.mapPos.altitude)\n        local s = PM.MapPos2String(p.mapPos)\n        local wPos = PM.MapPosToWorldVec3(s);\n        local waypointObject = WPointer(\n                wPos.x, wPos.y, wPos.z,\n                archHudWaypointSize * 1.25, p.name, 'WP', 'WP', subId)\n        local customSVG = builder.addSinglePointSVG()\n        customSVG.setPosition(wPos.x, wPos.y, wPos.z)\n            .setData(waypointObject)\n            .setDrawFunction(draw)\n            .build()\n            P(\"[WPointer] Added \"..p.name)\n    end\nend\nend)\npackage.preload['YFS-Tools:sys_onActionStartWp.lua']=(function()\nlocal actionStartFunc = {}\n\nfunction actionStartFunc.Run(action)\n    --P(\"ActionStart: \"..action)\n    if action == 'option1' then\n        WaypointOpt = true\n        return\n    end\n    if action == 'option2' then\n        projector.refresh()\n        return\n    end\nend\n\nreturn actionStartFunc\n\n\nend)\npackage.preload['YFS-Tools:unit_onTimer(update).lua']=(function()\nlocal timerFunc = {}\n\nfunction timerFunc.Run(timerId)\n    if timerId == 'update' then\n        if not INGAME then P(\"onTimer(update)\") end\n        if not DEBUG then\n            local svg = projector.getSVG()\n            ---@diagnostic disable-next-line: param-type-mismatch\n            if svg then system.setScreen(svg) end\n            return\n        end\n\n-- EasternGamer's Screen Update with debug info\nlocal timeStart = system.getArkTime()\nlocal svg, deltaPreProcessing, deltaDrawProcessing, deltaEvent, deltaZSort, deltaZBufferCopy, deltaPostProcessing = projector.getSVG()\nlocal delta = system.getArkTime() - timeStart\nlocal floor = math.floor\nlocal function WriteDelta(name, dt, suffix)\n    return '<div>'.. name .. ':'.. floor((dt*100000))/100 .. suffix .. '</div>'\nend\ncollectgarbage('collect')\nif svg then\n    if not DEBUG then\n        system.setScreen(svg)\n    else\n        system.setScreen(table.concat({\n            svg,\n            '<div>CPU Instructions: ', system.getInstructionCount() .. '/' .. system.getInstructionLimit() .. '</div>',\n            WriteDelta('Memory',collectgarbage('count')/1000, 'kb'),\n            WriteDelta('Total',delta, 'ms'),\n            WriteDelta('Pre-Processing', deltaPreProcessing, 'ms'),\n            WriteDelta('Draw Processing', deltaDrawProcessing, 'ms'),\n            WriteDelta('Event', deltaEvent, 'ms'),\n            WriteDelta('Z-Sorting', deltaZSort, 'ms'),\n            WriteDelta('Z-Buffer Copy', deltaZBufferCopy, 'ms'),\n            WriteDelta('Post Processing', deltaPostProcessing, 'ms')\n        }))\n    end\nend\n--==================================--\n    end\nend\n\nreturn timerFunc\nend)"},{"key":4,"filter":{"slotKey":-5,"signature":"onStart()","args":[]},"code":"library.addEventHandlers(library)\nlibrary.addEventHandlers(system)\nlibrary.addEventHandlers(player)\nlibrary.addEventHandlers(construct)\nlibrary.addEventHandlers(unit)"},{"key":5,"filter":{"slotKey":-4,"signature":"onActionStart(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionStart',action)"},{"key":6,"filter":{"slotKey":-4,"signature":"onActionLoop(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionLoop',action)"},{"key":7,"filter":{"slotKey":-4,"signature":"onActionStop(action)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onActionStop',action)"},{"key":8,"filter":{"slotKey":-4,"signature":"onUpdate()","args":[]},"code":"system:triggerEvent('onUpdate')"},{"key":9,"filter":{"slotKey":-4,"signature":"onFlush()","args":[]},"code":"system:triggerEvent('onFlush')"},{"key":10,"filter":{"slotKey":-4,"signature":"onInputText(text)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onInputText',text)"},{"key":11,"filter":{"slotKey":-4,"signature":"onCameraChanged(mode)","args":[{"variable":"*"}]},"code":"system:triggerEvent('onCameraChanged',mode)"},{"key":12,"filter":{"slotKey":-3,"signature":"onParentChanged(oldId,newId)","args":[{"variable":"*"},{"variable":"*"}]},"code":"player:triggerEvent('onParentChanged',oldId,newId)"},{"key":13,"filter":{"slotKey":-2,"signature":"onDocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onDocked',id)"},{"key":14,"filter":{"slotKey":-2,"signature":"onUndocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onUndocked',id)"},{"key":15,"filter":{"slotKey":-2,"signature":"onPlayerBoarded(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onPlayerBoarded',id)"},{"key":16,"filter":{"slotKey":-2,"signature":"onVRStationEntered(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onVRStationEntered',id)"},{"key":17,"filter":{"slotKey":-2,"signature":"onConstructDocked(id)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onConstructDocked',id)"},{"key":18,"filter":{"slotKey":-2,"signature":"onPvPTimer(active)","args":[{"variable":"*"}]},"code":"construct:triggerEvent('onPvPTimer',active)"},{"key":19,"filter":{"slotKey":-1,"signature":"onStop()","args":[]},"code":"unit:triggerEvent('onStop')"},{"key":20,"filter":{"slotKey":-1,"signature":"onTimer(timerId)","args":[{"variable":"*"}]},"code":"unit:triggerEvent('onTimer',timerId)"},{"key":21,"filter":{"slotKey":-1,"signature":"onStart()","args":[]},"code":"\n\n-- Important for local debugging:\npackage.path = \"lua/?.lua;util/wpointer/?.lua;\"..package.path\nrequire('YFS-Tools:globals.lua')\n\n-- DU-LuaC checks for true are last, so that local debugging sees true!\nWAYPOINTER_ENABLED = true\nDEBUG = false\nrequire('YFS-Tools:libmain.lua')\n\nif INGAME then\n    local Traceback = traceback\nelse\n    function Traceback(o)\n        if o then P(tostring(o)) end\n    end\n    require 'mockaround'\nend\n\nlocal status, err, _ = xpcall(function() require('YFS-Tools:startup.lua') end, Traceback)\nif not status then\n    P(\"[E] Error in startup!\")\n    if err then P(err) end\n    unit.exit()\n    return\nend\n\nlocal inp = require('YFS-Tools:sys_onInputText.lua')\nif inp ~= nil then\n    system:onEvent('onInputText', function (self, text) inp.Run(text) end)\nend\n\n-- *****************************************\n-- Only for waypointer mod\n---@diagnostic disable-next-line: lowercase-global\nrot = 0 -- for waypointer\nlocal onT\nif WAYPOINTER_ENABLED then\n    require('YFS-Tools:waypointer_lib.lua')\n    require('YFS-Tools:waypointer_start.lua') -- lua param could turn it off!\n    if WAYPOINTER_ENABLED then -- so check again if it is enabled\n        local asWP = require('YFS-Tools:sys_onActionStartWp.lua')\n        if asWP ~= nil then\n            system:onEvent('onActionStart', function (self, option) asWP.Run(option) end)\n        end\n\n        onT = require('YFS-Tools:unit_onTimer(update).lua')\n        if onT ~= nil then\n            unit:onEvent('onTimer', function (unit, id) onT.Run(\"update\") end)\n        end\n\n        P('[I] Waypointer module enabled.')\n\n        unit.setTimer(\"update\", 1/240) -- The timer to update the screen\n        system.showScreen(1)\n    end\nend\nif not WAYPOINTER_ENABLED then\n    P('[I] Waypointer module disabled.')\nend\n\n-- *****************************************\n\nif INGAME then\n    if DEBUGx then\n        status, err, _ = xpcall(function() PM.ConversionTest() end, Traceback)\n        if not status then\n            if err then P(\"[E] Error in test call:\\n\" .. err) end\n            unit.exit()\n            return\n        end\n    else\n        unit.hideWidget()\n    end\n    P(\"Type /help for available commands.\")\n\nend"}],"events":[],"methods":[]}