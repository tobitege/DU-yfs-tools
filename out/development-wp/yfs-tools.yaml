slots:
  "-5":
    name: library
    class: null
    select: null
    type:
      events: []
      methods: []
  "-4":
    name: system
    class: null
    select: null
    type:
      events: []
      methods: []
  "-3":
    name: player
    class: null
    select: null
    type:
      events: []
      methods: []
  "-2":
    name: construct
    class: null
    select: null
    type:
      events: []
      methods: []
  "-1":
    name: unit
    class: null
    select: null
    type:
      events: []
      methods: []
handlers:
  - key: 1
    filter:
      slotKey: -5
      signature: onStart()
      args: []
    code: >-
      ;(function()

      local a={}local b=0;function library.addEventHandlers(c)if not c or c.onEvent and c.triggerEvent then return false end;b=b+1;a[b]=c;local d,e,f='table','function','thread'if d~=type(c)then error('You can only add event handlers to table objects!')end;local g={}local function h(c)local i=type(c)return e==i or d==i and h(getmetatable(c).__call)or f==i end;c.onEvent=function(self,j,k,l)if not h(k)then error('Event handler must be a function, a callable object or a thread!')end;l=l or self;if d~=type(l)then error('The value of self must be a table!')end;if not g[j]then g[j]={_=0}end;local m=f==type(k)and function(...)coroutine.resume(k,...)end or k;local k=g[j]local n=k._+1;k[n]={m,l}k._=n;return n end;c.clearEvent=function(self,j,o)if g[j]and g[j][o]then g[j][o]=nil end end;c.clearAllEvents=function(self)g={}end;c.triggerEvent=function(self,j,...)local p=g[j]if p then for q=1,p._ do local k=p[q]if k then k[1](k[2],...)end end end end;return true end;function library.clearAllEventHandlers()for q=1,b do local c=a[q]if c and c.clearAllEvents then c:clearAllEvents()end end end

      end)()
  - key: 2
    filter:
      slotKey: -5
      signature: onStart()
      args: []
    code: >-
      ;(function()

      local a=DULibrary or{}function a.getLinks(b,c)local d={}if not b then b={}end;for e,f in pairs(unit.getOutPlugs())do local g=unit[f.name]if'table'==type(g)and'function'==type(g.getClass)then local h=true;for i,j in pairs(b)do if not('function'==type(g[i])and j==g[i]():sub(1,#j))then h=false;break end end;if h then if c then table.insert(d,g)else d[f.name]=g end end end end;return d end;function a.getLinksByClass(k,c)return a.getLinks({getClass=k},c)end;function a.getLinkByClass(k)return a.getLinksByClass(k,true)[1]end;function a.getCoreUnit()return a.getLinkByClass('CoreUnit')end;function a.getLinkByName(l)local m=a.getCoreUnit()if not m then error('getLinkByName requires a linked CoreUnit to work')end;local d=a.getLinks()for n,o in pairs(d)do if l==m.getElementNameById(o.getLocalId())then return o end end end

      end)()
  - key: 3
    filter:
      slotKey: -5
      signature: onStart()
      args: []
    code: >-
      package.preload['YFS-Tools:globals.lua']=(function()

      Config = { core = nil, databanks = {}, screens = {} }

      DetectedArch = 0

      DetectedYFS = false

      YFSDB = nil

      YFS_NAMED_POINTS = "NamedPoints"

      YFS_ROUTES = "NamedRoutes"

      ARCH_SAVED_LOCATIONS = "SavedLocations"

      DEBUG = false

      ScriptStartTime = 0

      INGAME = system ~= nil


      if not INGAME then


      else
          ScriptStartTime = system.getArkTime()
          print = system.print
      end


      projector = nil

      clicked = false 

      WP_EG_ENABLED = false WP_WOLF_ENABLED = false 

      CNID = construct.getId()

      end)

      package.preload['YFS-Tools:../util/SU.lua']=(function()

      local SU = {}


      local strmatch, strlen, tonum = string.match, string.len, tonumber


      function SU.Trim(s)
          if strlen(s) == 0 then return "" end
          return SU.Ltrim(SU.Rtrim(s))
      end


      function SU.Ltrim(s)
          local res, _ = string.gsub(s, "^%s+", "")
          return res
      end


      function SU.Rtrim(s)
          local res, _ = string.gsub(s, "%s+$", "")
          return res
      end


      function SU.Pad(s, padChar, length)
          if not s or not length or not padChar or tonum(length) < 1 then return s end
          return string.rep(padChar, length - s:len()) .. s
      end


      function SU.StartsWith(s, prefix)
          if not s or not prefix then return false end
          return string.sub(s, 1, #prefix) == prefix
      end


      function SU.EndsWith(s, suffix)
          if not s or not suffix then return false end
          return string.sub(s, -#suffix) == suffix
      end


      function SU.RtrimChar(s,char)
          if not s or not char then return s end
          while #s > 0 and SU.EndsWith(s, char) do
              s = string.sub(s,1,#s - #char)
          end
          return s
      end


      function SU.SplitQuoted(s)
          local function isQuote(c) return c == '"' or c == "'" end
          local function isSpace(c) return c == " " end

          local function add(target, v)
              v = SU.Trim(v)
              if v:len() > 0 then
                  table.insert(target, #target + 1, v)
              end
          end

          local inQuote = false
          local parts = {}     if type(s) ~= "string" or s == "" then
              return parts
          end

          local current = ""
          for c in string.gmatch(s, ".") do
              if isSpace(c) and not inQuote then
                              add(parts, current)
                  current = ""
              elseif isQuote(c) then
                  if inQuote then                 add(parts, current)
                      current = ""
                      inQuote = false
                  else                 add(parts, current)
                      current = ""
                      inQuote = true
                  end
              else
                  current = current .. c
              end
          end

              add(parts, current)

          return parts
      end


      function SU.If(cond, trueValue, falseValue)
          if cond then
              return tostring(trueValue or "")
          end
          return tostring(falseValue or "")
      end


      function SU.isPrintable(char)
          return strmatch(char, "[%g%s]") ~= nil
      end


      function SU.SplitAndCapitalize(inputString, delimiter)
          if not inputString or not SU.isPrintable(delimiter) then
              return inputString
          end
          local parts = {}
          for part in inputString:gmatch("[^" .. delimiter .. "]+") do
              table.insert(parts, part)
          end
          for i = 1, #parts do
              parts[i] = parts[i]:sub(1, 1):upper() .. parts[i]:sub(2)
          end
          return table.concat(parts)
      end


      return SU

      end)

      package.preload['YFS-Tools:../util/out.lua']=(function()

      local o = {}


      function o.PrettyDistance(dist)
          if dist < 10000 then
              return Round(dist,2).." m"
          end
          if dist < 200000 then
              return Round(dist/1000,2).." km"
          end
          return Round(dist/200000,2).." SU"
      end


      function o.PrettyMass(mass)
          if mass > 1000000 then
              return Round(mass / 1000000,2).." KT"
          end
          if mass > 1000 then
              return Round(mass / 1000,2).." tons"
          end
          return Round(mass,2).." kg"
      end


      function o.PrintLines(s)
          if not s then return end
          if type(s) ~= "string" then s = tostring(s) end
          for str in s:gmatch("([^\n]+)") do
               print(str)
          end
      end


      function o.Error(err)
          o.PrintLines(err)
          return false
      end


      function o.DeepPrint(e, maxItems)
          if IsTable(e) then
              local cnt = 0
              maxItems = maxItems or 0
              for k,v in pairs(e) do
                  if IsTable(v) then
                      P("-> "..k)
                      o.DeepPrint(v, maxItems)
                  elseif type(v) == "boolean" then
                      P(k..": "..BoolStr(v))
                  elseif type(v) == "function" then
                      P(k.."()")
                  elseif v == nil then
                      P(k.." ("..type(v)..")")
                  else
                      P(k..": "..tostring(v))
                  end
                  cnt = cnt + 1
                  if maxItems > 0 and cnt >= maxItems then
                     P("^:^:^:^: cutoff reached :^:^:^:^")
                      return
                  end
              end
          elseif type(e) == "boolean" then
             P(BoolStr(e))
          else
             P(e)
          end
      end


      function o.DumpVar(data)
              local tablecache = {}
          local buffer = ""
          local padder = "    "
          local function _dumpvar(d, depth)
              local t = type(d)
              local str = tostring(d)
              if (t == "table") then
                  if (tablecache[str]) then
                                                      buffer = buffer.."<"..str..">\n"
                  else
                      tablecache[str] = (tablecache[str] or 0) + 1
                      buffer = buffer.."("..str..") {\n"
                      for k, v in pairs(d) do
                          buffer = buffer..string.rep(padder, depth+1).."["..k.."] => "
                          _dumpvar(v, depth+1)
                      end
                      buffer = buffer..string.rep(padder, depth).."}\n"
                  end
              elseif (t == "boolean") then
                  buffer = buffer.."("..BoolStr(t)..")\n"
              elseif (t == "number") then
                  buffer = buffer.."("..t..") "..str.."\n"
              else
                  buffer = buffer.."("..t..") \""..str.."\"\n"
              end
          end
          _dumpvar(data, 0)
          return buffer
      end


      return o

      end)

      package.preload['YFS-Tools:../util/Dtbk.lua']=(function()

      Dtbk = {}

      Dtbk.__index = Dtbk;

      function Dtbk.new(bank)
          local self = setmetatable({}, Dtbk)
          self.DB = bank
          self.concat = table.concat
          return self
      end

      function Dtbk.hasKey(self,tag)
          return self.DB.hasKey(tag)
      end

      function Dtbk.getString(self,tag)
          return self.DB.getStringValue(tag)
      end

      function Dtbk.setString(self,tag,value)
          self.DB.setStringValue(tag,value)
      end

      function Dtbk.setData(self,tag,value)
          local str = json.encode(value)
          self.DB.setStringValue(tag,str)
      end

      function Dtbk.getData(self,tag)
          local tmp = self.DB.getStringValue(tag)
          if tmp == nil then return nil end
          local str = json.decode(tmp)
          return str
      end

      function Dtbk.remove(self,key)
          self.DB.clearValue(key)
      end

      function Dtbk.ResetAll(self)
          self.DB.clear()
      end

      end)

      package.preload['YFS-Tools:libutils.lua']=(function()

      local tonum, strmatch = tonumber, string.match


      function IsTable(obj)
          return obj ~= nil and type(obj) == "table"
      end


      function GetSortedAssocKeys(source)
          local L = {}
          if not IsTable(source) then E("[E] Invalid object for GetSortedKeys()!") return L end
          for k,_ in pairs(source) do
              table.insert(L, k)
          end
          table.sort(L)
          return L
      end


      function Round(num, decimals)
          local mult = 10^(decimals or 0)
          return ((num*mult) + (2^52 + 2^51) - (2^52 + 2^51))/mult
      end


      function TableLen(source)
          if not IsTable(source) then return 0 end
          local cnt = 0
          for _ in pairs(source) do
            cnt = cnt + 1
          end
          return cnt
      end


      function GetIndex(source, value)
          if not IsTable(source) then return -1 end
          for k, v in pairs(source) do
            if value == v then return k end
          end
          return -1
      end


      function GetParamValue(srcTable, paramName, reqType, reqMsg)
          local err = "[E] Parameter value missing for "..paramName
          if srcTable == nil or not IsTable(srcTable) then
              if reqMsg == true then P(err) end
              return nil
          end
          for k, v in ipairs(srcTable) do
              if v == paramName then
                  local idx = k + 1
                  if #srcTable < idx then
                      if reqMsg == true then P(err) end
                      return nil
                  end
                  local val = srcTable[idx]
                  if not reqType or reqType == "string" or reqType == "s" then
                      if val == '""' or val == "''" then return nil end
                      return val
                  elseif ((reqType == "int" or reqType == "i") and not strmatch(val, "%D")) then
                      return tonum(val)
                  elseif reqType == "number" or reqType == "n" then
                      return tonum(val)
                  elseif reqType == "bool" or reqType == "b" then
                      if val then return true else return false end
                  end
                  return nil
              end
          end
          if reqMsg == true then E(err) end
          return nil
      end


      function PairsByKeys(t, f)
          local a = {}
          for n in pairs(t) do table.insert(a, n) end
          table.sort(a, f)
          local i = 0     local iter = function ()         i = i + 1
              if a[i] == nil then
                  return nil
              else
                  return a[i], t[a[i]]
              end
          end
          return iter
      end


      function BoolState(bool)
          if bool then
              return "enabled"
          else
              return "disabled"
          end
      end


      function BoolStr(b)
          if b == true then
              return "true"
          else
              return "false"
          end
      end


      function ScreenOutput(output, chatFooter)
          local chat = "Point at screen, CTRL+L, then copy text!"
          if #Config.screens >  0 then
                                              local font = OutputFont or "FiraMono"
              local pre = "local text = [[\n"..output.."\n]]\n"..
      [[

      local rslib = require('rslib')

      local layer = createLayer()

      local rx, ry = getResolution()

      local fontSize = 15

      local font = loadFont("]]..font..[[", fontSize)

      local line = 1

      for str in text:gmatch("([^\n]+)") do
          addText(layer, font, str, 20, line*(fontSize+4))
          line = line + 1
      end ]]
                      Config.screens[1].setRenderScript(pre)
              if chatFooter and chatFooter:len() then
                  chat = chatFooter.."\n"..chat
              end
          else
              chat = "Hint: link a screen to PB to easily copy text from it!"
          end
          P(chat)
          return true
      end

      end)

      package.preload['YFS-Tools:commands.lua']=(function()

      local cmd = {}



      local strmatch, sformat, strlen = string.match, string.format, string.len

      local tonum, uclamp, mabs, max, floor, ceil = tonumber, utils.clamp, math.abs, math.max, math.floor, math.ceil



      local function yfsAddAltitudeWaypoints(wpdata, wpnames, altitude, suffix)
          local cnt = 0
          local names = {}
          local wpCnt = #wpnames
          for _,k in ipairs(wpnames) do
              local wp = wpdata.v[k]
              if wp ~= nil then
                  cnt = cnt + 1
                  local wpN = k .. suffix
                  if cnt > 1 then table.insert(names, wpN) end
                  table.insert(names, k)
                  if cnt < wpCnt then table.insert(names, wpN) end
                  local newPos = PM.ReplaceAltitudeInPos(wp.pos, altitude)
                  if wpdata.v[wpN] ~= nil then
                      wpdata.v[wpN].pos = newPos
                  else
                      wpdata.v[wpN] = { pos = newPos }
                      P(wpN .."  " .. newPos)
                  end
              end
          end
          if cnt == 0 then
              P("[E] No waypoints processed!")
              return nil,nil
          end
          P("[I] "..cnt.." waypoints at "..altitude.."m added (or changed)!")
          return wpdata, names
      end


      local function storeYFSData(keyName, data)
          if not DetectedYFS or not keyName then return false end
          YFSDB:setData(keyName, data)
          return true
      end


      local function getYFSData(keyName)
          if not DetectedYFS or not keyName then return false end
          local data = YFSDB:getData(keyName)
          if data == nil or not IsTable(data.v) then
              return false
          end
          return data
      end


      local function storeYFSNamedWaypoints(data)
          storeYFSData(YFS_NAMED_POINTS, data)
      end


      local function storeYFSRoutes(data)
          storeYFSData(YFS_ROUTES, data)
      end



      function cmd.FindCenterCmd(text)
          if not WM or not WM:hasPoints() then
              return E("[E] No waypoints to export.")
          end
          local routes = cmd.GetYFSRoutes()
          if not routes then return end

          local parts = SU.SplitQuoted(text)
          if #parts < 1 then
              return E("[E] Parameter(s) missing: routename\nExample: /findCenter 'Cryo' -onlySelectable")
          end
          local onlySelectable = GetIndex(parts, "-onlySelectable") > 0
          local routename = parts[1]
          local route = routes.v[routename]
          if not route or not IsTable(route.points) or #route.points == 0 then
              return E("[E] Route '"..routename.."' not found or empty")
          end

          local wpdata = cmd.GetYFSNamedWaypoints()

              local pointlist = {}
          local wpIdx = 1
          for _,v in ipairs(route.points) do
              local wppos = ""
              local wpName = "WP "..sformat("%03d", wpIdx)
              if v.waypointRef and wpdata then
                  wpName = v.waypointRef
                  wppos = wpdata.v[wpName].pos
              else
                  wppos = v.pos
              end

              if wppos and ((not onlySelectable) or (v.opt["selectable"] ~= false)) then
                  P("Using "..wpName)
                  pointlist[wpIdx] = PM.MapPosToWorldVec3(wppos)
              end
              wpIdx = wpIdx + 1
          end
          local center = GetCentralPoint(pointlist)
          if center then
              local locPos = PM.WorldToMapPos(center)
              local output = "[I] Center coords: "..PM.MapPos2String(locPos)
              P(output)
          else
              P("[E] Could not calculate center, sorry!")
          end
      end


      function cmd.GetYFSNamedWaypoints(muteMsg)
          if not DetectedYFS then
              return E("[E] Linked YFS databank required!")
          end
          local namedWP = getYFSData(YFS_NAMED_POINTS)
          if not namedWP and not muteMsg then
              P("[I] No named waypoints")
          end
          return namedWP
      end


      function cmd.GetYFSRoutes()
          if not DetectedYFS then
              return E("[E] Linked YFS databank required!")
          end
          local data = getYFSData(YFS_ROUTES)
          if not data then
              return E('[I] No YFS routes found.')
          end
          return data
      end


      function cmd.PlanetInfoCmd(text)
          PM.PlanetInfo(text)
      end


      function cmd.PrintAltitudeCmd(text)
          P(Out.PrettyDistance(PM.Altitude()))
      end


      function cmd.PrintPosCmd(text)
          P(PM.GetCurrentPosString())
      end


      function cmd.PrintWorldPosCmd(text)
          P(PM.Vec3ToPosString(PM.WorldPosVec3()))
      end


      function cmd.WarpCostCmd(text)
          CalcWarpCost(text)
      end


      function cmd.WpSaveNamedCmd(text, isYfs)
          if not WM or not WM:hasPoints() then
              return E("[E] No waypoints to export.")
          end
          local output = ""
          for _,wp in ipairs(WM:getSorted()) do
              local pos = wp:AsString()
              if isYfs then
                  pos = "pos-save-as '" .. wp:getName() .. "' -pos '" .. pos .. "'"
              else
                  pos = "/addlocation " .. wp:getName() .. " " .. pos
              end
              output = output .. pos .. "\n"
              P(pos)
          end
          ScreenOutput(output)
      end


      function cmd.ArchSaveNamedCmd(text)
          cmd.WpSaveNamedCmd(text, false)
      end


      function cmd.WpExportCmd(text)
          if not WM or not WM:hasPoints() then
              return E("[E] No waypoints to export.")
          end
          local output = ""
          local wplist = WM:getSorted()
          for _,wp in ipairs(wplist) do
              local s = wp:getName() .. "\n" .. wp:AsString() .. "\n"
              output = output .. s
          end
          P(output)
          ScreenOutput(output)
      end


      function cmd.WpAltitudeCeilingCmd(text)
          local wpnames = cmd.GetYFSNamedWaypoints()
          if not wpnames then return end

              local parts = SU.SplitQuoted(text)
          if #parts ~= 2 then
              P("[E] Parameter(s) missing: 'name 1' 'name 2'")
              return E("Example: /wp-altitude-ceiling 'Base 1' 'Base 2'")
          end
          local wpName1 = parts[1]
          local wpName2 = parts[2]

              local wp1found, wp2found = true, true
          if wpnames.v[wpName1] == nil or wpnames.v[wpName1] == "" then
              P("[E] Waypoint '".. wpName1 .."' not found.")
              wp1found = false
          end
          if wpnames.v[wpName2] == nil or wpnames.v[wpName2] == "" then
              P("[E] Waypoint '".. wpName2 .."' not found.")
              wp2found = false
          end
          if not wp1found or not wp2found then return end
          if wpnames.v[wpName1] == wpnames.v[wpName2] then
              return E("[E] Parameters invalid (same names).")
          end

              local alt1 = PM.GetAltitudeFromPos(wpnames.v[wpName1].pos)
          local alt2 = PM.GetAltitudeFromPos(wpnames.v[wpName2].pos)
          if alt1 == alt2 then
              P("[I] Waypoints had same altitude, no changes applied.")
              return
          end
          local target, targetAlt = "", 0
          if alt1 > alt2 then
              target = wpName2
              targetAlt = alt1
          else
              target = wpName1
              targetAlt = alt2
          end
          local newPos = PM.ReplaceAltitudeInPos(wpnames.v[target].pos, targetAlt)
          wpnames.v[target].pos = newPos
          P("[I] Waypoint '"..target.."' changed to:")
          P(newPos)

              storeYFSNamedWaypoints(wpnames)
          return true
      end


      function cmd.GetStoredLocations(points)     if not points or not IsTable(points) then return end
          for _,p in ipairs(points) do
              if p.name and p.position and p.position.x and p.position.y and p.position.z then
                  P("[I] Location '".. p.name .."' found.")
                  local pos = '::pos{0,0,'.. p.position.x .. ',' .. p.position.y .. ',' .. p.position.z ..'}'
                  PM.CreateWaypoint(pos, p.name)
              end
          end
      end


      function cmd.YfsAddAltitudeWpCmd(text)
          local wpdata = cmd.GetYFSNamedWaypoints()
          if not wpdata or not IsTable(wpdata.v) or TableLen(wpdata.v) == 0 then
              return E("[E] No waypoints.")
          end

          local example = "\nExample: /yfs-add-altitude-wp -altitude 450 -suffix 'F'"
          local args = SU.SplitQuoted(text)
          local pStart = GetParamValue(args, "-wpStartsWith", "s")
          if #args < 1 then
              return E("[E] Parameter missing: -altitude"..example)
          end
          local pAlt = GetParamValue(args, "-altitude", "n", true)
          local pSuf = GetParamValue(args, "-suffix", "s")
          if not pSuf or pSuf == "" then pSuf = "F" end
          if pAlt < -100 or pAlt > 20000 then
              return E("[E] -altitude value out of range (-100 .. 20000)"..example)
          end

              local wplist = {}
          for k in PairsByKeys(wpdata.v) do
              if not pStart or k:find(pStart) > 0 then
                  table.insert(wplist, k)
              end
          end
          local newData, names = yfsAddAltitudeWaypoints(wpdata, wplist, pAlt, pSuf)
          if newData ~= nil and names ~= nil then
              storeYFSNamedWaypoints(newData)
          end
          return true
      end


      function cmd.YfsBuildRouteFromWpCmd(text)
          local wpdata = cmd.GetYFSNamedWaypoints()
          if not wpdata or not IsTable(wpdata.v) or TableLen(wpdata.v) == 0 then
              return E("[E] No waypoints.")
          end

          local rdata = cmd.GetYFSRoutes()
          if not rdata or not IsTable(rdata.v) or TableLen(rdata.v) == 0 then
                      rdata = { v = {}, t = "table" }
          else
          end

          local example = "\nExample: /yfs-build-route-from-wp -name 'Route' -altitude 450 -wpStartsWith 'Chr' -suffix 'F'\n-suffix is optional, default F (Flight)"
          local args = SU.SplitQuoted(text)
          if #args < 1 then
              return E("[E] Parameters missing!"..example)
          end

          local pName  = GetParamValue(args, "-name", "s", true)
          if not pName then return end
          local pStart = GetParamValue(args, "-wpStartsWith", "s")
          local pAlt   = GetParamValue(args, "-altitude", "n", true)
          if not pAlt then return end
          local pSuf   = GetParamValue(args, "-prefix", "s")
          local pMarginL = GetParamValue(args, "-marginL", "n")
          local pMarginF = GetParamValue(args, "-marginF", "n")
          local pMaxSpeed = GetParamValue(args, "-maxSpeed", "n")
          local pFinalSpeedF = GetParamValue(args, "-finalSpeedF", "n")
              pMarginL = uclamp(pMarginL or 0.1, 0.1, 100)     pMarginF = uclamp(pMarginF or 0.1, 0.1, 100)     pMaxSpeed = uclamp(pMaxSpeed or 0, 0, 1200)     pFinalSpeedF = uclamp(pFinalSpeedF or 0, 0, 1200)     if rdata.v[pName] ~= nil then
              return E("[E] Route "..pName.."already exists, aborting!")
          end
          if type(pSuf) ~= "string" or pSuf == "" then pSuf = "F" end
          if strlen(pSuf) > 3 then
              return E("[E] -suffix accepts max. 3 characters"..example)
          end
          if pAlt < -600 or pAlt > 20000 then
              return E("[E] -altitude value out of range (-100 .. 20000)"..example)
          end

                  local wplist = {}
          for k in PairsByKeys(wpdata.v) do
              if not pStart or k:find(pStart) > 0 then
                  table.insert(wplist, k)
              end
          end

              local wpdata, wplistNew = yfsAddAltitudeWaypoints(wpdata, wplist, pAlt, pSuf)
          if wpdata == nil or wplistNew == nil then
              return E("[I] No waypoints processed: no changes made.")
          end

              rdata.v[pName] = { points = {} }

                  local cnt = 0
          for _,k in ipairs(wplistNew) do
              local wp = wpdata.v[k]
              if wp ~= nil then
                              cnt = cnt + 1
                  local rOpt = { margin = 0.1, maxSpeed = 0 }
                  local rp = { opt = rOpt, pos = wp.pos, waypointRef = k }
                              if GetIndex(wplist, k) < 1 then
                                      if pFinalSpeedF and pFinalSpeedF > 0 and GetIndex(wplist, k) < 1 then
                          rp.opt.finalSpeed = pFinalSpeedF
                      end
                                      if pMaxSpeed and pMaxSpeed > 0 then
                          rp.opt.maxSpeed = pMaxSpeed
                      end
                                      if pMarginF and pMarginF > 0.1 then
                          rp.opt.margin = pMarginF
                      end
                      rp.opt.selectable = false
                      rp.opt.skippable = false
                  else                                 if pMarginL and pMarginL > 0.1 then
                          rp.opt.margin = pMarginL
                      end
                      rp.opt.selectable = true
                      rp.opt.skippable = true
                  end
                  table.insert(rdata.v[pName].points, rp)
              end
          end
          P("[I] "..cnt.." positions added to route '"..pName.."'")
          storeYFSNamedWaypoints(wpdata)
          storeYFSRoutes(rdata)
      end


      function cmd.YfsSaveRouteCmd(text)
          local routes = cmd.GetYFSRoutes()
          if not routes then return end

          local parts = SU.SplitQuoted(text)
          if #parts < 1 then
              return E("[E] Parameter(s) missing: routename\nExample: /yfs-save-route 'Cryo' -onlySelectable -withOptions -prefix 'Cryo'")
          end
          local wpPrefix = GetParamValue(parts, "-prefix", "s")
          if not wpPrefix then wpPrefix = "WP" end
          local onlySelectable = GetIndex(parts, "-onlySelectable") > 0
          local withOptions = GetIndex(parts, "-withOptions") > 0
          local routename = parts[1]
          local route = routes.v[routename]
          if not route or not IsTable(route.points) or #route.points == 0 then
              return E("[E] Route '"..routename.."' not found or empty")
          end
          local output1, output2 = "route-create '"..routename.."'\r\n", ""

          local wpdata = cmd.GetYFSNamedWaypoints()

                  local wpIdx = 1
          local wpNames = {}     for _,v in ipairs(route.points) do
              local wppos = ""
              local wpName = wpPrefix.." "..sformat("%03d", wpIdx)
              if v.waypointRef and wpdata then
                  wpName = v.waypointRef
                  wppos = wpdata.v[wpName].pos
              else
                  wppos = v.pos or "<unknown>"
              end

              if GetIndex(wpNames, wpName) < 0 then
                  wpNames[#wpNames + 1] = wpName
                  local tmp = "pos-save-as '"..wpName.."' -pos '"..wppos.."'"
                  output1 = output1 .. tmp .. "\n"
              end
              if (not onlySelectable) or (v.opt["selectable"] ~= false) then
                  local tmp = "route-add-named-pos '"..wpName.."'"
                  if withOptions then
                                                      if v.opt["maxSpeed"] and v.opt["maxSpeed"] ~= 0 then
                          tmp = tmp.." -maxspeed "..v.opt["maxSpeed"]
                      end
                      if v.opt["margin"] and v.opt["margin"] ~= 0.1 then
                          tmp = tmp.." -margin "..v.opt["margin"]
                      end
                                      local routeLvlOptions = false
                      local routeOptStr = ""
                      if v.opt["skippable"] == true then
                          routeLvlOptions = true
                          routeOptStr = routeOptStr .. " -toggleSkippable"
                      end
                      if v.opt["selectable"] == false then
                          routeLvlOptions = true
                          routeOptStr = routeOptStr .. " -toggleSelectable"
                      end
                      if v.opt["finalSpeed"] and v.opt["finalSpeed"] ~= 0 then
                          routeLvlOptions = true
                          routeOptStr = routeOptStr.." -finalSpeed "..v.opt["finalSpeed"]
                      end
                      if routeLvlOptions then
                          tmp = tmp .. "\nroute-set-pos-option -ix "..wpIdx..routeOptStr
                      end
                  end
                  output2 = output2 .. tmp .. "\n"
                  wpIdx = wpIdx + 1
              end
          end
          output2 = output2.."route-save\r\n"
          P(output1..output2)
          ScreenOutput(output1..output2)
      end


      function cmd.YfsReplaceWpCmd(text)
          local wpnames = cmd.GetYFSNamedWaypoints()
          if not wpnames then return end

          local ex = "\r\nExample: /yfs-replace-wp 'base 1'"
          local params = SU.SplitQuoted(text)
          if #params < 1 then
              return E("[E] Parameter(s) missing: -name 'point'"..ex)
          end

          local wpName = GetParamValue(params, "-name", "s", true)
          if not wpName then return end
          if not wpnames.v[wpName] or wpnames.v[wpName] == "" then
              return E("[E] Waypoint '".. wpName .."' not found."..ex)
          end

          local newPos = PM.GetCurrentPosString()
          local pPos = GetParamValue(params, "-pos", "s")
          if pPos then
                      local tmp = PM.SplitPos(pPos)
              if not tmp then
                  return E("[E] Invalid ::pos{} specified!")
              end
              newPos = pPos
          end

          wpnames.v[wpName].pos = newPos
          P("[I] Waypoint '"..wpName.."' changed to:")
          P(newPos)

          storeYFSNamedWaypoints(wpnames)
          return true
      end


      function cmd.YfsOptionsResetCmd(text)
          local routes = cmd.GetYFSRoutes()
          if not routes then return end

              local example = "\nExample:\n/yfs-options-reset -route 'name' -ix 2 -endIx 3\nWith -endIx being optional."
          local parts  = SU.SplitQuoted(text)
          local pName  = GetParamValue(parts, "-route", "s", true)
          if not pName then return E(example) end
          if not routes.v[pName] then
              return E("[E] Route '"..pName.."' not found."..example)
          end
          if not routes.v[pName].points or #routes.v[pName].points == 0 then
              return E("[E] Route '"..pName.."' empty.")
          end

          local pStart = GetParamValue(parts, "-ix", "i", true)
          local pEnd   = GetParamValue(parts, "-endIx", "i")
          if not pEnd then pEnd = #routes.v[pName].points end
          local isError = not pName or not pStart or (pStart < 1) or (pEnd and pEnd < pStart)
          if isError then
              return E("[E] Wrong number of parameters / invalid values!"..example)
          end
          if not pEnd or pEnd < pStart then pEnd = pStart end

                  P("[I] Processing route '"..pName.."'")
          local changed = 0
          local finalSpeed = 30 / 3.6     for i,v in ipairs(routes.v[pName].points) do
              if i >= pStart and i <= pEnd then
                  local wpName = v.waypointRef
                  if not wpName then
                      wpName = i             end
                  changed = changed + 1
                              routes.v[pName].points[i].opt.finalSpeed = finalSpeed
                  routes.v[pName].points[i].opt.maxSpeed = 0
                  routes.v[pName].points[i].opt.margin = 0.1
                  routes.v[pName].points[i].opt.lockDir = nil
                  P("[I] Options reset for route waypoint: "..wpName)
              end
          end
          if changed == 0 then
              return E("[I] No waypoints in route changed.\n[*] Make sure that start (and end-index) are valid.")
          end
              storeYFSRoutes(routes)
          P("[I] Routes saved.")
      end


      function cmd.YfsRouteAltitudeCmd(text)
          local routes = cmd.GetYFSRoutes()
          if not routes then return end

          local namedWP = cmd.GetYFSNamedWaypoints()
          
              local example = "\nExample:\n/yfs-route-altitude -route 'name' -ix 2 -endIx 3 -alt 330\nThe -endIx is optional."
          local parts  = SU.SplitQuoted(text)
          local pName  = GetParamValue(parts, "-route", "s", true)
          if not pName then return end
          if not routes.v[pName] then
              return E("[E] Route '"..pName.."' not found."..example)
          end
          if not routes.v[pName].points or #routes.v[pName].points == 0 then
              return E("[E] Route '"..pName.."' empty.")
          end

          local pStart = GetParamValue(parts, "-ix", "i", true)
          local pEnd   = GetParamValue(parts, "-endIx", "i")
          local pAlt   = GetParamValue(parts, "-alt", "n", true)
          if not pEnd then pEnd = #routes.v[pName].points end

          local isError = not pName or not pStart or not pAlt or (pStart < 1) or (pEnd and pEnd < pStart) or (pAlt < -100) or (pAlt > 10000)
          if isError then
              return E("[E] Wrong number of parameters / invalid values!"..example)
          end
          if not pEnd or pEnd < pStart then pEnd = pStart end

                  P("[I] Processing route '"..pName.."'")
          local changed = 0
          local wpnames = {}
          for i,v in ipairs(routes.v[pName].points) do
              if i >= pStart and i <= pEnd then
                  local newPos = ""
                  local wpName = v.waypointRef
                  if wpName and namedWP and namedWP.v and namedWP.v[wpName] then
                      local wp = namedWP.v[wpName]
                      if GetIndex(wpnames, wpName) < 1 then
                          table.insert(wpnames, wpName)
                      end
                      newPos = PM.ReplaceAltitudeInPos(wp.pos, pAlt)
                  else                 wpName = i
                      newPos = PM.ReplaceAltitudeInPos(v.pos, pAlt)
                  end
                  changed = changed + 1
                  routes.v[pName].points[i].pos = newPos
                  P("[I] Route Waypoint '"..wpName.."' changed to:\n"..newPos)
              end
          end
          if changed == 0 then
              return E("[I] No waypoints in route changed.\n[*] Make sure that start (and end-index) are valid.")
          end
              storeYFSRoutes(routes)
          P("[I] Routes saved.")

              changed = 0
          for _,entry in ipairs(wpnames) do
              if namedWP and namedWP.v[entry] then
                  changed = changed + 1
                  local newPos = PM.ReplaceAltitudeInPos(namedWP.v[entry].pos, pAlt)
                  namedWP.v[entry].pos = newPos
                  P("[I] Named Waypoint '"..entry.."' changed to:")
                  P(newPos)
              else
                  P("[E] '"..entry.."' not found!")
              end
          end
              if changed > 0 then
              storeYFSNamedWaypoints(namedWP)
              P("[I] Named waypoints saved.")
          end
      end


      function cmd.YfsWpAltitudeCmd(text)
              local wpnames = cmd.GetYFSNamedWaypoints()
          if not wpnames then return E("[E] No named waypoints.") end

              local parts = SU.SplitQuoted(text)
          if #parts ~= 2 then
              return E("[E] Wrong number of parameters!\nExample: /yfs-wp-altitude 'Base 1' 324.12")
          end
          local pName = parts[1] or ""

              if not pName or not parts[2] or not wpnames.v[pName] or wpnames.v[pName] == "" then
               return E("[E] Waypoint '".. pName .."' not found")
          end

              local pAlt = tonum(parts[2] or 0)
          local newPos = PM.ReplaceAltitudeInPos(wpnames.v[pName].pos, pAlt)
          wpnames.v[pName].pos = newPos
          P("[I] Waypoint '"..pName.."' changed to:")
          P(newPos)
          P("[I] Note: routes' waypoints are updated on route activation, i.e. exporting route data before activation may still show old value!")

              storeYFSNamedWaypoints(wpnames)
          return true
      end


      function cmd.YfsRouteNearestCmd(text)
          local routes = cmd.GetYFSRoutes()
          if not routes then return end
              local params = SU.SplitQuoted(text)
          if #params == 0 or #params > 2 then
              P("[E] Wrong parameter count\n[I] Example: /yfs-route-nearest 'Route 1'")
              P("\nOptional parameter:\n")
              P("-onlySelectable -> only show closest, selectable waypoints in route")
              return false
          end
              local routeName = params[1]
          local route = routes.v[routeName]
          if not route or not IsTable(route.points) then
              return E("[E] Route '" .. routeName .."' not found or empty")
          end
          P("[I] Route '"..routeName.."' found.")
              local onlySelectable = GetIndex(params, "-onlySelectable") > 0

              local wplist = cmd.GetYFSNamedWaypoints(true)
          local idx = 0
          local closestDist = 999999999
          local sDist, sNearest = "", ""
          local res =  {}
          for k,v in ipairs(route.points) do
              idx = idx + 1
              if (not onlySelectable) or (v.opt and v.opt.selectable ~= false) then
                  local wpname = SU.Trim(sformat("%02d", idx) .. ": '"..(v.waypointRef or "").."'")
                  local pos = v.pos
                  if v.waypointRef and wplist then
                      pos = wplist.v[v.waypointRef].pos
                  end
                  local dist = PM.GetDistance(pos)
                  if dist > 0.1 then
                      route.points[k].distance = dist
                      sDist = wpname .. " = " .. sformat("%.4f", dist)
                      if dist < closestDist then
                          sNearest = sDist
                          closestDist = dist
                      end
                      local tmpDist = tostring(math.modf(dist * 10000))
                      local key = ('0'):rep(12-#tmpDist)..tmpDist
                      res[key] = idx
                  end
              end
          end
          if not idx then return E("[I] No selectable waypoints found.") end
          local output = "Route-Idx / Name / Distance (m)\n"
          for _,key in pairs(GetSortedAssocKeys(res)) do
              local routeIdx = res[key]
              local wpName = route.points[routeIdx].waypointRef or routeIdx
              local wpDist = route.points[routeIdx].distance
              output = output .. sformat("%02d", routeIdx).." / '"..wpName.."' / "
              output = output .. Out.PrettyDistance(wpDist).."\n"
          end
          output = output .. "\n[I] Nearest waypoint: "..sNearest

          Out.PrintLines(output)
          ScreenOutput(output)
      end


      function cmd.YfsRouteToNamedCmd(text)
          local routes = cmd.GetYFSRoutes()
          if not routes then return end
              local params = SU.SplitQuoted(text)
          if #params == 0 or #params > 6 then
              P("[E] Wrong parameter count\n[I] Example: /yfs-route-to-named 'Route 1'\nOptional parameters:\n")
              P("-onlySelectable -> only write waypoints marked as selectable in route")
              P("-prefix Myprefix -> if unspecified, 'WP' is default")
              P("-toScreen -> output JSON of list to optional screen if linked")
              P("-toDB -> only if this is given, the changed list will be written to DB to avoid miscalls")
              P("Important: command aborts if ANY waypoint's name starts with given prefix to avoid errors!")
              return false
          end
              local routeName = params[1]
          local route = routes.v[routeName]
          if not route or not IsTable(route.points) then
              return E("[E] Route '" .. routeName .."' not found or empty")
          end
          P("[I] Route '"..routeName.."' found.")
              local toDB = GetIndex(params, "-toDB") > 0
          local toScreen = GetIndex(params, "-toScreen") > 0
          local onlySelectable = GetIndex(params, "-onlySelectable") > 0
          local wpPrefix = GetParamValue(params, "-prefix", "s")
          if not wpPrefix then wpPrefix = "WP" end

              local wplist = cmd.GetYFSNamedWaypoints(true)
          if not wplist or not wplist.v then
              wplist = { v = { } }
          else
                      for k,_ in pairs(wplist.v) do
                  if string.find(k, wpPrefix) == 1 then
                      return E("[!] Waypoints with same prefix already exist!\n[!] Command aborted.")
                  end
              end
          end
          local idx = 0
          for _,v in ipairs(route.points) do
              if (not onlySelectable) or (v.opt and v.opt.selectable ~= false) then
                  idx = idx + 1
                  local wpname = wpPrefix .. " " .. sformat("%02d", idx)
                  local wp = { pos = v.pos, opt = v.opt}
                              wplist.v[wpname] = wp
                  P(wpname .."  " .. v.pos)
              end
          end
          if not idx then return E("[I] No changes to waypoints done") end

              if toDB then
              storeYFSNamedWaypoints(wplist)
              P("[I] Waypoint changes saved to databank!")
          else
              P("[I] -toDB not present, no changes saved to databank!")
          end
          if toScreen then
              ScreenOutput(json.encode(wplist.v))
          end
      end


      function cmd.YFSLoadNamedWaypoints()
          local wpnames = cmd.GetYFSNamedWaypoints()
          if not wpnames then return end
          for k,v in pairs(wpnames.v) do
              PM.CreateWaypoint(v.pos, k)
          end
      end


      function cmd.YFSLoadRoutepoints(onlySelectableWP, onlyWpForRoute)
          local routes = cmd.GetYFSRoutes()
          if not routes then return false end
          P('[I] Processing routes...')
          for k,v in pairs(routes.v) do
              if (onlyWpForRoute == "" or onlyWpForRoute == k) and IsTable(v) then
                  for k2,v2 in ipairs(v.points) do
                      if (not onlySelectableWP) or (v2.opt["selectable"] ~= false) then
                          local wpName = k .. " " .. k2
                          if v2.waypointRef then
                              wpName = v2.waypointRef
                          end
                          PM.CreateWaypoint(v2["pos"], wpName)
                      end
                  end
                  P("[I] Route '"..k.."' read.")
              end
          end
          return true
      end


      function cmd.YfsSaveNamedCmd(text)
          cmd.WpSaveNamedCmd(text, true)
      end


      function cmd.PosDataCmd()
              P("getCameraHorizontalFov: "..system.getCameraHorizontalFov())
          P("getCameraVerticalFov: "..system.getCameraVerticalFov())

          P("getCameraPos: "..PM.Vec3String(system.getCameraPos()))
          P("getCameraForward: "..PM.Vec3String(system.getCameraForward()))
          P("getCameraRight: "..PM.Vec3String(system.getCameraRight()))
          P("getCameraUp: "..PM.Vec3String(system.getCameraUp()))

          P("getCameraWorldPos: "..PM.Vec3String(system.getCameraWorldPos()))
          P("getCameraWorldForward: "..PM.Vec3String(system.getCameraWorldForward()))
          P("getCameraWorldRight: "..PM.Vec3String(system.getCameraWorldRight()))
          P("getCameraWorldUp: "..PM.Vec3String(system.getCameraWorldUp()))

          P("construct.getWorldPosition: "..PM.Vec3String(construct.getWorldPosition(CNID)))
          P("construct.getOrientationForward: "..PM.Vec3String(construct.getOrientationForward()))
          P("construct.getOrientationRight: "..PM.Vec3String(construct.getOrientationRight()))
          P("construct.getOrientationUp: "..PM.Vec3String(construct.getOrientationUp()))
      end


      function cmd.DumpPointsCmd()
          if true then
              P("~=~=~=~=~=~=~= DUMP START ~=~=~=~=~=~=")
              local tmp = Out.DumpVar(WM:getWaypointsInst())
              P(tmp)
              return ScreenOutput((tmp or "[I] No waypoints."),"\n~=~=~=~=~=~=~= DUMP END ~=~=~=~=~=~=~=")
          end

      end


      function cmd.DumpRoutesCmd()
          if not DetectedYFS then return E("[I] No YFS databank.") end
          P("~=~=~=~=~=~=~= ROUTES DUMP START ~=~=~=~=~=~=")
          local tmp = YFSDB:getString(YFS_ROUTES)
          P(tmp)
          ScreenOutput((tmp or "[I] No routes."),"\n~=~=~=~=~=~=~= ROUTES DUMP END ~=~=~=~=~=~=~=")
      end


      function cmd.RoutesCmd()
          local routes = cmd.GetYFSRoutes()
          if not routes then return end
          P("[I] Available routes:")
          for k,_ in pairs(routes.v) do
              P(k)
          end
      end



      function cmd.YfsTestDataCmd(param)
          if not (param == "TESTING") then return end
          P("[*] Creating YFS test data...")

          YFSDB:remove(YFS_NAMED_POINTS)
          local data = { }
          data["Chr 01"] = { pos = "::pos{0,7,-20.7784,-153.7402,360.5184}", opt = {} }
          data["Chr 02"] = { pos = "::pos{0,7,-21.3610,-152.3447,345.8787}", opt = {} }
          data["Chr 03"] = { pos = "::pos{0,7,-23.0540,-152.8934,360.6677}", opt = {} }
          data["Chr 04"] = { pos = "::pos{0,7,-22.4445,-154.3119,320.1029}", opt = {} }
          data["Chr 05"] = { pos = "::pos{0,7,-20.5370,-154.7507,308.0151}", opt = {} }
          data["Chr 06"] = { pos = "::pos{0,7,-21.6295,-155.1465,292.7660}", opt = {} }
          data["Chr Hub"] = { pos = "::pos{0,7,-21.9903,-153.1008,391.4632}", opt = {} }
          local tmp = { v = data, t = type(data) }
          storeYFSNamedWaypoints(tmp)

          YFSDB:remove(YFS_ROUTES)
          local r = { }
                  storeYFSRoutes({ v = r, t = type(r) })

          P("[*] YFS test data saved!")
          cmd.DumpPointsCmd()
          cmd.DumpRoutesCmd()
      end


      function cmd.ConversionTestCmd(param)
          PM.ConversionTest()
      end


      function cmd.XCmd()
                  end

      return cmd

      end)

      package.preload['YFS-Tools:help.lua']=(function()

      local help = {}


      function help.PrintHelpCmd()
          local hlp = "~~~~~~~~~~~~~~~~~~~~\nYFS-Tools Commands:\n~~~~~~~~~~~~~~~~~~~~\n"..
          "/arch-save-named\n-> Builds list of chat commands for ArchHud to add locations for all named waypoints.\n"..
          "/findCenter\n-> Calculates center between all points of a route, like for a central hub.\n"..
          "/planetInfo (id or name)\n-> Info about current planet or for passed planet id or name, e.g. 2 for Alioth).\n"..
          "/printAltitude /printPos /printWorldPos\n-> Prints info data.\n"..
          "/warpCost -from name/::pos{}/planets -to name/::pos{}/planets -mass tons -moons\n-> Flexible warp cell calculator.\n"..
          "/wp-altitude-ceiling\n-> Changes a waypoint to have the higher altitude of both.\n"..
          "/wp-export\n-> Outputs list of plain waypoints to chat and an optional screen. Source can include ArchHud locations, too, if databank linked.\n"..
          "/yfs-add-altitude-wp\n-> Adds waypoints for each existing WP at a specified altitude and name suffix.\n"..
          "/yfs-build-route-from-wp\n-> Powerful route-building command based on existing named waypoints.\n"..
          "/yfs-options-reset\n-> Reset options of route waypoints for a specific route.\n"..
          "/yfs-replace-wp 'name'\n-> Replaces a named waypoint with the current location.\n"..
          "/yfs-route-altitude\n-> Changes altitude for a range of waypoints of a specific YFS route.\n"..
          "/yfs-route-nearest\n-> Show list of route waypoints by distance from current location.\n"..
          "/yfs-route-to-named\n-> Converts a route's *unnamed* waypoints to named waypoints for YFS.\n"..
          "/yfs-save-named\n-> Builds list of YFS commands to recreate all named waypoints.\n"..
          "/yfs-save-route\n-> Builds list of YFS commands to recreate full route incl. named waypoints and their options.\n"..
          "/yfs-wp-altitude\n-> Changes altitude of a named waypoint to specified altitude.\n"..
          "=========================================\n"..
          "Important: Enclose names (as parameters) in single quotes if they contain blanks!\n"..
          "*** DO NOT USE COMMANDS THAT CHANGE POINTS ***\n*** OR ROUTES WHILE YFS IS RUNNING! ***\n"
          ScreenOutput(hlp)
          P(hlp)
      end


      return help

      end)

      package.preload['YFS-Tools:warpcost.lua']=(function()

      local strmatch, sformat, strlen = string.match, string.format, string.len

      local tonum, uclamp, mabs, max, floor, ceil = tonumber, utils.clamp, math.abs, math.max, math.floor, math.ceil



      function CalcWarpCost(text)
          local example = "\nExample 1:\n/warpCost -from Madis -to Alioth -mass 534"..
              "\nExample 2:\n/warpCost -from Alioth -to planets -moons"..
              "\nOptional '-from x' with x being either 'here', a planet name, ::pos{} or 'planets' (multi-result)."..
              "\nOptional '-to x' like -from, but for end location."..
              "\nOptional '-mass x' with x the total mass in tons. If not given, the current constructs' total mass is used."..
              "\nOptional '-cargo x' with x the cargo mass in tons. If specified, a cell count for a return trip is calculated, too."..
              "\nOptional '-moons' only together with 'planets' to also include moons in the list."..
              "\n- One of -from or -to can be left out, then the current construct's location (or planet) is used."..
              "\n- If construct is landed on a planet or moon, the Atlas specified warp altitude is the starting point."..
              "\n- Enclose names in single-quotes if they contain spaces!"
          local getCMass = construct.getMass
          local pOn, onPlanet = {}, false
          local s, s2 = "~~~ WARP CELL CALCULATOR ~~~", ""

          local function checkParam(args, pName, isFrom)
              local v, allPlanets, offs = {}, false, 0
              local par = GetParamValue(args, pName, "s")
              if not par or (par == "") or (par == "here") then
                  v = PM.WorldPosVec3()             if onPlanet and pOn then
                      offs = 2 * pOn.radius
                      par = pOn.name[1]
                      v = vec3(pOn.center)
                  else
                      offs = 12                 par = PM.Vec3ToPosString(v)
                  end
              elseif par == "planets" then
                  allPlanets = true
              elseif par > "" then
                  if SU.StartsWith(par, "::pos{") then
                      offs = 12                 v = PM.MapPosToWorldVec3(par)
                  else
                      local p = PM.PlanetByName(par)
                      if p then
                          offs = 2 * p.radius
                          v = vec3(p.center)
                      end
                  end
              end
              return { parm = par, v = v, isP = allPlanets, offset = offs }
          end

          local args = SU.SplitQuoted(text)
          if #args < 1 then return E("[E] Parameter(s) missing!"..example) end
          local pMoons = GetIndex(args, "-moons") > 0

                  local offset = 0
          pOn = PM.GetClosestPlanet(PM.WorldPosVec3())
          if pOn then
              offset = 2 * pOn.radius         onPlanet = PM.Altitude() < offset
              if onPlanet then
                  s2 = "Current"
              else
                  s2 = "Nearest"
              end
              s = s.."\n"..s2.." planet: "..pOn.name[1]
          else
              s = s.."\n[I] No planet nearby!"
          end

              local maxMass = 50000
              local tons = getCMass(CNID) / 1000 
              local pCargo, bCargo = 0, false
          if GetIndex(args, "-cargo") > 0 then
              local tmpCargo = GetParamValue(args, "-cargo", "n")
              tmpCargo = tmpCargo or 0
              if tmpCargo > 0 then
                  pCargo = uclamp(tmpCargo, 0, maxMass)
                  bCargo = pCargo > 0
              else
                  return E(s.."\n[E] Invalid -cargo value, must be in range of 1-50000 tons!")
              end
          end

          local pMass = GetParamValue(args, "-mass", "n")
          s2 = "Mass: "
          if pMass then
              tons = tonum(pMass)
          else
              s2 = "Construct "..s2
          end
          s = s.."\n"..s2..Out.PrettyMass(tons*1000)
          if bCargo then
              s = s.."  ~*~  Cargo: "..Out.PrettyMass(pCargo*1000)
          end
          if tons < 100 then         return E(s.."\n[E] Impossibly low mass for a warp ship! ;)")
          elseif tons > maxMass then
              return E(s.."\n[E] I don't accept you're warping that heavy! ;)")
          end

          local locFrom = checkParam(args, "-from", true)
          if not locFrom.isP and not locFrom.v then
              return E(s.."\n[E] Invalid starting location!")
          end
          local locTo = checkParam(args, "-to", false)
          if not locTo.isP and not locTo.v then
              return E(s.."\n[E] Invalid end location!")
          end

          if locFrom.isP and locTo.isP then
              return E(s.."\n[E] Only one 'planets' option supported!")
          end
          if (locFrom.parm == locTo.parm) or (locFrom.v == locTo.v) then
              return E(s.."\n[E] Start and end locations must be different!")
          end

          local function process(from, to, distance, massT, cargo)
              local out = ""
              if from > "" then out = out .. from end
              if from > "" and to > "" then out = out .. " to " end
              if to > "" then out = out .. to end
              out = out.. " ("..Out.PrettyDistance(distance)..")"

                      if distance < 200000 then
                  return out.." -> too short!"
              elseif distance > 100000000 then
                  return out.." -> too far!"
              end
              local cnt = PM.ComputeCells(distance, massT)
              out = out.." = "..cnt.." cell" .. SU.If(cnt > 1, "s")
              if bCargo then
                  local cnt2 = PM.ComputeCells(distance, massT - cargo)
                  out = out.." / "..cnt2.." cell" .. SU.If(cnt > 1, "s").." = "..(cnt+cnt2).." total"
              end
              return out
          end

              if not locFrom.isP and not locTo.isP then
              local distance = mabs(vec3(locFrom.v - locTo.v):len()) - locFrom.offset - locTo.offset
              local res = process(locFrom.parm, locTo.parm, distance, tons, pCargo)
              if type(res) == "string" then
                  s = s .. "\n" .. res
                  P(s)
                  ScreenOutput(s)
              else
                  E("[E] Sorry, something went wrong :(")
              end
              return
          end

              local v1, v2 = nil, nil
          s2 = " (Distance) / Cells"..SU.If(bCargo, " / Return w/o cargo")
          if locFrom.isP then
              s = s.."\nTo: "..locTo.parm.."\nFrom"..s2
          else
              s = s.."\nFrom: "..locFrom.parm.."\nTo"..s2
          end
          for _,v in pairs(WaypointInfo[0]) do
              if not v.isAsteroid and (pMoons or not v.isMoon) then
                  offset = 2 * v.radius
                  if locFrom.isP then
                      locFrom.parm = v.name[1]
                      locFrom.v = v.centerV3
                      offset = offset + locTo.offset
                  else
                      locTo.parm = v.name[1]
                      locTo.v = v.centerV3
                      offset = offset + locFrom.offset
                  end
                  local distance = mabs(vec3(locFrom.v - locTo.v):len()) - offset
                  if distance > 100000 then
                      s = s .. "\n" ..
                          process(SU.If(locFrom.isP, locFrom.parm),
                                  SU.If(locTo.isP, locTo.parm),
                                  distance, tons, pCargo)
                  end
              end
          end
          P(s)
          ScreenOutput(s)
      end

      end)

      package.preload['YFS-Tools:../util/wpoint.lua']=(function()

      local tonum, strlen, strmatch = tonumber, string.len, string.match


      Waypoint = { mapPos = {}, name = "", parent = nil }


      Waypoint.new = function(parent)
          local obj = setmetatable(
              { parent = parent, name = "",
                mapPos = { systemId = 0, id = 0, latitude = 0.0, longitude = 0.0, altitude = 0.0 } },
              { __index = Waypoint }
          )
          return obj
      end


      Waypoint.get = function(self)
          return self.mapPos
      end


      Waypoint.getPosPattern = function()
          local num = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'
          return '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' .. num ..  ',' .. num .. '}'
      end


      Waypoint.set = function(self, newMapPos)
          if type(newMapPos) == "string" and strlen(newMapPos) < 16 then
              print("[E] Invalid position: "..newMapPos)
              return {}
          end

          if type(newMapPos) == "string" then
              local s, p, x, y, z = strmatch(newMapPos, self.getPosPattern())
              if s then
                  self.mapPos.systemId = tonum(s)
                  self.mapPos.id = tonum(p)
                  self.mapPos.latitude = tonum(x)
                  self.mapPos.longitude = tonum(y)
                  self.mapPos.altitude = tonum(z)
              else
                  print(newMapPos.." - Invalid string format. Use '::pos{s, p, x, y, z}'.")
              end
          elseif type(newMapPos) == "table" and #newMapPos == 3 then
              self.mapPos.latitude = tonum(newMapPos[1])
              self.mapPos.longitude = tonum(newMapPos[2])
              self.mapPos.altitude = tonum(newMapPos[3])
          elseif type(newMapPos) == "table" and #newMapPos == 5 then
              self.mapPos.systemId = tonum(newMapPos[1])
              self.mapPos.id = tonum(newMapPos[2])
              self.mapPos.latitude = tonum(newMapPos[3])
              self.mapPos.longitude = tonum(newMapPos[4])
              self.mapPos.altitude = tonum(newMapPos[5])
          elseif type(newMapPos) == "table" and newMapPos.x and newMapPos.y and newMapPos.z then
              self.mapPos.systemId = 0
              self.mapPos.id = 0
              self.mapPos.latitude = tonum(newMapPos.x)
              self.mapPos.longitude = tonum(newMapPos.y)
              self.mapPos.altitude = tonum(newMapPos.z)
          else
              print("Invalid input. Provide a ::pos{} string, vec3() or {s,p,x,y,z} table.")
          end
          return self
      end


      Waypoint.setName = function(self, newName)
          if newName == nil then self.name = "" return end
          if type(newName) == "string" and newName:gmatch("^%a[%w_- ]*$") then
              self.name = newName
          else
              print(tostring(newName).."\n[E] WP: Invalid name format. Should only contain printable characters.")
          end
          return self
      end


      Waypoint.getName = function(self)
          return self.name
      end


      Waypoint.getAltitude = function(self)
          return self.mapPos.altitude
      end


      Waypoint.AsString = function(self)
          return string.format("::pos{%d, %d, %.4f, %.4f, %.4f}",
                               self.mapPos.systemId, self.mapPos.id,
                               self.mapPos.latitude, self.mapPos.longitude, self.mapPos.altitude)
      end


      Waypoint.__Waypoint = function(self) return true end

      end)

      package.preload['YFS-Tools:../util/wpointmgr.lua']=(function()

      local tonum, strlen, strmatch = tonumber, string.len, string.match



      WaypointMgr = { name = "", waypoints = {} }


      WaypointMgr.add = function(self, waypoint, index)
          if waypoint.__Waypoint and waypoint.__Waypoint() then
                      if waypoint.name and waypoint.name ~= "" then
                              for _,v in ipairs(self.waypoints) do
                      if v.name == waypoint.name then
                          return nil
                      end
                  end
              end
              local wplus1 = 1 + #self.waypoints
              if index then
                              if index < 1 or index > wplus1 then
                      print("[E] Invalid index. Must be in the range 1 to " .. wplus1)
                      return nil
                  end
                  waypoint.parent = self
                  table.insert(self.waypoints, index, waypoint)
              else
                  waypoint.parent = self
                  table.insert(self.waypoints, wplus1, waypoint)
              end
              return waypoint
          else
              print("[E] Invalid waypoint parameter!")
              return nil
          end
      end


      WaypointMgr.getWaypointsData = function(self)
          local res = {}
          for k,v in ipairs(self.waypoints) do
              table.insert(res, k, v:get())
          end
          return res
      end


      WaypointMgr.getWaypointsInst = function(self)
          return self.waypoints
      end


      WaypointMgr.getCount = function(self)
          return #self.waypoints
      end


      WaypointMgr.getSorted = function(self)
          local sortedPoints = {}

              for _,v in pairs(self.waypoints) do
              table.insert(sortedPoints, v)
          end

              table.sort(sortedPoints, function(a, b)
              return a.name < b.name
          end)
          return sortedPoints
      end


      WaypointMgr.moveUp = function(self, index)
          local waypointsCount = #self.waypoints

          if index and index > 1 and index <= waypointsCount then
              self.waypoints[index], self.waypoints[index - 1] = self.waypoints[index - 1], self.waypoints[index]
          end
      end


      WaypointMgr.moveDown = function(self, index)
          local waypointsCount = #self.waypoints

          if index and index >= 1 and index < waypointsCount then
              self.waypoints[index], self.waypoints[index + 1] = self.waypoints[index + 1], self.waypoints[index]
          end
      end


      WaypointMgr.removeByName = function(self, waypointName)
          for i, waypoint in ipairs(self.waypoints) do
              if waypoint.name == waypointName then
                  local removedWaypoint = table.remove(self.waypoints, i)
                  return removedWaypoint          end
          end
          return nil  end

      WaypointMgr.hasPoints = function(self, param)
          return #self.waypoints > 0
      end


      WaypointMgr.exists = function(self, param)
          for _, v in ipairs(self.waypoints) do
              if type(param) == "string" and v.name == param then
                  return v
              elseif param and param.__Waypoint and Waypoint.__Waypoint() then
                  if v == param then
                      return v
                  end
              elseif type(param) == "table" and #param == 5 then
                              if v.mapPos.systemId  == tonum(param[1]) and
                     v.mapPos.id        == tonum(param[2]) and
                     v.mapPos.latitude  == tonum(param[3]) and
                     v.mapPos.longitude == tonum(param[4]) and
                     v.mapPos.altitude  == tonum(param[5]) then
                      return v
                  end
              end
          end
          return nil
      end


      WaypointMgr.getName = function(self)
          return self.name
      end


      WaypointMgr.new = function(name)
          local obj = setmetatable(
              { waypoints = {}, name = name or "" },
              { __index = WaypointMgr }
          )
          return obj
      end


      return WaypointMgr

      end)

      package.preload['YFS-Tools:../util/stl.lua']=(function()

      local function mkPrint(str)

      return 'print(\'' .. str:gsub('\'', '\\\''):gsub('\n', '\\n') .. '\')'

      end


      local function tMerge(...)

      local tables = {...}

      local result = {}

      for _, t in pairs(tables) do
          for k, v in pairs(t) do
          result[k] = v
          end
      end

      return result

      end


      local function getLine(str, ln)

      local _ = 0

      for s in str:gmatch("([^\n]*)\n?") do
          _ = _ + 1
          if _ == ln then
          return s
          end
      end

      return nil

      end


      local function trim(str)

      return str:gsub("^%s*(.-)%s*$", "%1")

      end


      local Template = {

      globals = {
          math = math,
          table = table,
          string = string,
          ipairs = ipairs,
          pairs = pairs,
      }

      }


      function Template.__call(self, ...)

      return Template.render(self, ({...})[1])

      end


      function Template:render(vars)

      if type(vars or {}) ~= 'table' then
          error('Template parameters must be a table, got ' .. type(vars))
      end


      local _ = {}


      local env = tMerge(Template.globals, self.globals or {}, vars or {}, {
          print = function (str) table.insert(_, tostring(str or '')) end,
      })


      self.callable(env)


      local result = table.concat(_, ''):gsub('%s+', ' ')


      result = result:sub(result:find('[^%s]') or 1):gsub('%s*$', '')


      return result

      end


      function Template.new(source, globals, buildErrorHandler)

      local self = {
          source = source,
          globals = globals,
      }


      local yield = (coroutine and coroutine.isyieldable() and coroutine.yield) or function () end


      source = source:gsub('{{(.-)}}', '{%% print(%1) %%}')


      source = source:gsub('\n%s*{%%', '{%%')

      source = source:gsub('%%}\n', '%%}')


      local tPieces = {}


      while #source > 0 do
              local iLuaStart = source:find('{%%')

              local iLuaEnd = source:find('%%}')

              if iLuaStart then
              if not iLuaEnd then
              error('Template error, missing Lua closing tag near: ' .. source:sub(0, 16))
          end

              local currentText = source:sub(1, iLuaStart - 1)
          if #currentText then
              table.insert(tPieces, mkPrint(currentText))
          end

              local luaTagContent = source:sub(iLuaStart, iLuaEnd + 1):match('{%%(.-)%%}') or ''
          table.insert(tPieces, luaTagContent)

              source = source:sub(iLuaEnd + 2)
          else
              table.insert(tPieces, mkPrint(source))

              source = ''
          end

              yield()
      end


      self.code = table.concat(tPieces, '\n')


      local lua = string.format('return function (_) _ENV = _; _ = _ENV[_]\n%s\nend', self.code)

      local _, err = load(lua, nil, 't', {})

      if _ and not err then
          _ = _()
      end


      if err then
          local _, ln, msg = err:match('^(.-):(%d+):(.+)')
          local nearSrc = getLine(self.source, ln - 1)
          local nearLua = getLine(self.code, ln - 1)

          local ex = {
          raw = err,
          line = ln - 1,
          near = trim(nearSrc or 'N/A'),
          nearLua = trim(nearLua or 'N/A'),
          message = trim(msg),
          }

          if buildErrorHandler then
          buildErrorHandler(self, ex)
          else
          error(('Failed compiling template!\nError: %s\nLine: %d\nNear: %s\nCode: %s'):format(ex.message, ex.line, ex.near, ex.nearLua))
          end

              return nil
      else
              self.callable = _
      end


      return setmetatable(self, Template)

      end


      return Template.new

      end)

      package.preload['YFS-Tools:../util/wolfeCentralpoint.lua']=(function()

      local msqrt = math.sqrt


      function GetCentralPoint(waypoints, useCentroid)
          if type(waypoints) ~= "table" or #waypoints == 0 then return nil end
          if #waypoints == 1 then
                    return waypoints[1]
          elseif #waypoints == 2 then
                      return (vec3(waypoints[1]) + vec3(waypoints[2])) / 2
          end

              local base_weight = 1 / #waypoints

              local centroid = vec3(0, 0, 0)
          for _, waypoint in pairs(waypoints) do
              centroid = centroid + vec3(waypoint) * base_weight
          end

              local center = centroid

                  
              if not useCentroid then
                      local avg_distance = 0
              for _, waypoint in pairs(waypoints) do
                  avg_distance = avg_distance + base_weight * (vec3(waypoint) - center):len() ^ msqrt(2)
              end

                      local center_accumulator = vec3(0, 0, 0)
              for _, waypoint in pairs(waypoints) do
                  local point = vec3(waypoint)
                  local distance = (point - center):len() ^ msqrt(2)
                  local weight = distance / avg_distance
                  center_accumulator = center_accumulator + point * base_weight * weight
              end

                      center = center_accumulator
          end

          return center
      end

      end)

      package.preload['YFS-Tools:libmain.lua']=(function()

      SU = require('YFS-Tools:../util/SU.lua') Out = require('YFS-Tools:../util/out.lua') P = Out.PrintLines

      E = Out.Error


      require('YFS-Tools:../util/Dtbk.lua') 

      require('YFS-Tools:libutils.lua') Cmd = require('YFS-Tools:commands.lua') Help = require('YFS-Tools:help.lua') 

      require('YFS-Tools:warpcost.lua') 

      require('YFS-Tools:../util/wpoint.lua') WM = require('YFS-Tools:../util/wpointmgr.lua').new("MAIN") 

      WaypointInfo = require('atlas')


      STL = require('YFS-Tools:../util/stl.lua') require('YFS-Tools:../util/wolfeCentralpoint.lua') --     WolfeCenterPointRS = 'vec2 = vec2 or require(\'cpml.vec2\')\nvec3 = vec3 or require(\'cpml.vec3\')\n\n--------------------------------------\n-- Configuration\n--------------------------------------\n\n-- Pulls upstream config\nlocal config = data.config or {}\n\n-- How large each dot is\nlocal dot_size = 2\n\n-- How many meters from center to screen edge\nlocal screen_radius = config.screen_radius or 3000\n\n-- The grid circles\nlocal grid_size = config.grid_size or 500\n\n-- Colors to be used\nlocal colors = {\n  background = { 0.1, 0.1, 0.1 },\n  overlay = { 0, 0, 0, 0.5 },\n  guides = {\n    main = { 0, 0.5, 1.5, 0.2 },\n    secondary = { 0, 0.5, 1.5, 0.15 },\n  },\n  center = { 0, 2, 1 },\n  points = { 0, 2, 2 },\n  messages = { 0.6, 0.6, 0.6 },\n}\n\n-- Spacing\nlocal spacing = { 8, 8 }\n\n-- Font to be used\nlocal fonts = {\n  title = loadFont(\'Oxanium\', 30),\n  main = loadFont(\'Oxanium\', 24),\n  sub = loadFont(\'Oxanium\', 15),\n}\n\n--------------------------------------\n-- Helpers\n--------------------------------------\n\nlocal screen_width, screen_height = getResolution()\nlocal cursor = vec2(getCursor())\n\n-- How close to detect hover\nlocal proximity_distance = 0.02 * screen_height\n\n-- Helper function to convert color tables\nlocal function rgba(color)\n  return color[1], color[2], color[3], color[4] or 1\nend\n\n-- Draws a small dot\nlocal function draw_dot(layer, x, y, color, hover_handler, click_handler)\n  setNextFillColor(layer, rgba(color))\n  addCircle(layer, x, y, dot_size)\n\n  local is_hovering = (vec2(x, y) - cursor):len() <= proximity_distance\n\n  if hover_handler and is_hovering then\n    hover_handler()\n  end\n\n  if click_handler and is_hovering and getCursorReleased() then\n    click_handler()\n  end\nend\n\n-- Draws a circle\nlocal function draw_circle(layer, x, y, radius, color)\n  setNextStrokeWidth(layer, 1)\n  setNextStrokeColor(layer, rgba(color))\n  setNextFillColor(layer, rgba({ 0, 0, 0, 0 }))\n  addCircle(layer, x, y, radius)\nend\n\n-- Draws line\nlocal function draw_line(layer, x1, y1, x2, y2, color)\n  setNextStrokeColor(layer, rgba(color))\n  addLine(layer, x1, y1, x2, y2)\nend\n\n-- Draws an overlay\nlocal function draw_overlay(layer)\n  setNextFillColor(layer, rgba(colors.overlay))\n  addBox(layer, 0, 0, screen_width, screen_height)\nend\n\n-- Draws info box\nlocal function draw_info_box(layer, x, y, title, rows, color)\n  draw_line(layer, x, y, x + 150, y, color)\n\n  if title then\n    setNextFillColor(layer, rgba(color))\n    setNextTextAlign(layer, AlignH_Left, AlignV_Bottom)\n    addText(layer, fonts.sub, tostring(title), x + spacing[1], y - spacing[1])\n  end\n\n  local next_x = x + spacing[1]\n  local next_y = y + spacing[2]\n  for _, row in pairs(rows) do\n    local text = row\n    local font = fonts.main\n    if \'table\' == type(row) then\n      font = fonts[row[1]]\n      text = row[2]\n    end\n    local font_size = getFontSize(font)\n\n    setNextFillColor(layer, rgba(color))\n    setNextTextAlign(layer, AlignH_Left, AlignV_Top)\n    addText(layer, font, tostring(text), next_x, next_y)\n    next_y = next_y + font_size\n  end\nend\n\n-- Draws cursor\nlocal function draw_cursor(layer)\n  local cursor_size = 16\n  local x, y = cursor:unpack()\n\n  if x and y and x + y > 0 then\n    setNextShadow(layer, 0.25 * cursor_size, 0, 0, 0, 1)\n    setNextFillColor(layer, 1, 1, 1, 1)\n    addQuad(\n      layer,\n      x, y,\n      x + cursor_size, y + 0.5 * cursor_size,\n      x + 0.5 * cursor_size, y + 0.5 * cursor_size,\n      x + 0.5 * cursor_size, y + cursor_size\n    )\n  end\nend\n\n--------------------------------------\n-- Main render logic\n--------------------------------------\n\nsetBackgroundColor(rgba(colors.background))\n\n-- Pre-calculate center of screen\nlocal screen_center_x, screen_center_y = 0.5 * screen_width, 0.5 * screen_height\n\n-- Check if we have data\nif not data.is_activated then\n  -- Offline mode\n  local layer = createLayer()\n\n  setNextTextAlign(layer, AlignH_Center, AlignV_Bottom)\n  setNextFillColor(layer, rgba(colors.messages))\n  addText(layer, fonts.title, \'SCRIPT OFFLINE\', screen_center_x, screen_center_y - 0.5 * spacing[2])\n\n  setNextTextAlign(layer, AlignH_Center, AlignV_Top)\n  setNextFillColor(layer, rgba(colors.messages))\n  addText(layer, fonts.sub, \'activate programming board to start\', screen_center_x, screen_center_y + 0.5 * spacing[2])\nelseif not data.waypoints then\n  -- Waiting on input\n  local layer = createLayer()\n\n  setNextTextAlign(layer, AlignH_Center, AlignV_Bottom)\n  setNextFillColor(layer, rgba(colors.messages))\n  addText(layer, fonts.title, \'AWAITING INPUT\', screen_center_x, screen_center_y - 0.5 * spacing[2])\n\n  setNextTextAlign(layer, AlignH_Center, AlignV_Top)\n  setNextFillColor(layer, rgba(colors.messages))\n  addText(layer, fonts.sub, \'input your first coordinate in the Lua chat to start\', screen_center_x, screen_center_y + 0.5 * spacing[2])\nelse\n  -- Normal operation\n  local center_body, center_world = data.center.body, vec3(data.center.world)\n\n  -- Intializes render script\n  local layer_background, layer_data, layer_overlay, layer_info, layer_cursor = createLayer(), createLayer(), createLayer(), createLayer(), createLayer()\n\n  -- Cursor\n  draw_cursor(layer_cursor)\n\n  -- Half screen size\n  local screen_radius_pixels = screen_center_y\n\n  -- Renders guides\n  for radius = grid_size, screen_radius, grid_size do\n    local pixel_radius = screen_radius_pixels * radius / screen_radius\n    local color = colors.guides.secondary\n    if radius % 1000 == 0 then\n      color = colors.guides.main\n    end\n\n    draw_circle(layer_background, screen_center_x, screen_center_y, pixel_radius, color)\n\n    setNextFillColor(layer_background, rgba(color))\n    setNextTextAlign(layer_background, AlignH_Center, AlignV_Top)\n    addText(layer_background, fonts.sub, radius .. \'m\', screen_center_x, screen_center_y + pixel_radius + 0.5 * spacing[2])\n  end\n\n  -- Renders center dot\n  draw_dot(layer_data, screen_center_x, screen_center_y, colors.center, function()\n    draw_circle(layer_info, screen_center_x, screen_center_y, proximity_distance, colors.center)\n    draw_overlay(layer_overlay)\n    draw_info_box(layer_info, screen_center_x + proximity_distance, screen_center_y, nil, {\n      \'center point\',\n      { \'sub\', \'click to set waypoint\' },\n    }, colors.center)\n  end, function()\n    -- Sets waypoint on click\n    setOutput((\'{%s,%s,%s}\'):format(center_world:unpack()))\n  end)\n\n  -- Renders waypoints\n  for _, waypoint in pairs(data.waypoints or {}) do\n    local lat, lng = waypoint.body.lat - center_body.lat, waypoint.body.lng - center_body.lng\n\n    local offset = vec2(lng, lat * -1)\n    local distance = (vec3(waypoint.world) - center_world):len()\n\n    -- Don\'t render anything outside screen\n    if distance <= screen_radius then\n      -- Calculates pixel position\n      local pixel = vec2(0.5 * screen_width, 0.5 * screen_height) + offset:normalize() * screen_radius_pixels * distance / screen_radius\n\n      -- Draws point on "map"\n      draw_dot(layer_data, pixel.x, pixel.y, colors.points, function()\n        -- Draws extra info on hover\n        draw_circle(layer_info, pixel.x, pixel.y, proximity_distance, colors.points)\n        draw_overlay(layer_overlay)\n        draw_info_box(layer_info, pixel.x + proximity_distance, pixel.y, waypoint.label, {\n          (\'%.2fm\'):format(distance),\n          { \'sub\', \'click to set waypoint\' },\n        }, colors.points)\n      end, function()\n        -- Sets waypoint on click\n        setOutput((\'{%s,%s,%s}\'):format(vec3(waypoint.world):unpack()))\n      end)\n    end\n  end\n\n  requestAnimationFrame(1)\nend'


      WolfAR = nil

      end)

      package.preload['YFS-Tools:../util/pos.lua']=(function()

      local max, min, mcos, macos, mdeg, msin, mabs, mrad, matan, ceil, floor, mpi = math.max, math.min, math.cos, math.acos, math.deg, math.sin, math.abs, math.rad, math.atan, math.ceil, math.floor, math.pi

      local tonum, strlen, strmatch, sformat = tonumber, string.len, string.match, string.format

      local uclamp, vec3 = utils.clamp, vec3


      local o = {}

      o.__index = o

      function o.New(pCore, pConstruct, pWM)
              local s = {
              core = pCore,
              construct = pConstruct,
              Alioth1G = 9.891,
              waypointNames = {},
              waypointCount = 0,
              planetNames = {},
              p = {},         pIdx = 0,         wm = pWM     }

          local function float_eq(a, b)         if a == 0 then
                  return mabs(b) < 1e-09
              elseif b == 0 then
                  return mabs(a) < 1e-09
              else
                  return mabs(a - b) < math.max(mabs(a), mabs(b)) * epsilon
              end
          end

              local function constructPresent()
              return s.construct ~= nil
          end

              local function corePresent()
              return s.core ~= nil
          end

          
              function o.ComputeCells(distance, tons)
              return ceil(max(floor(tons*floor(((distance/1000)/200))*0.00024), 1))
          end

              function o.GetPosPattern()
              local num = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'
              return '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' .. num ..  ',' .. num .. '}'
          end

              function o.GetWaypointCount()
              return s.wm:getCount()
          end

                  function o.SplitPos(posStr)
                      if type(posStr) ~= "string" then
                  P("[E] Invalid position: "..type(posStr))
                  return nil
              end
              if strlen(posStr) < 16 or not strmatch(posStr, "^::pos{") then
                  P("[E] Invalid position: "..posStr)
                  return nil
              end
              local sysId, pId, lat, lng, alt = strmatch(posStr, o.GetPosPattern())
              return { systemId  = tonum(sysId),
                       id        = tonum(pId),
                       latitude  = tonum(lat),
                       longitude = tonum(lng),
                       altitude  = tonum(alt) }
          end

                  function o.GetAltitudeFromPos(posString)
              local p = o.SplitPos(posStr)
              if p and p.altitude then return p.altitude end
              return 0
          end

                  function o.GetPlanetFromPos(posStr)
              local p = o.SplitPos(posStr)
              if p and p.id and p.id > 0 then return p.id end
              return 0
          end

          function o.GetAtlasPlanet(pid)
              if not pid or not WaypointInfo[0] or not WaypointInfo[0][tonum(pid)] then
                  return nil
              end
              return WaypointInfo[0][tonum(pid)]
          end

          function o.GetClosestPlanetId(worldPosVec)
              local pIdx, dist = 0, 0
              local planetDistance = math.huge
              for i,v in pairs(WaypointInfo[0]) do
                  dist = (worldPosVec - vec3(v.center)):len()
                  if dist < planetDistance then
                      planetDistance = dist
                      pIdx = i
                  end
              end
              return pIdx
          end

          function o.GetClosestPlanet(worldPosVec)
              local pid = o.GetClosestPlanetId(worldPosVec)
              return o.GetAtlasPlanet(pid)
          end

          function o.GetCurrentPosString()
              local v = o.WorldPosVec3()
              return o.MapPos2String(o.WorldToMapPos(v))
          end

                  function o.MapPos2String(mapPos)
              if type(mapPos) ~= "table" then return "" end
              return '::pos{' .. (mapPos.systemId or 0).. ',' .. (mapPos.id or 0) .. ',' ..
                     sformat("%.4f", (mapPos.latitude or 0)) .. ',' ..
                     sformat("%.4f", (mapPos.longitude or 0)) ..  ',' ..
                     sformat("%.4f", (mapPos.altitude or 0)) .. '}'
          end

                  function o.Vec3ToPosString(v3)
              if type(v3) ~= "table" then return "" end
              return '::pos{0,0,' ..
                     sformat("%.4f", (v3.x or 0)) .. ',' ..
                     sformat("%.4f", (v3.y or 0)) ..  ',' ..
                     sformat("%.4f", (v3.z or 0)) .. '}'
          end

                  function o.Vec3String(v3)
              if type(v3) ~= "table" then return "" end
              v3 = vec3(v3)
              return sformat("%.4f", (v3.x or 0)) .. ', ' ..
                     sformat("%.4f", (v3.y or 0)) .. ', ' ..
                     sformat("%.4f", (v3.z or 0))
          end

                      function o.ReplaceAltitudeInPos(posStr, newAltitude)
                      local p = o.SplitPos(posStr)
              if not p or not p.altitude or not newAltitude then
                  return posStr
              end
              p.altitude = tonum(newAltitude)
              return o.MapPos2String(p)
          end

                  function o.PlanetId()
              if not corePresent() then return 0 end
              if not INGAME then
                  return 2         end
              return s.core.getCurrentPlanetId()
          end

                  function o.WorldPosVec3()
              if not INGAME then
                  return { x = -25140.37011013, y = 100812.26194182, z = -52412.710373821}
              end
              if constructPresent() then
                              return vec3(construct.getWorldPosition())
              end
              if corePresent() then
                              return vec3(core.getWorldPosition())
              end
              return nil
          end

                  function o.Altitude()
              local p = o.GetAtlasPlanet(o.PlanetId())
              if not p or not p.center then return 0 end
              return (o.WorldPosVec3() - vec3(p.center)):len() - (p.radius or 0)
          end

                                          function o.GetDistance(posStr, distToStr)
              local curPos = o.WorldPosVec3()
              if type(distToStr) == "string" then
                  curPos = o.MapPosToWorldVec3(distToStr)
              elseif type(distToStr) == "table" then
                  curPos = vec3(distToStr)
              end
              local wPos = o.MapPosToWorldVec3(posStr)
              local dist = vec3(wPos - curPos):len()
              return dist
          end

                  function o.World2local(x,y,z)
                      local cWOUP = s.construct.getWorldOrientationUp()
              local cWOF = s.construct.getWorldOrientationForward()
              local cWOR = s.construct.getWorldOrientationRight()
              local cWOUPx, cWOUPy, cWOUPz = cWOUP[1], cWOUP[2], cWOUP[3]
              local cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]
              local cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]

              local v = library.systemResolution3(
                  {cWORx,  cWORy, cWORz},
                  {cWOFx,  cWOFy, cWOFz},
                  {cWOUPx, cWOUPy, cWOUPz},
                  {x, y, z})
              return v[1],v[2],v[3]
          end

                                      function o.WorldPosFromBody(celestial_body, latitude, longitude, altitude)
              if type(celestial_body) ~= "table" then return nil end
              local radius = altitude + (celestial_body.radius or 0)
              local phi, theta = mrad(latitude), mrad(longitude)
              local pcos = mcos(phi)
              local offset = vec3(pcos * mcos(theta), pcos * msin(theta), msin(phi))
                      return vec3(celestial_body.center) + offset * radius
          end

                          function o.BodyPosFromWorldPos(body, position)
                      local offset = position - vec3(body.center)
              local offset_normalized = offset:normalize()

              return {
                  systemId  = body.systemId,
                  id        = body.id,
                  latitude  = 90 - (macos(offset_normalized.z) * 180 / mpi),
                  longitude = matan(offset_normalized.y, offset_normalized.x) / mpi * 180,
                  altitude  = offset:len() - body.radius
              }
          end

                  function o.WorldToMapPos(v)
              local body = o.GetClosestPlanet(v)
              if not body or not body.center or not body.radius then
                  return { systemId = 0, id = 0, latitude = v.x, longitude = v.y, altitude = v.z }
              end
              return o.BodyPosFromWorldPos(body, v)
          end

          function o.PlanetByName(name)
              if type(name) ~= "string" or name == "" then return nil end
              name = name:lower()
              if s.planetNames[name] then
                  local pid = tonum(s.planetNames[name])
                  return WaypointInfo[0][pid]
              end
              return nil
          end

                      function o.MapPosToWorldVec3(posStr)
              local p = o.SplitPos(posStr)
              if not p or not p.systemId then return nil end
              if (p.systemId == 0 and p.id == 0) then             return vec3(p.latitude, p.longitude, p.altitude)
              end
              if not WaypointInfo[p.systemId] then return nil end
              local planet = WaypointInfo[p.systemId][p.id]
                              local lat = 0.0174532925199 * max(min(p.latitude, 90), -90)
              local lon = 0.0174532925199 * (p.longitude % 360)
              local xproj = mcos(lat)
              local planetxyz = vec3(xproj*mcos(lon), xproj*msin(lon), msin(lat))
              return vec3(planet.center) + (planet.radius + p.altitude) * planetxyz
          end

          function o.PlanetInfo(id)
              local pid = nil
              if type(id) == "string" and id:len() == 0 then
                  id = o.GetClosestPlanetId(o.WorldPosVec3())
              end
              if type(id) == "string" and s.planetNames[id:lower()] then             pid = tonum(s.planetNames[id:lower()])
              elseif type(id) == "string" and tonum(id) > 0 then             pid = tonum(id)
              end
              if pid == nil then
                  return E("[E] No valid planet name or id specified!")
              end
              local p = o.GetAtlasPlanet(pid)
              if not p or type(p.name) ~= "table" then
                  return E("[E] No planet found!")
              end
              P"~~~~~~~~ PLANET INFO ~~~~~~~~"
              if id == '' then
                P("Hint: '/planetInfo 2' for Alioth")
              end
              P("Name: "..p.name[1].." (Id: ".. p.id ..")")
              P("Center: "..p.center[1].." / "..p.center[2].." / "..p.center[3])
              P("Radius: "..(p.radius or 0).."m")
              local tmp = ""
              if p.gravity and p.gravity > 0 then
                  tmp = " ("..sformat("%.1f", (p.gravity / s.Alioth1G)) .." g)"
              end
              P("Gravity: "..(p.gravity or 0)..tmp)
              if p.satellites and #p.satellites > 0 then
                P("Has Moons: "..#p.satellites)
              end
              P("Surface Min Alt.: "..(p.surfaceMinAltitude or 0).."m")
              P("Surface Max Alt.: "..(p.surfaceMaxAltitude or 0).."m")
              P("Max Static Alt.: "..(p.maxStaticAltitude or "").."m")
              P("Has atmosphere: "..BoolStr(p.hasAtmosphere))
              if p.hasAtmosphere then
                P("Atmo Thickness: "..(p.atmosphereThickness or 0).."m")
                P("Atmo altitude: "..(p.atmoAltitude or 0).."m")
                P("Atmo 10%: "..(p.atmo10 or 0).."m")
              end
              P("Is in Safe Zone: "..BoolStr(p.isInSafeZone))
              P"~~~~~~~~~~~~~~~~~~~~~~~~~~~"
          end

                                      function o.CreateWaypoint(posString, wpName)
              if not s.wm or not wpName or wpName == '' or s.waypointNames[wpName] then
                  return false
              end

                      local p = o.SplitPos(posString)
              if not p or not p.systemId then return false end

                      if p.id == 0 then
                  local w = o.WorldToMapPos(vec3{ p.latitude, p.longitude, p.altitude })
                  if w and w.id and w.id > 0 then
                                      p.latitude  = w.latitude
                      p.longitude = w.longitude
                      p.altitude  = w.altitude
                      p.id        = w.id
                      p.systemId  = w.systemId
                      posString = o.MapPos2String(p)
                  end
              end

                      local wp = Waypoint:new(s.wm):setName(wpName):set(posString)
              if not wp or wp == {} then return false end
              if s.wm:exists(wp) then return false end
              return s.wm:add(wp)
          end

              function o.ConversionTest()
              local p1 = "::pos{0,2,35.5118,104.0375,285.3076}"
              local w1 = o.MapPosToWorldVec3(p1)
              P("HQ local to world:\n"..p1.." =")
              P(o.Vec3ToPosString(w1))
              local w2 = o.WorldToMapPos(w1)
              Out.DeepPrint(w2)
              P("World to local (should show same as above):")
              P(o.MapPos2String(w2))

              local wp = "::pos{0,0,-24955.2183,99771.5731,-52908.1353}"
              if o.CreateWaypoint(wp, "WorldPos") then
                P("Added 'WorldPos' waypoint")
              else
                P("Failed to add test waypoint!")
              end
          end

          local function init()
              s.pIdx = 0
              s.p = o.GetAtlasPlanet(o.PlanetId())
              if s.p then s.pIdx = s.p.id end
              if not WaypointInfo[0] then return end
              s.planetNames = {}
              for i, v in pairs(WaypointInfo[0]) do
                  s.planetNames[v.name[1]:lower()] = i
                              WaypointInfo[0][i].biosphere = nil
                  WaypointInfo[0][i].classification = nil
                  WaypointInfo[0][i].description = nil
                  WaypointInfo[0][i].habitability = nil
                  WaypointInfo[0][i].ores = nil
                              WaypointInfo[0][i].centerV3 = vec3(WaypointInfo[0][i].center)
                  if v.hasAtmosphere then
                      local res = v.atmosphereRadius - v.radius
                      WaypointInfo[0][i].atmoAltitude = res
                      WaypointInfo[0][i].atmo10 = res * 0.9
                  end
                  WaypointInfo[0][i].isAsteroid = WaypointInfo[0][i].type[1] == "Asteroid"
                  WaypointInfo[0][i].isMoon = WaypointInfo[0][i].type[1] == "Moon"
                  WaypointInfo[0][i].isPlanet = WaypointInfo[0][i].type[1] == "Planet"
              end

              if s.wm then
                  P("[I] WaypointMgr assigned: "..s.wm:getName())
              else
                  P("[E] NO WaypointMgr assigned!")
              end
          end

          init()
          return setmetatable(s, o)
      end 

      return o

      end)

      package.preload['YFS-Tools:startup.lua']=(function()

      local uclamp = utils.clamp


      local onlyForRoute=""--export: Load waypoints only for this route (enclosed in double quotes!); default "".

      local onlySelectableWP=true--export: Check to only display custom route waypoints that are marked as selectable

      local loadWaypoints=true--export: Enable to load custom waypoints from databank

      local outputFont="FiraMono"--export: Name of font used for screen output. Default: "FiraMono"


      onlyForRoute = onlyForRoute or ""

      OutputFont = outputFont or "FiraMono" 


      P("=========================================")

      P("YFS-Tools 1.7.7 (unofficial)")

      P("created by tobitege (c) 2023")

      P("Thanks to Yoarii (SVEA) for YFS and LUA help!")

      P("YFS 1.4+ databank link required (Routes).")

      P("=========================================")

      P("* WARNING: do not run commands that change")

      P("* waypoints/routes while YFS is running!")

      P("=========================================")

      P("LUA parameter(s):")

      P("Load waypoints from databank: " .. BoolStr(loadWaypoints))

      P("Only waypoints for route: " .. onlyForRoute)

      P("Only selectable waypoints: " .. BoolStr(onlySelectableWP))

      P("Screen output font name: " .. OutputFont)

      P("=========================================")


      local status, err = false, nil

      if INGAME then
          status, err, _ = xpcall(function()
              Config.core = library.getCoreUnit()
              Config.databanks = library.getLinksByClass('DataBank', true)         Config.screens = library.getLinksByClass('Screen', true)
          end, Traceback)
          if not status then
              P("Error in Link Detection:\n" .. err)
              unit.exit()
              return
          end
      else
              Config.core = unit.core
          Config.databanks =  { unit.databank }
          Config.screens =  { unit.screen }
      end


      if Config.core == nil then
          P("[E] No Core connected! Ending script.")
          unit.exit()
          return
      end


      PM = require('YFS-Tools:../util/pos.lua').New(Config.core, construct, WM) 

      if #Config.databanks > 0 then
          local plural = ""
          if #Config.databanks > 1 then plural = "s" else plural = " '"..Config.databanks[1].getName().."'" end
          P(#Config.databanks .. " databank" .. plural .. " connected.")
      else
          P("[E] DataBank not found.")
      end


      if #Config.screens > 0 then
          local plural = ""
          if #Config.screens > 1 then plural = "s" end
          P(#Config.screens .. " screen" .. plural .. " connected.")
      end


      if loadWaypoints ~= true or #Config.databanks == 0 then
          P("[I] Waypoints loading is off.")
          return
      end


      if not INGAME then
          onlyForRoute = "Garni"
      end


      local prevCount = 0

      for ix=1, #Config.databanks, 1 do
              local db = Config.databanks[ix]     P("===== Checking db '"..db.getName().."' =====")
          if db.hasKey(ARCH_SAVED_LOCATIONS) then
              P('ArchHud databank detected.')
              DetectedArch = ix
              local names = db.getStringValue(ARCH_SAVED_LOCATIONS)
              if names ~= "" then
                  P('Searching stored locations...')
                  local locations = json.decode(names)
                  if IsTable(locations) then
                      Cmd.GetStoredLocations(locations)
                  end
              end
          end
          if db.hasKey(YFS_ROUTES) or db.hasKey(YFS_NAMED_POINTS) then
              P('YFS databank detected.')
              YFSDB = Dtbk.new(db)
              DetectedYFS = true
              if not onlySelectableWP then
                  Cmd.YFSLoadNamedWaypoints()
              end
              Cmd.YFSLoadRoutepoints(onlySelectableWP, onlyForRoute)
          end
          local count = PM.GetWaypointCount()
          if count == prevCount then
              P("[I] No waypoints loaded from db "..ix)
          else
              P("[I] "..(count - prevCount).." waypoints loaded from db "..ix)
          end
          prevCount = PM.GetWaypointCount()
      end

      P("=======================")

      if PM.GetWaypointCount() > 0 then
          P("[I] Total "..PM.GetWaypointCount().." waypoints loaded.")
      else
          P("[I] No waypoints loaded.")
      end

      P("=======================")

      end)

      package.preload['YFS-Tools:sys_onInputText.lua']=(function()

      local inputTextFunc = {}


      function inputTextFunc.Run(t)
          t = SU.Trim(t)
          if not SU.StartsWith(t, "/") then return end
          if not Cmd then
              return E("[FATAL ERROR] Commands processor not assigned!")
          end
          local cmdList = {}
          cmdList['arch-save-named'] = 1
          cmdList['conversionTest'] = 1
          cmdList['findCenter'] = 1
          cmdList['posData'] = 1
          cmdList['help'] = 'Help'
          cmdList['planetInfo'] = 1
          cmdList['printAltitude'] = 1
          cmdList['printPos'] = 1
          cmdList['printWorldPos'] = 1
          cmdList['warpCost'] = 1
          cmdList['wp-altitude-ceiling'] = 1
          cmdList['wp-export'] = 1
          cmdList['yfs-add-altitude-wp'] = 1
          cmdList['yfs-build-route-from-wp'] = 1
          cmdList['yfs-save-named'] = 1
          cmdList['yfs-save-route'] = 1
          cmdList['yfs-replace-wp'] = 1
          cmdList['yfs-route-altitude'] = 1
          cmdList['yfs-route-nearest'] = 1
          cmdList['yfs-options-reset'] = 1
          cmdList['yfs-route-to-named'] = 1
          cmdList['yfs-wp-altitude'] = 1
          cmdList['DumpRoutes'] = 1
          cmdList['DumpPoints'] = 1
          cmdList['routes'] = 1
          if DEBUG then
              cmdList['YfsTestData'] = 1
              cmdList['x'] = 1
          end

          for k, func in pairs(cmdList) do
              if SU.StartsWith(t, "/"..k) then
                  local params = t:sub(k:len()+2) or ""
                  params = SU.Trim(params)
                  if k == 'help' then                 k = "PrintHelp"
                  end
                              local fn = SU.SplitAndCapitalize(k,'-').."Cmd"
                              local cmdName = SU.If(type(func) == "string", func, "Cmd")
                  P("Executing /"..k..SU.If(params ~= "", " with: "..params))
                  if not _G[cmdName] then
                      return E("[FATAL ERROR] "..cmdName.." not found!")
                  end
                  if _G[cmdName][fn] then
                      return _G[cmdName][fn](params)
                  end
              end
          end
          P("~~~~~~~~~~~~~~~~~~~~~")
          P("[E] Unknown command: "..t)
          P("[I] Supported commands:")
          for _,fn in ipairs(GetSortedAssocKeys(cmdList)) do
             P("/"..fn)
          end
      end


      return inputTextFunc

      end)

      package.preload['YFS-Tools:../util/wolfeARlib.lua']=(function()

      local uclamp = utils.clamp


      local wolfie = {
          core = nil,
          destList = {},
          destCount = 0,
          renderLimitKm = 5
      }

      local fontSize = 1.2 local font = 'Oxanium' -- 'Refrigerator'

      local colorBlue = { 130, 224, 255 } local colorLime = { 50, 205, 50 }   local colorOrange = { 256, 128, 0 } 

      local infinityDistance = 100 * 200000

      local referenceGravity1g = nil


      local function getHudColor(distance)
          if distance and distance > 2250 then
              return colorOrange
          end
          return colorLime
      end


      local function getHudColorRgb(alpha, distance)
          local color = getHudColor(distance)
          color[4] = alpha or 1
          return ('rgba(%s, %s, %s, %s)'):format(color[1], color[2], color[3], color[4])
      end


      local function convertLocalToWorldCoordinates(coordinate)
          return vec3(construct.getWorldPosition())
              + coordinate.x * vec3(construct.getWorldOrientationRight())
              + coordinate.y * vec3(construct.getWorldOrientationForward())
              + coordinate.z * vec3(construct.getWorldOrientationUp())
      end


      local function getCurrentPointedAt()
          return convertLocalToWorldCoordinates(vec3(0, infinityDistance, 0))
      end


      local function getDistanceAsString(distance)
          if distance > 100000 then
              return ('%.2f su'):format(distance / 200000)
          elseif distance > 1000 then
              return ('%.2f km'):format(distance / 1000)
          elseif distance > 10 then
              return ('%.1f m'):format(distance)
          end
          return ('%.2f m'):format(distance)
      end


      local function getDistanceToPoint(point)
          return (vec3(construct.getWorldPosition()) - point):len()
      end


      local function getARPointFromCoordinate(coordinate)
          local result = vec3(library.getPointOnScreen({ coordinate:unpack() }))
          if result:len() == 0 then
              return nil
          end
          return result
      end


      local function getRoundedValue(value, precision)
          return ('%.' .. (precision or 0) .. 'f'):format(value)
      end


      local function getGravitationalForceAtAltitude(altitude, celestialBody)
          return celestialBody.GM / (celestialBody.radius + altitude) ^ 2
      end


      local function getGravitationalForceAtAltitudeInGs(altitude, celestialBody)
          return getGravitationalForceAtAltitude(altitude, celestialBody) / referenceGravity1g
      end


      local function getAltitudeAtGravitationalForce(intensity, celestialBody)
          return math.sqrt(celestialBody.GM / intensity) - celestialBody.radius
      end


      local function getClosestCelestialBody(position, allowInfiniteRange)
          local closestBody = nil
          local closestBodyDistance = nil
          for _, celestialBody in pairs(WaypointInfo[0]) do
              local celestialBodyPosition = vec3(celestialBody.center)
              local celestialBodyDistance = (position - celestialBodyPosition):len()
              local celestialBodyAltitude = celestialBodyDistance - (celestialBody.radius or 0)
              if (not closestBodyDistance or closestBodyDistance > celestialBodyAltitude) and (allowInfiniteRange or celestialBodyDistance <= 400000) then
                  closestBody = celestialBody
                  closestBodyDistance = celestialBodyAltitude
              end
          end
          return closestBody, closestBodyDistance
      end


      local function getCelestialBodyPosition(position, celestialBody)
          return position - vec3(celestialBody.center.x, celestialBody.center.y, celestialBody.center.z)
      end


      local function getLatLonAltFromWorldPosition(position, celestialBody)
              local offset = getCelestialBodyPosition(position, celestialBody)
          local offsetNormalized = offset:normalize()
          return {
              lat = 90 - (math.acos(offsetNormalized.z) * 180 / math.pi),
              lon = math.atan(offsetNormalized.y, offsetNormalized.x) / math.pi * 180,
              alt = offset:len() - celestialBody.radius,
          }
      end


      local function getDistanceAroundCelestialBody(point, celestialBody)
          local currentCoordinates = getLatLonAltFromWorldPosition(vec3(construct.getWorldPosition()), celestialBody)
          local targetCoordinates = getLatLonAltFromWorldPosition(point, celestialBody)
          local flyingAltitude = math.max(currentCoordinates.alt, celestialBody.maxStaticAltitude or 1000)

              local function rad(deg)
              return deg * math.pi / 180
          end

              local phi2 = rad(targetCoordinates.lat)
          local deltaPhi, deltaLambda = rad(currentCoordinates.lat - targetCoordinates.lat), rad(currentCoordinates.lon - targetCoordinates.lon)

          local a = math.sin(deltaPhi / 2) ^ 2 + math.cos(phi2) * math.cos(phi2) * math.sin(deltaLambda / 2) ^ 2
          local c = 2 * math.atan(math.sqrt(a), math.sqrt(1 - a))

          return (celestialBody.radius + flyingAltitude) * c
      end


      function wolfie.render(destList)
          local UI = {}
          local Shapes = {}

              Shapes.Hexagon = STL([[
          <svg style="width: {{ size or 1 }}em; height: {{ size or 1 }}em;" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M24.25 1.56699L24 1.42265L23.75 1.56699L4.69745 12.567L4.44745 12.7113V13V35V35.2887L4.69745 35.433L23.75 46.433L24 46.5774L24.25 46.433L43.3026 35.433L43.5526 35.2887V35V13V12.7113L43.3026 12.567L24.25 1.56699ZM9.44745 32.4019V15.5981L24 7.19615L38.5526 15.5981V32.4019L24 40.8038L9.44745 32.4019Z" fill="{{ color }}" stroke="{{ stroke }}"/>
          </svg>
          ]])

              Shapes.Crosshair = STL([[
          <svg style="width: {{ size or 1 }}em; height: {{ size or 1 }}em;" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M23.6465 37.8683L24.0001 38.2218L24.3536 37.8683L26.3536 35.8684L26.5 35.7219V35.5148V26.5H35.5148H35.7219L35.8684 26.3536L37.8684 24.3536L38.2219 24L37.8684 23.6465L35.8684 21.6465L35.7219 21.5H35.5148H26.5V12.4852V12.2781L26.3536 12.1317L24.3536 10.1317L24.0001 9.77818L23.6465 10.1317L21.6465 12.1318L21.5 12.2782V12.4854V21.5H12.4854H12.2782L12.1318 21.6465L10.1318 23.6465L9.77824 24L10.1318 24.3536L12.1318 26.3536L12.2782 26.5H12.4854H21.5V35.5147V35.7218L21.6465 35.8682L23.6465 37.8683Z" fill="{{ color }}" stroke="{{ stroke }}"/>
          </svg>
          ]])

          local renderGlobals = {
              Colors = {
                  Shadow = 'rgba(0, 0, 0, 0.75)',
                  ShadowLight = 'rgba(0, 0, 0, 0.375)',
              },
              DistanceAroundCelestialBody = getDistanceAroundCelestialBody,
              DistanceTo = getDistanceToPoint,
              Exists = function(value) return 'nil' ~= type(value) end,
              GetHudColor = getHudColorRgb,
              GravityAt = getGravitationalForceAtAltitude,
              GravityAtInGs = getGravitationalForceAtAltitudeInGs,
              Metric = getDistanceAsString,
              Percentage = function(value, precision) return getRoundedValue(100 * (value or 1), precision) .. '%' end,
              Round = getRoundedValue,
              WorldCoordinate = getARPointFromCoordinate,
              UI = UI,
              Shapes = Shapes,
              renderLimit = wolfie.renderLimitKm
          }

                  renderGlobals.Label = STL([[<span style="font-size: {{ size or ']]..fontSize..[[' }}em; font-family: {{ font or ']]..font..[[' }};
              font-weight: {{ weight or 'normal' }}; color: {{ color or GetHudColor() }};
              text-shadow: 2px 2px 0.125em {{ stroke or Colors.Shadow }}, -2px -2px 0.50em #000, 2px -2px 0.50em #000;">
          {{ text }}
          </span>
          ]], renderGlobals)

              UI.PositionCenteredAt = STL('position: absolute; top: {{ Percentage(y, 5) }}; left: {{ Percentage(x, 5) }}; margin-top: -{{ (height or 1) / 2 }}em; margin-left: -{{ (width or 1) / 2 }}em;'
          , renderGlobals)

              UI.DestinationMarker = STL([[
          {%
          local screen = WorldCoordinate(position)
          local distance = DistanceTo(position)

                  if Exists(currentCelestialBody) and Exists(destinationCelestialBody) and currentCelestialBody.info.id == destinationCelestialBody.info.id then
              distance = math.max(distance, DistanceAroundCelestialBody(position, destinationCelestialBody.info))
          end
          local distKm = distance / 1000
          local showWP = screen and ((renderLimit < 0.01) or (renderLimit > distKm))
          %}
          {% if showWP then %}
              {% if distance and title and distance < 10 then %}
              <div style="font-size: 1em; position: absolute; top: 50%; left: 0.25em; white-space: nowrap; padding: 0px 0.5em;">
                  {{ Label({ text = title, size = 1.5 }) }}
              </div>
              {% end %}
              <div style="{{ UI.PositionCenteredAt({ x = screen.x, y = screen.y, width = 2, height = 2 }) }}">
              <div style="postion: relative;">
                  {{ Shapes.Hexagon({ color = GetHudColor(1, distance), stroke = Colors.Shadow, size = 2 }) }}
                  {% if title or distance then %}
                  <div style="font-size: 0.8em; position: absolute; top: 1em; left: 2.5em; white-space: nowrap; padding: 0px 0.5em;">
                  <hr style="border: 0px none; height: 2px; background: {{ GetHudColor(1, distance) }}; width: 5em; margin: 0px -0.5em 0.5em; padding: 0px;" />
                  {% if title then %}
                  <div>{{ Label({ text = title, size = 1, weight = 'bold' }) }}</div>
                  {% end %}
                  {% if distance then %}
                  <div>{{ Label({ text = Metric(distance), size = 1 }) }}</div>
                  {% end %}
                  </div>
                  {% end %}
                  </div>
              </div>
          {% end %}
          ]], renderGlobals)

              UI.Crosshair = STL([[
          <div style="{{ UI.PositionCenteredAt({ x = x, y = y, width = 1.5, height = 1.5 }) }}">
              {{ Shapes.Crosshair({ color = GetHudColor(), stroke = Colors.Shadow, size = 1.5 }) }}
          </div>
          ]], renderGlobals)

          renderGlobals.currentPointingAt = getCurrentPointedAt() 
              local rAR = [[<div class="wlhud-ar-elements">
          {%
          if currentPointingAt then
              currentPointingAtOnScreen = WorldCoordinate(currentPointingAt)
          end
          %}
          {% if Exists(currentPointingAtOnScreen) then %}
              {{ UI.Crosshair(currentPointingAtOnScreen) }}
          {% end %}
          ]]

          local currentCelestialBodyInfo, currentCelestialBodyCoordinates = nil, nil
          local currentPosition = vec3(construct.getWorldPosition())
          local currentCelestialBody = getClosestCelestialBody(currentPosition,false)
          if currentCelestialBody then
              currentCelestialBodyCoordinates = getLatLonAltFromWorldPosition(currentPosition, currentCelestialBody)
              if currentCelestialBodyCoordinates then
                  currentCelestialBodyInfo = { info = currentCelestialBody, coordinates = currentCelestialBodyCoordinates }
              end
          end
          if type(destList) == "table" then
              for _,dest in pairs(destList) do
                              local isDestinationOnSameCelestialBody = false
                  if currentCelestialBody and dest.bodyInfo and currentCelestialBody.id == dest.bodyInfo.info.id then
                      isDestinationOnSameCelestialBody = true
                  end

                  local marker = STL([[ {{ UI.DestinationMarker({ title = currentDestination.name, position = currentDestination.position }) }} ]],
                  {
                      currentDestination = dest,
                      currentCelestialBody = currentCelestialBodyInfo,
                      destinationCelestialBody = dest.bodyInfo,
                      destinationOnSameCelestialBody = isDestinationOnSameCelestialBody
                  })
                  if marker then
                      rAR = rAR .. marker(renderGlobals)
                  end
              end
          end
          rAR = rAR .. "</div>"
          local renderAR = STL(rAR, renderGlobals)
          if renderAR then
              return renderAR()
          end
          return ""
      end


      function wolfie.setCore(pCore)
          core = pCore
      end


      function wolfie.setRenderLimit(renderLimit)
          renderLimit = renderLimit or 0
          renderLimit = tonumber(renderLimit)
          wolfie.renderLimitKm = uclamp(renderLimit, 0, 1000000) end

      function wolfie.AddWaypoint(destName, vector)
          if not destName or type(vector) ~= "table" then return end
          wolfie.destCount = wolfie.destCount + 1
          local bodyCoordinates, bodyInfo = nil, nil
          local currentBody = getClosestCelestialBody(vector,false)
          if currentBody then
              bodyCoordinates = getLatLonAltFromWorldPosition(vector, currentBody)
              if bodyCoordinates then
                  bodyInfo = {
                      info = currentBody,
                      coordinates = bodyCoordinates
                  }
              end
          end
          local data = { name = destName, position = vec3(vector), bodyInfo = bodyInfo }
          wolfie.destList[wolfie.destCount] = data
      end


      function wolfie.onRenderFrame()
          return wolfie.render(wolfie.destList)
      end


      return wolfie

      end)

      package.preload['YFS-Tools:../util/wolfeAR_start.lua']=(function()

      local enableWaypointer=true--export: Enable waypoint AR display. Default: checked.

      local wpRenderLimit=5--export: The number of kilometers above which distance waypoints are not rendered; 0 means display all


      if not enableWaypointer then
          WP_WOLF_ENABLED = false
          return
      end


      if WM and WolfAR then
          WolfAR.setRenderLimit(wpRenderLimit)
          for _,p in ipairs(WM:getSorted()) do
              local s = PM.MapPos2String(p.mapPos)
              local wPos = PM.MapPosToWorldVec3(s);
              if s and wPos then
                  WolfAR.AddWaypoint(p.name, wPos)
                  P("[WPointer] Added "..p.name.."\r\n"..s)
              else
                  P("[E] "..p.name.."\r\n"..(s or "(none)"))
              end
          end
      end

      end)

      package.preload['YFS-Tools:unit_onTimer(update)_wolfeAR.lua']=(function()

      local timerFunc = {}


      function timerFunc.Run(timerId)
          if timerId == 'update' then
              local svg = WolfAR.onRenderFrame()
              if svg then
                  system.setScreen(svg)
                  if not INGAME then P("onTimer(update): "..svg) end
              end
          end
      end


      return timerFunc

      end)
  - key: 4
    filter:
      slotKey: -5
      signature: onStart()
      args: []
    code: |-
      library.addEventHandlers(library)
      library.addEventHandlers(system)
      library.addEventHandlers(player)
      library.addEventHandlers(construct)
      library.addEventHandlers(unit)
  - key: 5
    filter:
      slotKey: -4
      signature: onActionStart(action)
      args:
        - variable: "*"
    code: system:triggerEvent('onActionStart',action)
  - key: 6
    filter:
      slotKey: -4
      signature: onActionLoop(action)
      args:
        - variable: "*"
    code: system:triggerEvent('onActionLoop',action)
  - key: 7
    filter:
      slotKey: -4
      signature: onActionStop(action)
      args:
        - variable: "*"
    code: system:triggerEvent('onActionStop',action)
  - key: 8
    filter:
      slotKey: -4
      signature: onUpdate()
      args: []
    code: system:triggerEvent('onUpdate')
  - key: 9
    filter:
      slotKey: -4
      signature: onFlush()
      args: []
    code: system:triggerEvent('onFlush')
  - key: 10
    filter:
      slotKey: -4
      signature: onInputText(text)
      args:
        - variable: "*"
    code: system:triggerEvent('onInputText',text)
  - key: 11
    filter:
      slotKey: -4
      signature: onCameraChanged(mode)
      args:
        - variable: "*"
    code: system:triggerEvent('onCameraChanged',mode)
  - key: 12
    filter:
      slotKey: -3
      signature: onParentChanged(oldId,newId)
      args:
        - variable: "*"
        - variable: "*"
    code: player:triggerEvent('onParentChanged',oldId,newId)
  - key: 13
    filter:
      slotKey: -2
      signature: onDocked(id)
      args:
        - variable: "*"
    code: construct:triggerEvent('onDocked',id)
  - key: 14
    filter:
      slotKey: -2
      signature: onUndocked(id)
      args:
        - variable: "*"
    code: construct:triggerEvent('onUndocked',id)
  - key: 15
    filter:
      slotKey: -2
      signature: onPlayerBoarded(id)
      args:
        - variable: "*"
    code: construct:triggerEvent('onPlayerBoarded',id)
  - key: 16
    filter:
      slotKey: -2
      signature: onVRStationEntered(id)
      args:
        - variable: "*"
    code: construct:triggerEvent('onVRStationEntered',id)
  - key: 17
    filter:
      slotKey: -2
      signature: onConstructDocked(id)
      args:
        - variable: "*"
    code: construct:triggerEvent('onConstructDocked',id)
  - key: 18
    filter:
      slotKey: -2
      signature: onPvPTimer(active)
      args:
        - variable: "*"
    code: construct:triggerEvent('onPvPTimer',active)
  - key: 19
    filter:
      slotKey: -1
      signature: onStop()
      args: []
    code: unit:triggerEvent('onStop')
  - key: 20
    filter:
      slotKey: -1
      signature: onTimer(timerId)
      args:
        - variable: "*"
    code: unit:triggerEvent('onTimer',timerId)
  - key: 21
    filter:
      slotKey: -1
      signature: onStart()
      args: []
    code: >-
      package.path = "lua/?.lua;util/wpointer/?.lua;"..package.path

      require('YFS-Tools:globals.lua')


      WP_EG_ENABLED = false


      WP_WOLF_ENABLED = true


      DEBUG = false

      require('YFS-Tools:libmain.lua')


      if INGAME then
          local Traceback = traceback
      else
          function Traceback(o)
              if o then P(tostring(o)) end
          end
          require 'mockaround'
      end


      local status, err, _ = xpcall(function() require('YFS-Tools:startup.lua') end, Traceback)

      if not status then
          P("[E] Error in startup!")
          if err then P(err) end
          unit.exit()
          return
      end


      local inp = require('YFS-Tools:sys_onInputText.lua')

      if inp ~= nil then
          system:onEvent('onInputText', function (self, text) inp.Run(text) end)
      end




      if WP_WOLF_ENABLED and Config.core then
          WolfAR = require('YFS-Tools:../util/wolfeARlib.lua')
          require('YFS-Tools:../util/wolfeAR_start.lua')
          if WP_WOLF_ENABLED then
              WolfAR.setCore(Config.core)
              onT = require('YFS-Tools:unit_onTimer(update)_wolfeAR.lua')
              if onT ~= nil then
                  unit:onEvent('onTimer', function (unit, id) onT.Run("update") end)
              end
          end
      end


      if not WP_EG_ENABLED and not WP_WOLF_ENABLED then
          P('[I] Waypointer module disabled.')
      else
          P('[I] Waypointer module enabled.')

          unit.setTimer("update", 1/120)     system.showScreen(1)
      end


      if INGAME then
          if DEBUGx then
              status, err, _ = xpcall(function() PM.ConversionTest() end, Traceback)
              if not status then
                  if err then P("[E] Error in test call:\n" .. err) end
                  unit.exit()
                  return
              end
          else
              unit.hideWidget()
          end
          P("Type /help for available commands.")

      end
events: []
methods: []
